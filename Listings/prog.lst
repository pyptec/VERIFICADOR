C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PROG
OBJECT MODULE PLACED IN .\Objects\prog.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE prog.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\prog.lst) TABS(2) OBJECT(.\Objects\prog.obj)

line level    source

   1          
   2          #include "prog.h" 
   3          #include <string.h>
   4          extern int printf   (const char *, ...);
   5          extern char putchar (char);
   6          extern char getchar (void);
   7          extern char  *strtok  (char *str, const char *set);
   8          extern char   strcmp  (const char *s1, const char *s2);
   9          extern char  *strcpy  (char *s1, const char *s2);
  10          extern char _getkey (void);
  11          extern char  *strcat  (char *s1, const char *s2);
  12          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  13          extern void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom);
  14          extern int sprintf  (char *, const char *, ...);
  15          extern int    atoi (const char *s1);
  16          extern void LeerMemoria(unsigned int addres, unsigned char *res);
  17          extern void EscribirMemoria(unsigned int addres,unsigned char *res);
  18          extern char check_fechaOut(char *buffer);
  19          extern void Block_read_clock_ascii(unsigned char *datos_clock);
  20          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  21          extern char check_fechaOut_2(char *buffer);
  22          
  23          unsigned char cursor[20] = "/"; //current working directory
  24          unsigned char validacion [9]={"admin"}; //usuario
  25          
  26          #define True                    0x01
  27          #define False                   0x00
  28          
  29          
  30          /*define posiciones de memoria*/
  31          #define EE_ID_CLIENTE         0x0000
  32          #define EE_ID_PARK            0x0002
  33          #define EE_TIEMPO_GRACIA      0x0004
  34          #define EE_SIN_COBRO          0x0006
  35          #define EE_DEBUG              0x0008
  36          #define EE_USE_LPR            0x000A
  37          #define EE_CPRCN_ACTIVA       0x000C
  38          #define EE_TIPO_PANTALLA      0X000E
  39          #define EE_DCTO_PASA_CAJA     0X000F
  40          #define EE_ADDRESS_HIGH_BOARD   0X0012
  41          #define EE_JUST_ONE_TIME_CLAVE  0X0013
  42          #define EE_HABILITA_APB_MENSUAL 0X0015
  43          #define EE_HORARIO_1            0X0019
  44          #define EE_HORARIO_2            0x0032
  45          #define EE_HORARIO_3            0x004b
  46          #define EE_HORARIO_4            0x0064
  47          #define EE_HORARIO_5            0x007d
  48          #define EE_HORARIO_6            0x0096
  49          #define EE_HORARIO_7            0x00af
  50          #define EE_HORARIO_8            0x00c8
  51          #define EE_HORARIO_9            0x00e1
  52          #define EE_HORARIO_10           0x00fa
  53          
  54          #define EE_ID_REGISTER          0x0300
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 2   

  55          #define EE_FECHA_VENCIMIENTO    0X0350
  56          /* Definicion del tamaño de comando y longitud de cmd*/
  57          
  58          #define   NUMCOMMAND 16
  59          #define   LONGSIZE 3
  60          
  61          
  62          
  63          enum ee_horario_addr{
  64            ee_horario1_addr, ee_horario2_addr, ee_horario3_addr, ee_horario4_addr, ee_horario5_addr,
  65            ee_horario6_addr, ee_horario7_addr, ee_horario8_addr, ee_horario9_addr, ee_horario10_addr,
  66            ee_horarioNULL_addr
  67          };
  68          
  69          
  70          enum Dia_Semana_addr{
  71            Lunes_addr = 1, Martes_addr = 2, Miercoles_addr = 3, Jueves_addr =4, Viernes_addr = 5, 
  72            Sabado_addr = 6, Domingo_addr =0 
  73          };
  74          enum Dia_Semana_data{
  75            Domingo_dato=0x31, Lunes_dato=0x32, Martes_dato=0x33, Miercoles_dato=0x34, Jueves_dato=0x35, Viernes_dato
             -=0x36, Sabado_dato=0x37  
  76          };
  77          enum Hora_Minutos_addr{
  78            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
  79            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14,
  80            Habilita_addr =15, Segundo_Tiempo=16
  81          };
  82          enum Hora_Minutos_data{
  83              Hora_High_data = 0, Hora_Low_data = 1, Minutos_High_data = 3, Minutos_Low_data =4
  84          };
  85          
  86          char comandos[NUMCOMMAND][LONGSIZE]=
  87          {
  88            "0",          //ID_CLIENTEValor del punto cero.
  89            "1",       //COD_PARKTiempo de recolecion entre muestra
  90            "2",    // T_GRACIAInformacion recolectada enviada al rs232
  91            "3",    //SIN_COBROAjuste del cero del sensor
  92            "4",  //DEBUG Calibracion por la curva de la pendiente
  93            "5",    //USE_LPR
  94            "6",//COMPARACION_ACTIVA
  95            "7",      //TIPO_PANTALLA
  96            "8",      //DCTO por caja
  97            "9",    // habilita apb para mensual
  98            "10",   // direccion logico
  99            "11",     // prog horario
 100            "12",     // ver cmd programados
 101            "13",     //AYUDA Ayuda!muestra todos los comandos
 102            "14",   //SALIRSalir de programacion
 103            "15"    ////cmd escondido fecha de vencimiento password
 104          };
 105          
 106          /*------------------------------------------------------------------------------
 107          Rutina que encripta la clave q se le envie
 108          len_clave= longitud de la clave a encriptar
 109          aleatorio=numero aleatoria para escoger el dato a sumar y para la or
 110          
 111          ------------------------------------------------------------------------------*/
 112          unsigned char *hash_id(unsigned char *clave)
 113          {
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 3   

 114   1        unsigned char len_clave,i;
 115   1        static unsigned int temp, temp1;
 116   1        unsigned char aleatorio []={":[<%?XT]=)" };
 117   1        unsigned char suma []={"#*YJAIMEcamiltK"};/*caracteres q se le suman a la trama */
 118   1        unsigned char xxor []={"wrz25q68-91fS.@" };
 119   1        unsigned char usuario1[11];
 120   1        unsigned char vencimiento_password [4];
 121   1        
 122   1        LeerMemoria(EE_FECHA_VENCIMIENTO,vencimiento_password); 
 123   1        if (check_fechaOut_2(vencimiento_password) != True)
 124   1          
 125   1        {
 126   2          printf("\n CONTRASEÑA ACTUAL VENCIDA DEBE RENOVAR FECHA VENCIMIENTO \n"); 
 127   2          strcpy(aleatorio,"@#!$`Fb^&*");
 128   2        }
 129   1        else
 130   1        {
 131   2          strcpy(aleatorio, ":[<%?XT]=)");
 132   2        }
 133   1        
 134   1        len_clave=strlen(clave);                      /*longitud de la clave a encriptar*/
 135   1        for (i=0; i<10;i++)
 136   1        {
 137   2          temp=*(clave+i)+aleatorio[i];               /*el primer caracter de la clave se le suma con el primero de los a
             -leatorios*/
 138   2          temp1=temp & 15;                            /*al  resultado se le hace una and con (0x0f)*/
 139   2          if (temp1==0)temp1++; 
 140   2          temp=*(clave+i) + suma[temp1-1];            /*se suma la clave  con el arreglo suma y el valor del arreglo bie
             -ne de  aleatorio el resultado q da en temp */
 141   2          temp1=temp & 15;
 142   2          if (temp1==0)temp1++;
 143   2          temp=temp ^ xxor[temp1-1];                  /*temp se le hace uan xor aleatoria*/
 144   2          if (temp > 255)
 145   2          {
 146   3            temp=temp & 255;
 147   3          }     
 148   2          if ((temp >=122)&&(temp<=255))
 149   2          {
 150   3          temp=temp & 122;
 151   3          
 152   3          }
 153   2          if (temp < 48)
 154   2          {
 155   3            temp=temp+64;
 156   3          }
 157   2          if ((temp>=91)&&(temp<=96))
 158   2          {
 159   3            temp=temp +7 ;
 160   3          }
 161   2          if ((temp>=58)&&(temp<=64))
 162   2          {
 163   3            temp=temp - 7 ;
 164   3          }
 165   2          usuario1[i]=temp;
 166   2          
 167   2        }
 168   1        usuario1[10]=0;
 169   1        return usuario1;
 170   1      }
 171          
 172          
 173          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 4   

 174          Rutina de lista de comandos 
 175          ------------------------------------------------------------------------------*/
 176          
 177          unsigned char ListaComandos(unsigned char *cmd)
 178          {
 179   1         unsigned char buf[LONGSIZE];
 180   1         unsigned char i;
 181   1         
 182   1         for (i=0; i<NUMCOMMAND; i++)
 183   1         {
 184   2            strcpy(buf, &comandos[i][0]);
 185   2            if (strcmp(buf, cmd)==0)
 186   2               return(i);
 187   2         }
 188   1         
 189   1         return(0xFF);
 190   1      }
 191          
 192          
 193          /*------------------------------------------------------------------------------
 194          Rutina que valida la clave
 195          ------------------------------------------------------------------------------*/
 196          unsigned char  ValidarClave(unsigned char *buffer)
 197          {
 198   1      unsigned char buf [7];
 199   1        
 200   1            strcpy(buf, &validacion[0]);
 201   1            if (strcmp(buf, buffer)==0)
 202   1               return(0);
 203   1       
 204   1         
 205   1         return(0xFF);
 206   1      }
 207          
 208          
 209          
 210          /*------------------------------------------------------------------------------
 211          Rutina que busca el \
 212          ------------------------------------------------------------------------------*/
 213          unsigned char * GetCMD(unsigned char *in)
 214          {
 215   1         char tokens[]=" \r\n";
 216   1         return(strtok(in,tokens));
 217   1      }
 218          
 219          /*------------------------------------------------------------------------------
 220          Rutina de 
 221          ------------------------------------------------------------------------------*/
 222          unsigned char * GetOption(unsigned char *in)
 223          {
 224   1         unsigned char tokensSpace[]=" \r\n";
 225   1         unsigned char tokensQuote[]="\"\r\n";
 226   1         
 227   1         //trim leading spaces
 228   1         while (*in==' ')
 229   1            in++;
 230   1         
 231   1         //if first char is a quote, then end token on a quote.  ELSE end token on a space
 232   1         if (*in == '\"')
 233   1            return(strtok(in,tokensQuote));
 234   1         else
 235   1            return(strtok(in,tokensSpace));
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 5   

 236   1      } 
 237          /*------------------------------------------------------------------------------
 238          Rutina de muestra el cursor
 239          ------------------------------------------------------------------------------*/
 240          
 241          void DisplayCursor(void)
 242          {
 243   1         printf("\r\n\n%s> ", cursor);
 244   1      }
 245          
 246          /*------------------------------------------------------------------------------
 247          Rutina que captura los datos pto serie y los muestra en el pto
 248          ------------------------------------------------------------------------------*/
 249          
 250          void IngresaDato(unsigned char  *buffer, unsigned char modo)
 251          {
 252   1      
 253   1       int i;
 254   1       
 255   1        do
 256   1        { 
 257   2          *buffer = _getkey();
 258   2        if (modo == 0) 
 259   2          {
 260   3             printf("%c", *buffer);
 261   3          }
 262   2          else 
 263   2          {
 264   3            putchar('*');
 265   3          }
 266   2           i=*buffer; 
 267   2           buffer++;
 268   2          *buffer='\0'; 
 269   2          
 270   2        } while(i != '\r');
 271   1          
 272   1            
 273   1               
 274   1      } 
 275          /*
 276          void LeerMemoria(unsigned int  addres,unsigned char  *res)
 277          {
 278          unsigned char i;
 279            do {
 280              *res=rd_eeprom(0xa8,addres);
 281              i=*res;
 282              addres++;
 283              res++;
 284              }while(i !='\0');
 285              *res='\0';
 286          }
 287          */
 288          /*------------------------------------------------------------------------------
 289          Rutina que programa el id_cliente en eeprom
 290          ------------------------------------------------------------------------------*/
 291          void prog_id_cliente()
 292          {
 293   1        unsigned char buffer[10];
 294   1        unsigned int dataee;
 295   1        
 296   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
 297   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 6   

 298   1        
 299   1        printf("\r\n\n ACTUAL ID_CLIENTE=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en pan
             -talla*/
 300   1        
 301   1        printf("\r\n\n DIGITE SU NUEVO ID_CLIENTE=");                                 /*digite el nuevo id_cliente*/
 302   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 303   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 304   1        wr_eeprom(0xa8,EE_ID_CLIENTE,dataee);                                         /*grabo el dato en la eeprom*/
 305   1        
 306   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*leo el dato grabado*/
 307   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 308   1        printf("\r\n\n DATO MODIFICADO ID_CLIENTE=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato 
             -grabado*/
 309   1      }
 310          /*------------------------------------------------------------------------------
 311          Rutina que programa el cod_park
 312          ------------------------------------------------------------------------------*/
 313          void prog_cod_park()
 314          {
 315   1        unsigned char buffer[10];
 316   1        unsigned int dataee;
 317   1        
 318   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
 319   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 320   1        
 321   1        printf("\r\n\n ACTUAL COD_PARK=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual en panta
             -lla*/
 322   1        
 323   1        printf("\r\n\n DIGITE SU NUEVO COD_PARK=");                                 /*digite el nuevo id_cliente*/
 324   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 325   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 326   1        wr_eeprom(0xa8,EE_ID_PARK,dataee);                                          /*grabo el dato en la eeprom*/
 327   1        
 328   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*leo el dato grabado*/
 329   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 330   1        printf("\r\n\n DATO MODIFICADO COD_PARK=%s\r\n\n",buffer);                  /*lo muetro por la pantalla el dato gr
             -abado*/
 331   1      }
 332          /*------------------------------------------------------------------------------
 333          Rutina que programa el tiempo de gracia de cobro (00) no tiene tiempo de gracia
 334          ------------------------------------------------------------------------------*/
 335          void Prog_tiempo_gracia()
 336          {
 337   1        unsigned char buffer[10];
 338   1        unsigned int dataee;
 339   1        
 340   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                          /*se lee el id_cliente actual */
 341   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 342   1        
 343   1        printf("\r\n\n ACTUAL TIEMPO_GRACIA=%s\r\n\n",buffer);                            /*se muestra el id_cliente actual en 
             -pantalla*/
 344   1        
 345   1        printf("\r\n\n DIGITE SU NUEVO TIEMPO_GRACIA=");                                  /*digite el nuevo id_cliente*/
 346   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 347   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 348   1        wr_eeprom(0xa8,EE_TIEMPO_GRACIA,dataee);                                          /*grabo el dato en la eeprom*/
 349   1        
 350   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                        /*leo el dato grabado*/
 351   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 352   1        printf("\r\n\n DATO MODIFICADO TIEMPO_GRACIA=%s\r\n\n",buffer);               /*lo muetro por la pantalla el dat
             -o grabado*/
 353   1      }
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 7   

 354          /*------------------------------------------------------------------------------
 355          Rutina que programa SIN COBRO
 356          SIN_COBRO=0 inhabilitado, SIN_COBRO=1 sin cobro, SIN_COBRO=2 sin cobro y salida el mismo dia");
 357          ------------------------------------------------------------------------------*/
 358          void Prog_Sin_Cobro()
 359          {
 360   1        
 361   1      
 362   1        unsigned char buffer[10];
 363   1        unsigned int dataee;
 364   1      
 365   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                          /*se lee el id_cliente actual */
 366   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 367   1        if(dataee==0)
 368   1        {
 369   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 370   2        }
 371   1        else if (dataee==1)
 372   1        {
 373   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 374   2        }
 375   1        else 
 376   1        {
 377   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 378   2        }
 379   1        
 380   1        printf("\r\n\n DIGITE SU NUEVO SIN_COBRO=");                                  /*digite el nuevo id_cliente*/
 381   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 382   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 383   1        wr_eeprom(0xa8,EE_SIN_COBRO,dataee);                                          /*grabo el dato en la eeprom*/
 384   1        
 385   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                        /*leo el dato grabado*/
 386   1        sprintf(buffer,"%d",dataee);                                                  /*lo convierto a un string*/
 387   1        if(dataee==0)
 388   1        {
 389   2          printf("\r\n\n ACTUAL SIN_COBRO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
 390   2        }
 391   1        else if (dataee==1)
 392   1        {
 393   2          printf("\r\n\n ACTUAL SIN_COBRO GRATIS=%s\r\n\n",buffer);   
 394   2        }
 395   1        else 
 396   1        {
 397   2            printf("\r\n\n ACTUAL SIN_COBRO GRATIS Y SALIDA EL MISMO DIA=%s\r\n\n",buffer);   
 398   2        }
 399   1        
 400   1      }
 401          /*------------------------------------------------------------------------------------
 402          Rutina que habilita el debuger
 403           Habilita = 1 ; 
 404          inahabilita = 0;
 405          --------------------------------------------------------------------------------------*/
 406          void Prog_debug()
 407          {
 408   1        unsigned char buffer[10];
 409   1        unsigned int dataee;
 410   1      
 411   1        
 412   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
 413   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 8   

 414   1        if(dataee==0)
 415   1        {
 416   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 417   2        }
 418   1        else
 419   1        {
 420   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 421   2        }
 422   1        
 423   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE DEBUG=");                                  /*digite el nuevo id_cliente*/
 424   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 425   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 426   1        wr_eeprom(0xa8,EE_DEBUG,dataee);                                          /*grabo el dato en la eeprom*/
 427   1        
 428   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                        /*leo el dato grabado*/
 429   1        sprintf(buffer,"%d",dataee);  
 430   1        if(dataee==0)
 431   1        {
 432   2          printf("\r\n\n ACTUAL DEBUG INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 433   2        }
 434   1        else
 435   1        {
 436   2          printf("\r\n\n ACTUAL DEBUG HABILITADO=%s\r\n\n",buffer);     
 437   2        }
 438   1      }
 439          /*------------------------------------------------------------------------------------
 440          
 441          --------------------------------------------------------------------------------------*/
 442          
 443          void Prog_Use_Lpr()
 444          {
 445   1          unsigned char buffer[10];
 446   1        unsigned int dataee;
 447   1      
 448   1        
 449   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
 450   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 451   1        if(dataee==0)
 452   1        {
 453   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 454   2        }
 455   1        else
 456   1        {
 457   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 458   2        }
 459   1        
 460   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE USE_LPR=");                                  /*digite el nuevo id_cliente*/
 461   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 462   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 463   1        wr_eeprom(0xa8,EE_USE_LPR,dataee);                                          /*grabo el dato en la eeprom*/
 464   1        
 465   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                        /*leo el dato grabado*/
 466   1        sprintf(buffer,"%d",dataee);  
 467   1        if(dataee==0)
 468   1        {
 469   2          printf("\r\n\n ACTUAL USE_LPR INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 470   2        }
 471   1        else
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 9   

 472   1        {
 473   2          printf("\r\n\n ACTUAL USE_LPR HABILITADO=%s\r\n\n",buffer);     
 474   2        }
 475   1      }
 476          /*------------------------------------------------------------------------------------
 477          Compara la placa de la tarjeta y la del software
 478          --------------------------------------------------------------------------------------*/
 479          void Prog_Comparacion_Activa()
 480          {
 481   1        unsigned char buffer[10];
 482   1        unsigned int dataee;
 483   1      
 484   1        
 485   1        dataee=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);                                         /*se lee el id_cliente actual */
 486   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 487   1        if(dataee==0)
 488   1        {
 489   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el id
             -_cliente actual en pantalla*/
 490   2        }
 491   1        else
 492   1        {
 493   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADO=%s\r\n\n",buffer);     
 494   2        }
 495   1        
 496   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE COMPARACION ACTIVA =");                                  /*digite el nuevo id_cli
             -ente*/
 497   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 498   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 499   1        wr_eeprom(0xa8,EE_CPRCN_ACTIVA,dataee);                                         /*grabo el dato en la eeprom*/
 500   1        
 501   1        dataee=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);                                       /*leo el dato grabado*/
 502   1        sprintf(buffer,"%d",dataee);  
 503   1        if(dataee==0)
 504   1        {
 505   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el i
             -d_cliente actual en pantalla*/
 506   2        }
 507   1        else
 508   1        {
 509   2          printf("\r\n\n ACTUAL COMPARACION ACTIVA  HABILITADO=%s\r\n\n",buffer);     
 510   2        }
 511   1      }
 512          /*------------------------------------------------------------------------------------
 513          cmd del tipo de pantalla a usar
 514          Rasberry = 1
 515          lcd = 0
 516          --------------------------------------------------------------------------------------*/
 517          void tipo_pantalla()
 518          {
 519   1        unsigned char buffer[10];
 520   1        unsigned int dataee;
 521   1      
 522   1        
 523   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
 524   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 525   1        if(dataee==0)
 526   1        {
 527   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 528   2        }
 529   1        else
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 10  

 530   1        {
 531   2          printf("\r\n\n PANTALLA RASPBERRY  HABILITADA=%s\r\n\n",buffer);      
 532   2        }
 533   1        
 534   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE LA PANTALLA =");                                 /*digite el nuevo id_cliente*/
 535   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 536   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 537   1        wr_eeprom(0xa8,EE_TIPO_PANTALLA,dataee);                                          /*grabo el dato en la eeprom*/
 538   1        
 539   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                        /*leo el dato grabado*/
 540   1        sprintf(buffer,"%d",dataee);  
 541   1        if(dataee==0)
 542   1        {
 543   2          printf("\r\n\n PANTALLA LCD HABILITADA=%s\r\n\n",buffer);                           /*se muestra el id_cliente actual
             - en pantalla*/
 544   2        }
 545   1        else
 546   1        {
 547   2          printf("\r\n\n PANTALLA RASPBERRY  HABILITADA=%s\r\n\n",buffer);      
 548   2        }
 549   1        
 550   1      }
 551          /*------------------------------------------------------------------------------------
 552          cmd que habilita si pasa por caja si no
 553          (0) pasa por caja
 554          (1) aplica el descuento
 555          ------------------------------------------------------------------------------------*/
 556          void dcto_caja()
 557          {
 558   1        unsigned char buffer[10];
 559   1        unsigned int dataee;
 560   1      
 561   1        
 562   1        dataee=rd_eeprom(0xa8,EE_DCTO_PASA_CAJA);                                         /*se lee el id_cliente actual */
 563   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 564   1        if(dataee==0)
 565   1        {
 566   2          printf("\r\n\n PASA POR CAJA PARA VALIDAR DCTO=%s\r\n\n",buffer);                           /*se muestra el id_client
             -e actual en pantalla*/
 567   2        }
 568   1        else
 569   1        {
 570   2          printf("\r\n\n APLICA DESCUENTO=%s\r\n\n",buffer);      
 571   2        }
 572   1        
 573   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE DCTO =");                                  /*digite el nuevo id_cliente*/
 574   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 575   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 576   1        wr_eeprom(0xa8,EE_DCTO_PASA_CAJA,dataee);                                         /*grabo el dato en la eeprom*/
 577   1        
 578   1        dataee=rd_eeprom(0xa8,EE_DCTO_PASA_CAJA);                                       /*leo el dato grabado*/
 579   1        sprintf(buffer,"%d",dataee);  
 580   1        if(dataee==0)
 581   1        {
 582   2          printf("\r\n\n PASA POR CAJA PARA VALIDAR DCTO=%s\r\n\n",buffer);                           /*se muestra el id_client
             -e actual en pantalla*/
 583   2        }
 584   1        else
 585   1        {
 586   2          printf("\r\n\n APLICA DESCUENTO=%s\r\n\n",buffer);      
 587   2        }
 588   1      }
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 11  

 589          void Prog_Apb_Mensual()
 590          {
 591   1        unsigned char buffer[10];
 592   1        unsigned int dataee;
 593   1      
 594   1        
 595   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                         /*se lee el id_cliente actual */
 596   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 597   1        if(dataee==0)
 598   1        {
 599   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
 600   2        }
 601   1        else
 602   1        {
 603   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL HABILITADO=%s\r\n\n",buffer);      
 604   2        }
 605   1        
 606   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE ANTIPASSBACK MENSUAL=");                                 /*digite el nuevo id_cl
             -iente*/
 607   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 608   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 609   1        wr_eeprom(0xa8,EE_HABILITA_APB_MENSUAL,dataee);                                         /*grabo el dato en la eeprom*/
 610   1        
 611   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                       /*leo el dato grabado*/
 612   1        sprintf(buffer,"%d",dataee);  
 613   1        if(dataee==0)
 614   1        {
 615   2          printf("\r\n\n ACTUAL ANTIPASSBACK MENSUAL INHABILITADO=%s\r\n\n",buffer);                            /*se muestra el 
             -id_cliente actual en pantalla*/
 616   2        }
 617   1        else
 618   1        {
 619   2          printf("\r\n\n ACTUAL ANTIPASSBACK  MENSUAL HABILITADO=%s\r\n\n",buffer);     
 620   2        }
 621   1      }
 622          void Prog_Address_High_Board()
 623          {
 624   1        unsigned char buffer[10];
 625   1        unsigned int dataee;
 626   1      
 627   1        /*solo para monitor*/
 628   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                         /*se lee el id_cliente actual */
 629   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 630   1        if(dataee==0)
 631   1        {
 632   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 633   2        }
 634   1        else
 635   1        {
 636   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 637   2        }
 638   1        
 639   1        printf("\r\n\n DIGITE LA NUEVA ADDRESS_HIGH_BOARD=");                                 /*digite el nuevo id_cliente*/
 640   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 641   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 642   1        wr_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD,dataee);                                         /*grabo el dato en la eeprom*/
 643   1        
 644   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                       /*leo el dato grabado*/
 645   1        sprintf(buffer,"%d",dataee);  
 646   1        if(dataee==0)
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 12  

 647   1        {
 648   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);                           /*se muestra el id_cliente actu
             -al en pantalla*/
 649   2        }
 650   1        else
 651   1        {
 652   2          printf("\r\n\n ACTUAL ADDRESS_HIGH_BOARD=%s\r\n\n",buffer);     
 653   2        }
 654   1      }
 655          unsigned char *Addr_Horarios()
 656          {
 657   1        unsigned char ee_addr_horario[11];
 658   1          /*direcciones de memoria de almacenamiento*/
 659   1        ee_addr_horario[ee_horario1_addr]= EE_HORARIO_1;
 660   1        ee_addr_horario[ee_horario2_addr]= EE_HORARIO_2;
 661   1        ee_addr_horario[ee_horario3_addr]= EE_HORARIO_3;
 662   1        ee_addr_horario[ee_horario4_addr]= EE_HORARIO_4;
 663   1        ee_addr_horario[ee_horario5_addr]= EE_HORARIO_5;
 664   1        ee_addr_horario[ee_horario6_addr]= EE_HORARIO_6;
 665   1        ee_addr_horario[ee_horario7_addr]= EE_HORARIO_7;
 666   1        ee_addr_horario[ee_horario8_addr]= EE_HORARIO_8;
 667   1        ee_addr_horario[ee_horario9_addr]= EE_HORARIO_9;
 668   1        ee_addr_horario[ee_horario10_addr]= EE_HORARIO_10;
 669   1        ee_addr_horario[ee_horarioNULL_addr] = False;
 670   1        return ee_addr_horario;
 671   1      }
 672          unsigned char Prog_Horarios_on_off(unsigned int addr)
 673          {
 674   1        unsigned char buffer[10];
 675   1        unsigned int dataee,habilitado;
 676   1        dataee = rd_eeprom(0xa8,addr);                                          /*se lee el id_cliente actual */
 677   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
 678   1        if(dataee==0)
 679   1        {
 680   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 681   2        }
 682   1        else
 683   1        {
 684   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 685   2        }
 686   1        printf("\r\n\n DIGITE EL NUEVO ESTADO DE HORARIO=");                                  /*digite el nuevo id_cliente*/
 687   1        IngresaDato(buffer,0);                                                        /*trae el dato digitado*/
 688   1        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 689   1        wr_eeprom(0xa8,addr,dataee);                                          /*grabo el dato en la eeprom*/
 690   1        
 691   1        dataee=rd_eeprom(0xa8,addr);                                        /*leo el dato grabado*/
 692   1        sprintf(buffer,"%d",dataee);  
 693   1        if(dataee==0)
 694   1        {
 695   2          habilitado= False;
 696   2          printf("\r\n\n ACTUAL HORARIO INHABILITADO=%s\r\n\n",buffer);                           /*se muestra el id_cliente ac
             -tual en pantalla*/
 697   2        }
 698   1        else
 699   1        {
 700   2          habilitado=True;
 701   2          printf("\r\n\n ACTUAL HORARIO HABILITADO=%s\r\n\n",buffer);     
 702   2        }
 703   1        return habilitado;
 704   1      }
 705          void Prog_Horario_Desde_Hasta(unsigned int addr)
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 13  

 706          {
 707   1          unsigned char buffer[10];
 708   1          unsigned char dataee;
 709   1        /*la hora de inicio del horario*/
 710   1        
 711   1        printf("\r\n\n Digite Hora 08:00 Minutos Desde: ");
 712   1        IngresaDato(buffer,0);
 713   1        printf("\r\n\n Hora Programada Desde: ");
 714   1        wr_eeprom(0xa8, addr + Hora_High_addr_Desde,buffer[Hora_High_data]);
 715   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Desde);
 716   1        printf("%c",dataee);
 717   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Desde ,buffer[Hora_Low_data]);
 718   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Desde); //
 719   1        printf("%c:",dataee);
 720   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Desde,buffer[Minutos_High_data]);
 721   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Desde);
 722   1        printf("%c",dataee);
 723   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Desde,buffer[Minutos_Low_data]);
 724   1        dataee = rd_eeprom(0xa8,addr +  Minutos_Low_addr_Desde);
 725   1        printf("%c",dataee);
 726   1      
 727   1      /*la hora de final del horario*/
 728   1      
 729   1        printf("\r\n\n Digite Hora:Minutos Hasta: ");
 730   1        IngresaDato(buffer,0);
 731   1        
 732   1        printf("\r\n\n Hora Programada Hasta: ");
 733   1      
 734   1        wr_eeprom(0xa8,addr + Hora_High_addr_Hasta,buffer[Hora_High_data]);
 735   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Hasta);
 736   1        printf("%c",dataee);
 737   1        wr_eeprom(0xa8,addr + Hora_Low_addr_Hasta ,buffer[Hora_Low_data]);
 738   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Hasta);
 739   1        printf("%c:",dataee);
 740   1        wr_eeprom(0xa8,addr + Minutos_High_addr_Hasta,buffer[Minutos_High_data]);
 741   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Hasta);
 742   1        printf("%c",dataee);
 743   1        wr_eeprom(0xa8,addr + Minutos_Low_addr_Hasta ,buffer[Minutos_Low_data]);
 744   1        dataee = rd_eeprom(0xa8,addr + Minutos_Low_addr_Hasta);
 745   1        printf("%c",dataee);
 746   1      }
 747          void Ver_Horario_Desde_Hasta(unsigned int addr)
 748          {
 749   1        unsigned char dataee;
 750   1        printf("\r\n Desde  Hasta\r\n");
 751   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Desde);
 752   1        printf(" %c",dataee);
 753   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Desde); //
 754   1        printf("%c:",dataee);
 755   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Desde);
 756   1        printf("%c",dataee);
 757   1        dataee = rd_eeprom(0xa8,addr +  Minutos_Low_addr_Desde);
 758   1        printf("%c   ",dataee); 
 759   1          /*hasta*/
 760   1        dataee = rd_eeprom(0xa8,addr + Hora_High_addr_Hasta);
 761   1        printf("%c",dataee);
 762   1        
 763   1        dataee = rd_eeprom(0xa8,addr + Hora_Low_addr_Hasta);
 764   1        printf("%c:",dataee);
 765   1        
 766   1        dataee = rd_eeprom(0xa8,addr + Minutos_High_addr_Hasta);
 767   1        printf("%c",dataee);
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 14  

 768   1        
 769   1        dataee = rd_eeprom(0xa8,addr + Minutos_Low_addr_Hasta);
 770   1        printf("%c",dataee);
 771   1      }
 772          void Prog_Horario_dias(unsigned int addr)
 773          {
 774   1        unsigned char buffer[10];
 775   1        unsigned char dataee, j, temp;
 776   1        /*los dias programados*/
 777   1        printf("\r\n\n Digite los dias a programar Lunes = 2, ");
 778   1        printf("Martes = 3, Miercoles = 4, Jueves = 5, ");
 779   1        printf("Viernes = 6, Sabado = 7, Domingo = 1 : ");
 780   1        IngresaDato(buffer,0);
 781   1        
 782   1        
 783   1        printf("\r\n\n Dias Programados : ");
 784   1        
 785   1        for(j=0; j < 8 ; j++)
 786   1        {
 787   2          
 788   2          if ((temp=buffer[j]) == Lunes_dato) 
 789   2          {
 790   3            printf(" Lunes");
 791   3          
 792   3            wr_eeprom(0xa8,addr+Lunes_addr,Lunes_dato); 
 793   3            dataee=rd_eeprom(0xa8,addr+Lunes_addr); 
 794   3            printf("= %c,",dataee);
 795   3          }
 796   2          
 797   2          if ((temp=buffer[j]) == Martes_dato)
 798   2          {
 799   3            printf(" Martes");
 800   3            wr_eeprom(0xa8,addr+Martes_addr,Martes_dato);
 801   3            dataee=rd_eeprom(0xa8,addr+Martes_addr);  
 802   3            printf("= %c,",dataee);
 803   3          }
 804   2        
 805   2          if ((temp=buffer[j])== Miercoles_dato)
 806   2          {
 807   3            printf(" Miercoles");
 808   3            wr_eeprom(0xa8,addr+Miercoles_addr,Miercoles_dato);
 809   3            dataee=rd_eeprom(0xa8,addr+Miercoles_addr); 
 810   3            printf("= %c,",dataee);
 811   3          }
 812   2          
 813   2          if ((temp=buffer[j]) == Jueves_dato)
 814   2          {
 815   3            printf(" Jueves");
 816   3            wr_eeprom(0xa8,addr+Jueves_addr,Jueves_dato);
 817   3            dataee=rd_eeprom(0xa8,addr+Jueves_addr);  
 818   3            printf("= %c,",dataee);
 819   3          }
 820   2          
 821   2          if ((temp=buffer[j]) == Viernes_dato)
 822   2          { 
 823   3            printf(" Viernes");
 824   3            wr_eeprom(0xa8,addr+Viernes_addr,Viernes_dato);
 825   3            dataee=rd_eeprom(0xa8,addr+Viernes_addr); 
 826   3            printf("= %c,",dataee);
 827   3          }
 828   2          
 829   2          if ((temp=buffer[j]) == Sabado_dato) 
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 15  

 830   2          {
 831   3            printf(" Sabado");
 832   3            wr_eeprom(0xa8,addr+Sabado_addr,Sabado_dato);
 833   3            dataee=rd_eeprom(0xa8,addr+Sabado_addr);  
 834   3            printf("= %c,",dataee);
 835   3          }
 836   2          
 837   2          if ((temp=buffer[j]) == Domingo_dato)
 838   2          {
 839   3            printf(" Domingo");
 840   3            wr_eeprom(0xa8,addr+Domingo_addr,Domingo_dato);
 841   3            dataee = rd_eeprom(0xa8,addr+Domingo_addr); 
 842   3            printf("= %c",dataee);
 843   3          }
 844   2        }
 845   1        
 846   1      }
 847          void Ver_Horario_dias(unsigned int addr)
 848          {
 849   1        unsigned char dataee;
 850   1        /*Lunes*/
 851   1        dataee=rd_eeprom(0xa8,addr+Lunes_addr); 
 852   1          if(dataee == Lunes_dato)
 853   1          {
 854   2          printf(" Lunes = Programado\r\n");
 855   2          }
 856   1          else
 857   1          {
 858   2          printf(" Lunes = No programado\r\n");
 859   2          }
 860   1          /*Martes*/
 861   1          
 862   1          dataee=rd_eeprom(0xa8,addr+Martes_addr);  
 863   1          if(dataee == Martes_dato)
 864   1          {
 865   2          printf(" Martes = Programado\r\n");
 866   2          }
 867   1          else
 868   1          {
 869   2          printf(" Martes = No programado\r\n");
 870   2          }
 871   1          
 872   1          /*Miercoles*/
 873   1          dataee=rd_eeprom(0xa8,addr+Miercoles_addr); 
 874   1          if(dataee == Miercoles_dato)
 875   1          {
 876   2          printf(" Miercoles = Programado\r\n");
 877   2          }
 878   1          else
 879   1          {
 880   2          printf(" Miercoles = No programado\r\n");
 881   2          }
 882   1          /*Jueves*/
 883   1            dataee=rd_eeprom(0xa8,addr+Jueves_addr);  
 884   1          if(dataee == Jueves_dato)
 885   1          {
 886   2          printf(" Jueves = Programado\r\n");
 887   2          }
 888   1          else
 889   1          {
 890   2          printf(" Jueves = No programado\r\n");
 891   2          }
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 16  

 892   1          /*Viernes*/
 893   1            dataee=rd_eeprom(0xa8,addr+Viernes_addr); 
 894   1          if(dataee == Viernes_dato)
 895   1          {
 896   2          printf(" Viernes = Programado\r\n");
 897   2          }
 898   1          else
 899   1          {
 900   2          printf(" Viernes = No programado\r\n");
 901   2          }
 902   1          /*Sabado*/
 903   1          
 904   1            dataee=rd_eeprom(0xa8,addr+Sabado_addr);  
 905   1          if(dataee == Sabado_dato)
 906   1          {
 907   2          printf(" Sabado = Programado\r\n");
 908   2          }
 909   1          else
 910   1          {
 911   2          printf(" Sabado = No programado\r\n");
 912   2          }
 913   1          /*Domingo*/
 914   1          dataee=rd_eeprom(0xa8,addr+Domingo_addr); 
 915   1          if(dataee == Domingo_dato)
 916   1          {
 917   2          printf(" Domingo = Programado\r\n");
 918   2          }
 919   1          else
 920   1          {
 921   2          printf(" Domingo = No programado\r\n");
 922   2          }
 923   1      }
 924          void Prog_Horarios()
 925          {
 926   1        unsigned char buffer[10];
 927   1        unsigned char ee_addr_horario[11];
 928   1        unsigned int addr,temp;
 929   1        unsigned char dataee;
 930   1        unsigned char j;
 931   1        
 932   1        /*direcciones de memoria de almacenamiento*/
 933   1        
 934   1          strcpy (ee_addr_horario,(Addr_Horarios()));
 935   1          
 936   1        /*se programa el banco de horarios del 1 al 10*/
 937   1        
 938   1        printf("\r\n\n Digite el numero del Horario a programar = ");   
 939   1        IngresaDato(buffer,0);  
 940   1        
 941   1        j=(atoi(buffer)) - 1;
 942   1        
 943   1        /*mi direccion eeprom*/
 944   1        
 945   1        addr= ee_addr_horario[j];
 946   1        temp= addr;
 947   1        
 948   1        /*habilita o desabilita el uso del horario*/
 949   1        
 950   1        addr =addr + Habilita_addr ;
 951   1        if (Prog_Horarios_on_off(addr) == True);
 952   1        {
 953   2          /*limpiar la memoria*/
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 17  

 954   2        addr= temp;
 955   2          for(j=Lunes_addr; j < 8 ; j++)
 956   2          {
 957   3            wr_eeprom(0xa8,addr+j,0xff);
 958   3          }
 959   2        
 960   2        addr= temp;
 961   2        /*los dias programados*/
 962   2        
 963   2        Prog_Horario_dias(addr);
 964   2          
 965   2        /*la hora de inicio del horario*/
 966   2        
 967   2        Prog_Horario_Desde_Hasta(addr);
 968   2        
 969   2        /*programo si hay segundo horario*/
 970   2        printf("\r\n\n Programar segundo Horario si=(1) no=(0)= ");   
 971   2        IngresaDato(buffer,0);
 972   2        dataee=atoi(buffer);                                                          /*lo convierto a un dato hex*/
 973   2        wr_eeprom(0xa8,addr+Segundo_Tiempo,dataee);                                         /*grabo el dato en la eeprom*/
 974   2        
 975   2        dataee=rd_eeprom(0xa8,addr+Segundo_Tiempo);                                       /*leo el dato grabado*/
 976   2        sprintf(buffer,"%d",dataee);  
 977   2          if(dataee==True)
 978   2          {
 979   3            /*la hora de inicio del segundo horario*/
 980   3            addr =addr + Minutos_Low_addr_Desde ;
 981   3            Prog_Horario_Desde_Hasta(addr);
 982   3          }
 983   2        }
 984   1        
 985   1      }
 986          void Prog_fecha_vencimiento()
 987          {
 988   1        unsigned char buffer[11];
 989   1        unsigned char *cmd;
 990   1        
 991   1        unsigned char fecha[7];
 992   1        unsigned int dataee;
 993   1      
 994   1        LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);   
 995   1           hex_ascii(buffer,fecha);
 996   1                                    
 997   1        
 998   1        printf("\r\n\n ACTUAL FECHA VENCIMIENTO PASSWORD:%s\r\n\n",fecha);                            /*se muestra el id_client
             -e actual en pantalla*/
 999   1          
1000   1         do{
1001   2        printf("\r\n\n/>Id Registro:");
1002   2        LeerMemoria(EE_ID_REGISTER,buffer);
1003   2        printf("%s", buffer);
1004   2        strcpy (validacion,hash_id(buffer));
1005   2        printf("\r\n\n/>Password:");
1006   2        
1007   2          /*para pruebas*/
1008   2        //printf("\r\n\%s ", validacion);
1009   2          
1010   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
1011   2        cmd = GetCMD(buffer);         //quita el carri return 
1012   2        EscribirMemoria(EE_ID_REGISTER,validacion);
1013   2      
1014   2        }while(ValidarClave(cmd)!=0);
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 18  

1015   1        
1016   1        
1017   1        printf("\r\n\n DIGITE LA NUEVA FECHA DE VENCIMIENTO=");                                 /*digite el nuevo id_cliente*/
1018   1        IngresaDato(buffer,0);  
1019   1        printf("\r\n\n %s\r\n\n",buffer); 
1020   1        
1021   1          fecha[0]=buffer[0]; 
1022   1          fecha[1]=buffer[1]; 
1023   1          fecha[2]=0; 
1024   1          
1025   1          dataee=atoi(fecha);
1026   1          printf("\r\n\n %X",dataee); 
1027   1        /*lo convierto a un dato hex*/
1028   1         wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO,dataee);                                         /*grabo el dato en la eeprom*/
1029   1          fecha[0]=buffer[2]; 
1030   1          fecha[1]=buffer[3]; 
1031   1          fecha[2]=0; 
1032   1          dataee=atoi(fecha);
1033   1          printf("\r\n\n %X",dataee); 
1034   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+1,dataee);
1035   1          fecha[0]=buffer[4]; 
1036   1          fecha[1]=buffer[5]; 
1037   1          fecha[2]=0; 
1038   1          dataee=atoi(fecha); 
1039   1          printf("\r\n\n %X",dataee);     
1040   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+2,dataee);
1041   1          wr_eeprom(0xa8,EE_FECHA_VENCIMIENTO+3,0);
1042   1          
1043   1          LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);
1044   1          
1045   1          hex_ascii(buffer,fecha);  
1046   1          printf("\r\n\n ACTUAL FECHA DE VENCIMIENTO PROGRAMADA =%s\r\n\n",fecha);  
1047   1        
1048   1      }
1049          void Ver_Horario()
1050          {
1051   1        unsigned char buffer[10];
1052   1        unsigned char ee_addr_horario[11];
1053   1        unsigned char conta;
1054   1        
1055   1        unsigned int addr,temp;
1056   1        unsigned char dataee;
1057   1        /*direcciones de memoria de almacenamiento*/
1058   1        
1059   1        strcpy (ee_addr_horario,(Addr_Horarios()));
1060   1        for (conta=0;conta < 10 ; conta++)
1061   1        {
1062   2        
1063   2        printf("\r\n numero del Horario  programado = %c\r\n",conta+49);
1064   2          
1065   2        /*HORARIO HABILITADO O INHABILITADO*/
1066   2        addr= ee_addr_horario[conta];
1067   2        temp= addr;
1068   2          /*habilita o desabilita el uso del horario*/
1069   2        
1070   2        addr =addr + Habilita_addr ;
1071   2        dataee = rd_eeprom(0xa8,addr);                                          /*se lee el id_cliente actual */
1072   2        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1073   2          if(dataee == 1)
1074   2          {
1075   3          printf("\r\n  HORARIO HABILITADO  = ON\r\n");                           /*se muestra el id_cliente actual en pantalla
             -*/
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 19  

1076   3          
1077   3          printf("\r\n Dias Programados\r\n");
1078   3        addr=temp;
1079   3        Ver_Horario_dias(addr);
1080   3        
1081   3        Ver_Horario_Desde_Hasta(addr);
1082   3        dataee=rd_eeprom(0xa8,addr+Segundo_Tiempo);                                       /*leo el dato grabado*/
1083   3        sprintf(buffer,"%d",dataee);  
1084   3            if(dataee==True)
1085   3            {
1086   4            printf("\r\n  SEGUNDO HORARIO HABILITADO  = ON\r\n");
1087   4            /*la hora de inicio del segundo horario*/
1088   4            addr =addr + Minutos_Low_addr_Desde ;
1089   4            Ver_Horario_Desde_Hasta(addr);
1090   4            }
1091   3            else
1092   3            {
1093   4            printf("\r\n SEGUNDO HORARIO HABILITADO  = OFF\r\n");
1094   4            }
1095   3          }
1096   2          else
1097   2          {
1098   3          printf("\r\n  HORARIO HABILITADO  = OFF\r\n");      
1099   3          }
1100   2          
1101   2        }
1102   1        
1103   1          
1104   1      }
1105          void Ver_Prog()
1106          {
1107   1        unsigned char buffer[10];
1108   1        unsigned int dataee;
1109   1        unsigned char fecha[7];
1110   1        
1111   1        
1112   1        dataee=rd_eeprom(0xa8,EE_ID_CLIENTE);                                         /*se lee el id_cliente actual */
1113   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1114   1        /*ID programado*/
1115   1        printf("\r\n ID_CLIENTE_PROGRAMADO = %s\r\n",buffer);   
1116   1        /*codigo de parkeadero*/
1117   1        dataee=rd_eeprom(0xa8,EE_ID_PARK);                                          /*se lee el id_cliente actual */
1118   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1119   1        
1120   1        printf("\r\n COD_PARK_PROGRAMADO = %s\r\n",buffer);   
1121   1        /*tiempo de gracia*/
1122   1        dataee=rd_eeprom(0xa8,EE_TIEMPO_GRACIA);                                          /*se lee el id_cliente actual */
1123   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1124   1        
1125   1        printf("\r\n TIEMPO_GRACIA PROGRAMADO = %s\r\n",buffer);    
1126   1        /*SIN COBRO*/
1127   1        dataee=rd_eeprom(0xa8,EE_SIN_COBRO);                                          /*se lee el id_cliente actual */
1128   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1129   1        if(dataee==0)
1130   1        {
1131   2          printf("\r\n\ SIN_COBRO HABILITADO = OFF \r\n");                            /*se muestra el id_cliente actual en panta
             -lla*/
1132   2        }
1133   1        else if (dataee==1)
1134   1        {
1135   2          printf("\r\n SIN_COBRO = ON\r\n");    
1136   2        }
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 20  

1137   1        
1138   1        /*estado de debug*/
1139   1        dataee=rd_eeprom(0xa8,EE_DEBUG);                                          /*se lee el id_cliente actual */
1140   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1141   1        if(dataee==1)
1142   1        {
1143   2          printf("\r\n PROGRAMADO DEBUG = ON\r\n"); 
1144   2        } 
1145   1        else
1146   1        {
1147   2          printf("\r\n PROGRAMADO DEBUG = OFF\r\n");  
1148   2        } 
1149   1        /*Estado del lpr*/
1150   1        dataee=rd_eeprom(0xa8,EE_USE_LPR);                                          /*se lee el id_cliente actual */
1151   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1152   1        if(dataee==0)
1153   1        {
1154   2          printf("\r\n USE_LPR = OFF\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1155   2        }
1156   1        else
1157   1        {
1158   2          printf("\r\n USE_LPR = ON\r\n");      
1159   2        }
1160   1        /*comparacion activa*/
1161   1        dataee=rd_eeprom(0xa8,EE_CPRCN_ACTIVA);                                         /*se lee el id_cliente actual */
1162   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1163   1        if(dataee==0)
1164   1        {
1165   2          printf("\r\n\n  COMPARACION ACTIVA = OFF\r\n");                           /*se muestra el id_cliente actual en pantal
             -la*/
1166   2        }
1167   1        else
1168   1        {
1169   2          printf("\r\n\n COMPARACION ACTIVA  = ON\r\n");      
1170   2        }
1171   1        
1172   1        /*Tipo de pantalla*/
1173   1        dataee=rd_eeprom(0xa8,EE_TIPO_PANTALLA);                                          /*se lee el id_cliente actual */
1174   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1175   1        if(dataee==0)
1176   1        {
1177   2          printf("\r\n PANTALLA LCD PROGRAMADA\r\n");                           /*se muestra el id_cliente actual en pantalla*/
1178   2        }
1179   1        else
1180   1        {
1181   2          printf("\r\n PANTALLA RASPBERRY  PROGRAMADA\r\n");      
1182   2        }
1183   1        /*DESCUENTOS*/
1184   1        dataee=rd_eeprom(0xa8,EE_DCTO_PASA_CAJA);                                         /*se lee el id_cliente actual */
1185   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1186   1        if(dataee==0)
1187   1        {
1188   2          printf("\r\n\n PASA POR CAJA PARA VALIDAR DCTO=%s\r\n\n",buffer);                           /*se muestra el id_client
             -e actual en pantalla*/
1189   2        }
1190   1        else
1191   1        {
1192   2          printf("\r\n\n APLICA DESCUENTO=%s\r\n\n",buffer);      
1193   2        }
1194   1        /*APB MENSUAL*/
1195   1        dataee=rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL);                                         /*se lee el id_cliente actual */
1196   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 21  

1197   1        if(dataee==0)
1198   1        {
1199   2          printf("\r\n\n  ANTIPASSBACK MENSUAL = OFF\r\n");                           /*se muestra el id_cliente actual en pant
             -alla*/
1200   2        }
1201   1        else
1202   1        {
1203   2          printf("\r\n\n  ANTIPASSBACK MENSUAL = ON\r\n");      
1204   2        } 
1205   1        /*ADDRESS HIGH*/
1206   1        dataee=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);                                         /*se lee el id_cliente actual */
1207   1        sprintf(buffer,"%d",dataee);                                                  /*se convierte  un entero a un string*/
1208   1        if(dataee==0)
1209   1        {
1210   2          printf("ACTUAL ADDRESS_HIGH_BOARD PROGRAMADA = %s\r\n",buffer);                           /*se muestra el id_cliente 
             -actual en pantalla*/
1211   2        }
1212   1      
1213   1        
1214   1        /*horarios Programados*/
1215   1         Ver_Horario();
1216   1        
1217   1        /*Fecha de vencimiento clave*/
1218   1        LeerMemoria(EE_FECHA_VENCIMIENTO,buffer);
1219   1          
1220   1          hex_ascii(buffer,fecha);  
1221   1          printf("\r\n ACTUAL FECHA DE VENCIMIENTO PROGRAMADA =%s\r\n",fecha);  
1222   1      }
1223          /*------------------------------------------------------------------------------
1224          Rutina que muestra la lista de comandos
1225          ------------------------------------------------------------------------------*/
1226          void Show()
1227          {
1228   1         printf("\r\n ID_CLIENTE    --- CMD 0 Identificador del cliente maximo 255");
1229   1         printf("\r\n COD_PARK      --- CMD 1 El numero del parqueadero maximo 255");
1230   1         printf("\r\n T_GRACIA      --- CMD 2 Tiempo sin cobro 00,  maximo 255");
1231   1         printf("\r\n SIN_COBRO     --- CMD 3 Inhabilitado= 0, Gratis= 1 , Gratis y salida el mismo dia= 2");
1232   1         printf("\r\n DEBUG         --- CMD 4 Habilitar = 1, Inhabilitar = 0");
1233   1         printf("\r\n USE_LPR       --- CMD 5 Habilitar = 1, Inhabilitar = 0");
1234   1         printf("\r\n COMPARACION_ACTIVA --- CMD 6 Habilitar = 1, Inhabilitar = 0");
1235   1         printf("\r\n TIPO_PANTALLA     --- CMD 7 (0) pantalla lcd  serie (1) raspberry o bluetooth");
1236   1         printf("\r\n DCTO_PASA_CAJA     --- CMD 8 (0) pasa por caja (1) aplica el descuento");
1237   1         printf("\r\n USE_APB_MENSUAL    --- CMD 9 Habilitar = 1, Inhabilitar = 0");
1238   1         printf("\r\n ADDRESS_HIGH_BOARD --- CMD 10 La direccion alta del board del numero 5 al 9 sino se usa deb
             -e ir en 0");
1239   1         printf("\r\n HORARIO            --- CMD 11 Progama 10 horarios del 1 al 10");
1240   1         printf("\r\n VER_PROGRAMACION   --- CMD 12 Muestra la programacion");
1241   1         printf("\r\n AYUDA         --- CMD 13 Muestra los comandos");
1242   1         printf("\r\n SALIR         --- CMD 14 Salir de programacion");
1243   1      
1244   1      }
1245          /*------------------------------------------------------------------------------
1246          Rutina de principal de programacion
1247          ------------------------------------------------------------------------------*/
1248          void  First_Clave()
1249          {
1250   1        unsigned char clave[11];
1251   1        
1252   1        
1253   1          Block_read_clock_ascii(clave);
1254   1          clave[10] = 0;
1255   1          strcpy (validacion,hash_id(clave));
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 22  

1256   1          EscribirMemoria(EE_ID_REGISTER,validacion);
1257   1          validacion[0]=0x14;   //año
1258   1          validacion[0]=0x0B;   //mes
1259   1          validacion[0]=0x14;
1260   1          validacion[0]=0;
1261   1          
1262   1          EscribirMemoria(EE_FECHA_VENCIMIENTO,validacion);
1263   1        
1264   1        
1265   1      }
1266          /*------------------------------------------------------------------------------
1267          Rutina de principal de programacion
1268          ------------------------------------------------------------------------------*/
1269          
1270          void menu(void)
1271          {
1272   1      
1273   1      unsigned char *cmd,*option1,*option2;
1274   1      unsigned char opt_buffer[40];
1275   1      unsigned char buffer[40];
1276   1      
1277   1      
1278   1      
1279   1        
1280   1        printf("\r\n\nSistema de Programacion verificador lintech \r\n\r\n");
1281   1      if(rd_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE) != False) 
1282   1        {
1283   2          First_Clave();  
1284   2          wr_eeprom(0xa8,EE_JUST_ONE_TIME_CLAVE,0x0);
1285   2          //printf("%s", buffer);
1286   2        
1287   2        }
1288   1       
1289   1      
1290   1        do{
1291   2        printf("\r\n\n/>Id Registro:");
1292   2        LeerMemoria(EE_ID_REGISTER,buffer);
1293   2        buffer[10]=0;
1294   2        printf("%s", buffer);
1295   2        strcpy (validacion,hash_id(buffer));
1296   2        printf("\r\n\n/>Password:");
1297   2        
1298   2          /*para pruebas*/
1299   2      //  printf("\r\n\%s ", validacion);
1300   2        
1301   2        IngresaDato(buffer,1);          //ingreso el password por teclado 
1302   2        cmd = GetCMD(buffer);         //quita el carri return 
1303   2        EscribirMemoria(EE_ID_REGISTER,validacion);
1304   2      }while(ValidarClave(cmd)!=0);       //validamos el usuario
1305   1      
1306   1      
1307   1        
1308   1        Show();
1309   1        while(1)
1310   1        {
1311   2        DisplayCursor();
1312   2      
1313   2      
1314   2          IngresaDato(buffer,0);  
1315   2          cmd = GetCMD(buffer); 
1316   2          option1 = GetOption(cmd + strlen(cmd) + 1);
1317   2          option2 = GetOption(option1 + strlen(option1) + 1);  
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 23  

1318   2      
1319   2         //si empieza con un '/', eso significa que incluye el caminoa
1320   2            //al archivo.  si el archivo no empieza con un '/', debe agregarce 
1321   2            //la ruta del archivo.
1322   2            if (option1 && (option1[0]=='/'))
1323   2            {
1324   3               //option1 is a full path
1325   3               strcpy(opt_buffer, option1);
1326   3            }
1327   2            else if (option1)
1328   2            {
1329   3               // tack on the current working directory to option1
1330   3               strcpy(opt_buffer, cursor);
1331   3               strcat(opt_buffer, option1);
1332   3            }         
1333   2      
1334   2      
1335   2      
1336   2      
1337   2      
1338   2          if (cmd)
1339   2            {
1340   3               switch(ListaComandos(cmd))
1341   3               {
1342   4                  case 0:                     /*Se programa la identificacion del cliente*/
1343   4                    prog_id_cliente();
1344   4                  
1345   4                   break;
1346   4                  
1347   4                  case 1:  //Tiempo de recolecion entre muestra
1348   4                  prog_cod_park();
1349   4                     break;
1350   4                  
1351   4                  case 2:  //Informacion recolectada enviada al rs232
1352   4          
1353   4                  Prog_tiempo_gracia();
1354   4                
1355   4                     break;
1356   4                  
1357   4                  case 3:  //Ajuste del cero del sensor
1358   4                  Prog_Sin_Cobro();
1359   4      
1360   4                     break;
1361   4                  
1362   4                  case 4:  //Ajuste de calibracion por medio de la pendiente
1363   4                    Prog_debug();
1364   4                     break;
1365   4                  case 5:  //help me
1366   4                    Prog_Use_Lpr();
1367   4                     break;
1368   4                  case 6:  //help me
1369   4                 Prog_Comparacion_Activa();
1370   4      
1371   4                     break;
1372   4                  case 7:     //tipo de pantalla
1373   4                  tipo_pantalla();
1374   4                    break;
1375   4                  
1376   4                  case 8:     //tipo de pantalla
1377   4                  dcto_caja();
1378   4                    break;
1379   4                  case 9:   //cmd configuracion los horarios
C51 COMPILER V9.59.0.0   PROG                                                              09/28/2020 11:10:44 PAGE 24  

1380   4                    Prog_Apb_Mensual();
1381   4                  break;
1382   4                  case 10:    //cmd configuracion de la direccion del board
1383   4                    Prog_Address_High_Board();
1384   4                  break;
1385   4                  case 11:    //cmd configuracion los horarios
1386   4                    Prog_Horarios();
1387   4                  break;
1388   4                  
1389   4                  case 12:  //help me
1390   4                 
1391   4                    Ver_Prog();
1392   4                     break;
1393   4                  case 13:  //help me
1394   4                 
1395   4                    Show();
1396   4                     break;
1397   4                  case 14:  //salir
1398   4                  return;
1399   4      
1400   4                     break;
1401   4                  case 15:
1402   4                    Prog_fecha_vencimiento();
1403   4                    break;
1404   4          
1405   4                
1406   4                  default:
1407   4                     printf("\r\nComando no existe '%s'", cmd);
1408   4                     break;
1409   4              }
1410   3            }
1411   2        }
1412   1      }
1413          
1414            
1415          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8566    ----
   CONSTANT SIZE    =   4460    ----
   XDATA SIZE       =     81     489
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
