C51 COMPILER V9.59.0.0   IO_SENSORES                                                       09/21/2020 13:31:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE IO_SENSORES
OBJECT MODULE PLACED IN .\Objects\io_sensores.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE io_sensores.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\io_sensores.lst) TABS(2) OBJECT(.\Objects\io_sensores.obj)

line level    source

   1          
   2          #include <io_sensores.h>
   3          #include <reg51.h>
   4          
   5          /*funciones externas*/
   6          extern void Debug_txt_Tibbo(unsigned char * str);
   7          extern void load_and_send_info_reloj();
   8          extern void load_and_send_id_cod();
   9          extern void send_portERR(unsigned char cod_err);
  10          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  11          
  12          sbit DataIn = P1^1;         //      
  13          sbit sel_A = P3^5;          //Pulsador                        *
  14          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
  15          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
  16          sbit busy = P3^3;           /*bussy de Entrada Interrupcion del Procesador principal      */
  17          
  18          #define NO_TIFIQUE_EVP      'N'
  19          #define SI_NOTIFIQUE_EVP    'S'
  20          
  21          #define AUTOMOVIL           0X00
  22          #define MOTO                0X01
  23          /*datos en eeprom*/
  24          #define EE_CPRCN_ACTIVA       0x000C
  25          #define EE_ADDRESS_HIGH_BOARD   0X0012
  26          
  27          extern bit COMPARACION_ACTIVA;
  28          extern  unsigned char Tipo_Vehiculo;
  29          
  30          //***************************************************************************************************
  31          void sel_Funcion(void)
  32          {
  33   1        sel_A=0;
  34   1        sel_B=0;
  35   1        sel_C=0;
  36   1      }
  37          //***************************************************************************************************
  38          void sel_Auto(void)
  39          {
  40   1        sel_A=0;
  41   1        sel_B=1;
  42   1        sel_C=0;
  43   1      }
  44          //***************************************************************************************************
  45          /*
  46          void sel_Pulsa(void)
  47          {
  48            sel_A=1;
  49            sel_B=1;
  50            sel_C=0;
  51          }
  52          */
  53          //***************************************************************************************************
  54          void sel_Sensor2(void)
C51 COMPILER V9.59.0.0   IO_SENSORES                                                       09/21/2020 13:31:51 PAGE 2   

  55          {
  56   1        sel_A=0;
  57   1        sel_B=0;
  58   1        sel_C=1;
  59   1      }
  60          //***************************************************************************************************
  61          void sel_Sensor1(void)
  62          {
  63   1        sel_A=1;
  64   1        sel_B=0;
  65   1        sel_C=1;
  66   1      }
  67          //***************************************************************************************************
  68          void sel_Dir1(void)
  69          {
  70   1        sel_A=0;
  71   1        sel_B=1;
  72   1        sel_C=1;
  73   1      }
  74          //***************************************************************************************************
  75          void sel_Dir2(void)
  76          {
  77   1        sel_A=1;
  78   1        sel_B=1;
  79   1        sel_C=1;
  80   1      }
  81          
  82          char ValidaSensor(void)
  83          {
  84   1        
  85   1      char  Valido=0;
  86   1      int Tmin=500;
  87   1        while ((DataIn==1)&&(Valido==0))
  88   1        {
  89   2          Tmin--;
  90   2          if (Tmin==0)
  91   2          {
  92   3             Valido=1;
  93   3          }
  94   2        }
  95   1        return Valido;
  96   1      }
  97          /*------------------------------------------------------------------------------
  98          Funcion q debuelve la direccion de la tarjeta
  99          ------------------------------------------------------------------------------*/
 100          unsigned char Dir_board()
 101          {
 102   1        unsigned char Board=0x01;
 103   1        unsigned char Board_High;
 104   1        sel_Dir1();
 105   1        if (DataIn==1)
 106   1        {
 107   2          Board++;
 108   2        }
 109   1        sel_Dir2();
 110   1        if (DataIn==1)
 111   1        {
 112   2          Board=Board+2;
 113   2        }
 114   1        if(Board == 0x01)
 115   1        { 
 116   2        Board_High=rd_eeprom(0xa8,EE_ADDRESS_HIGH_BOARD);
C51 COMPILER V9.59.0.0   IO_SENSORES                                                       09/21/2020 13:31:51 PAGE 3   

 117   2        
 118   2          if(Board_High != 0)
 119   2          {
 120   3            if(Board_High == 0xff)
 121   3            {
 122   4              Board=0x01;
 123   4            }
 124   3            else  Board= Board_High ;
 125   3          } 
 126   2        
 127   2        }
 128   1        return (Board+0x30);
 129   1      }
 130          /*------------------------------------------------------------------------------
 131          Detecto la activacion de los sensores de salida
 132          si retorna 0xff el sensor activo
 133          si retorno 0x00 loop no activo
 134          01 saliendo
 135          ------------------------------------------------------------------------------*/
 136          
 137          unsigned char  ValidaSensoresPaso(void)
 138          {
 139   1       
 140   1          sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
 141   1            if ((DataIn==1))        
 142   1          {  
 143   2            if (ValidaSensor()==1)
 144   2            {
 145   3            sel_Sensor1();  
 146   3              if (DataIn==0)                            // sensor1  se encuentra activo puede ser carro, si esta inhabilitado debe
             - ser moto          
 147   3              {  sel_Auto();
 148   4                if (DataIn==0)
 149   4                {                                         // sensor Auto activo es un carro 
 150   5                   Debug_txt_Tibbo((unsigned char *) "Sensores Auto y sensor1 activos.");
 151   5                   Tipo_Vehiculo=AUTOMOVIL;
 152   5                    return 0xff;
 153   5                  
 154   5                }
 155   4                else
 156   4                  {
 157   5                    Debug_txt_Tibbo((unsigned char *) "Sensor activo sensor1 .");
 158   5                    Tipo_Vehiculo=MOTO;
 159   5                    return 0xff ;
 160   5                  }
 161   4                  
 162   4                  
 163   4              }
 164   3              else
 165   3              {   sel_Auto();
 166   4                if (DataIn==0)
 167   4                {
 168   5                
 169   5                Debug_txt_Tibbo((unsigned char *) "Detectado. Sensor Auto.");
 170   5                  Tipo_Vehiculo=MOTO;
 171   5                  return 0xff;  
 172   5                }
 173   4                else
 174   4                {
 175   5                  Debug_txt_Tibbo((unsigned char *) "Sensores no detectados");
 176   5                  return 0x00;  
 177   5                }
C51 COMPILER V9.59.0.0   IO_SENSORES                                                       09/21/2020 13:31:51 PAGE 4   

 178   4                  
 179   4      
 180   4              }
 181   3            }
 182   2            else 
 183   2            {
 184   3              Debug_txt_Tibbo((unsigned char *) "Vehiculo Esperando Salir.");
 185   3              return 0x00;
 186   3            }
 187   2          }else 
 188   1          {
 189   2          Debug_txt_Tibbo((unsigned char *) "Vehiculo Saliendo. Un momento");
 190   2          return 0x01;
 191   2          }
 192   1      
 193   1      }
 194          
 195          unsigned char  ValidaSensores_Out(void)
 196          {
 197   1      char  valido=0;
 198   1        
 199   1          sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
 200   1            if ((DataIn==1))        
 201   1            {  
 202   2              if (ValidaSensor()==1)
 203   2              {
 204   3                valido=0;
 205   3                return valido;
 206   3              }
 207   2              else
 208   2              {
 209   3                valido=1;
 210   3                return valido;
 211   3              }
 212   2            }
 213   1            else
 214   1            {
 215   2              valido=1;
 216   2              return valido;
 217   2            }
 218   1      }
 219          /*------------------------------------------------------------------------------
 220          funcion de msj en lcd de informacion
 221          toggle=0    envia por el pto paralelo STX, cmd (i), año, mes, dia, hora, minutos, seg, dia de la semana, ETX
 222          toggle=1    
 223          toggle=2    envia ID y COD_PARK   por el pto paralelo STX, cmd (D), ID_CLIENTE, COD_CLIENTE, ETX  
 224          ------------------------------------------------------------------------------*/
 225           void msj_lcd_informativo()
 226           {
 227   1       unsigned char info=0;
 228   1       static unsigned char toggle=0;
 229   1            sel_Funcion();                                  /*el pulsador funcion es el cmd q visualiza la informacion tres */
 230   1          if (DataIn==0)
 231   1          {
 232   2             if ((toggle==0)&&(info==0))                    /*primer pulso de funcion*/
 233   2            {
 234   3             if (busy==1)                                   /*habilito transmicion pto paralelo*/
 235   3              {
 236   4                info=1;                                     /*incremento info para ser limpiado cuando se suelte el pulsador*/
 237   4                load_and_send_info_reloj();                 /*se envia el reloj al lcd */
 238   4                toggle=1;                                   /*incremento a toggle para el proximo pulso sea otra opcion*/
 239   4              }
C51 COMPILER V9.59.0.0   IO_SENSORES                                                       09/21/2020 13:31:51 PAGE 5   

 240   3             }    
 241   2              else if((toggle==1)&&(info==0))
 242   2              {
 243   3                if (busy==1)
 244   3                {
 245   4                info=1;
 246   4                load_and_send_id_cod();                   /*muestro el codigo e id del cliente configurado*/
 247   4                toggle=2;
 248   4                }
 249   3              }
 250   2              else if ((toggle==2)&&(info==0))
 251   2              {
 252   3                if (busy==1)
 253   3                {
 254   4                info=1;
 255   4                  if(rd_eeprom(0xa8,EE_CPRCN_ACTIVA)==1)    /*se muestra si hay comparacion activa si o no*/
 256   4                  {
 257   5                    send_portERR(SI_NOTIFIQUE_EVP);
 258   5                  }else {send_portERR(NO_TIFIQUE_EVP);}
 259   4                  
 260   4                toggle=0;
 261   4                }
 262   3              
 263   3              }
 264   2            
 265   2            }
 266   1          
 267   1          sel_Funcion();                  // el antirebote
 268   1          if (DataIn==1)
 269   1          {
 270   2            info=0;
 271   2          }
 272   1      
 273   1       }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    414    ----
   CONSTANT SIZE    =    160    ----
   XDATA SIZE       =      1       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
