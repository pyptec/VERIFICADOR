C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Clock.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          
   2          #include <Clock.h>
   3          #include <reg51.h>
   4          
   5          /*funcion prototipo*/
   6          extern void Delay (void);
   7          extern void Delay_20us(unsigned int cnt);
   8          extern void Debug_Fecha_actual(unsigned char *buffer);
   9          extern float pow   (float x, float y);
  10          /*variables externas */
  11          extern unsigned char  Debug_Tibbo;
  12          
  13          sbit sck = P1^4 ;                 /* define I/O functions     */
  14          sbit io  = P1^5 ;
  15          sbit rst = P1^6 ;
  16          /*CMD DE ESCRITURA RELOJ*/
  17          #define WDIA            0x86
  18          #define WMES            0x88
  19          #define WANO            0x8C
  20          #define WHORA           0x84
  21          #define WMIN            0x82
  22          #define WSEG            0x80
  23          #define WDIA_SEMANA     0x8A
  24          /*CMD DE LECTURA DEL RELOJ*/
  25          #define RDIA            0x87
  26          #define RMES            0x89
  27          #define RANO            0x8D
  28          #define RHORA           0x85
  29          #define RMIN            0x83
  30          #define RSEG            0x81
  31          #define RDIA_SEMANA     0x8B
  32          
  33          #define True                    0x01
  34          #define False                   0x00
  35          
  36          unsigned char data_clk;
  37          //*********************************************************************************
  38          
  39          //*********************************************************************************
  40          void p_ck (void)
  41          {
  42   1          sck=1;
  43   1          Delay();
  44   1          sck=0;
  45   1      }
  46          //*********************************************************************************
  47          void eb_clk(char dir_clk) {
  48   1        int nbits;
  49   1        for (nbits=0; nbits<8; nbits++)
  50   1        {
  51   2          dir_clk >>=1;
  52   2          if (CY==1)
  53   2          { 
  54   3            io=1;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 2   

  55   3          }
  56   2          else
  57   2          {
  58   3            io=0;
  59   3          }
  60   2          p_ck();
  61   2        }
  62   1      }
  63          //*********************************************************************************
  64          char lee_clk (unsigned char dir_clk) {            
  65   1      int nbits;
  66   1        rst=1;
  67   1        Delay_20us(3);
  68   1        eb_clk(dir_clk);
  69   1        for (nbits=0; nbits<8; nbits++)
  70   1        {
  71   2          if (io==1) 
  72   2          {
  73   3          data_clk = data_clk | 0x80;
  74   3          if (nbits<=6) {
  75   4           data_clk >>=1;
  76   4           }
  77   3          }
  78   2          if (io==0)
  79   2          {
  80   3            data_clk = data_clk & 0x7F;
  81   3          if (nbits<=6) 
  82   3           {
  83   4            data_clk >>=1;
  84   4           }
  85   3          }
  86   2          p_ck();
  87   2          } 
  88   1        rst=0;
  89   1        return data_clk;
  90   1      }
  91          //*********************************************************************************
  92          void wr_clk (unsigned char dir_clk, unsigned char byte) {            
  93   1        rst=1;
  94   1        Delay_20us(3);
  95   1        eb_clk(dir_clk);
  96   1        dir_clk=byte;
  97   1        eb_clk(dir_clk);
  98   1        rst=0;
  99   1        
 100   1       }
 101          //****************************************************************************
 102           unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 103          {
 104   1        unsigned char byte_out;
 105   1        byte_h=byte_h&0x0f;
 106   1        byte_h<<=4;
 107   1        byte_l=byte_l&0x0f;
 108   1        byte_out=byte_h|byte_l;
 109   1        return byte_out;
 110   1      }
 111          /*------------------------------------------------------------------------------
 112          
 113          ------------------------------------------------------------------------------*/
 114          unsigned char validar_clk(unsigned char *datos_clock)
 115          {
 116   1        unsigned char validador=0;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 3   

 117   1        
 118   1        
 119   1          if ((*datos_clock >= '0') &&(*datos_clock <= '9'))                                /*valida el dia parte alta */
 120   1          {
 121   2          
 122   2             if ((*(datos_clock+1) >= '0') &&(*(datos_clock+1) <= '9'))                     /*valida el dia parte baja*/
 123   2            {
 124   3              
 125   3               if ((*(datos_clock+3) >= '0') &&(*(datos_clock+3) <= '9'))             /*valida el mes parte alta*/
 126   3              {
 127   4                if ((*(datos_clock+4) >= '0') &&(*(datos_clock+4) <= '9'))            /*valida el mes parte baja */
 128   4                {
 129   5                 if ((*(datos_clock+8) >= '0') &&(*(datos_clock+8) <= '9'))         /*año baja*/      
 130   5                  {
 131   6                   if ((*(datos_clock+0x0b) >= '0')&&(*(datos_clock+0x0b) <= '9'))          /*hora alta*/ 
 132   6                    {
 133   7                    if ((*(datos_clock+0x0c) >= '0') &&(*(datos_clock+0x0c) <= '9'))          /*hora baja*/ 
 134   7                      {
 135   8                     if ((*(datos_clock+0x0e) >= '0') &&(*(datos_clock+0x0e) <= '9'))       /*minutos alta*/
 136   8                        {
 137   9                      if ((*(datos_clock+0x0f) >= '0') &&(*(datos_clock+0x0f) <= '9'))        /*minutos baja*/
 138   9                        {
 139  10                       if ((*(datos_clock+0x11) >= '0') &&(*(datos_clock+0x11) <= '9'))       /*segundos alta*/
 140  10                            {
 141  11                        if ((*(datos_clock+0x12) >= '0') &&(*(datos_clock+0x12) <= '9'))        /*segundos baja*/
 142  11                          {
 143  12                          if ((*(datos_clock+0x14) >= '0') &&(*(datos_clock+0x14) <= '9'))        /*dia de la semana*/
 144  12                           {
 145  13                                  validador=0;
 146  13                           }
 147  12                              }
 148  11                              else
 149  11                              {
 150  12                                validador =1;
 151  12                              }
 152  11                            }
 153  10                            else
 154  10                            {
 155  11                              validador =1;
 156  11                          
 157  11                            }
 158  10                          }
 159   9                          else
 160   9                          {
 161  10                            validador =1;
 162  10                        
 163  10                          }
 164   9                      
 165   9                        }
 166   8                        else
 167   8                        {
 168   9                          validador =1;
 169   9                        
 170   9                        }
 171   8                      }
 172   7                      else
 173   7                      {
 174   8                        validador =1;
 175   8                        //break;
 176   8                      }
 177   7                    }
 178   6                    else
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 4   

 179   6                    {
 180   7                      validador =1;
 181   7                      
 182   7                    }               
 183   6                  }
 184   5                  else
 185   5                  {
 186   6                    validador =1;
 187   6                    
 188   6                  }
 189   5                }
 190   4                
 191   4              }
 192   3              else
 193   3              {
 194   4                validador =1;
 195   4                
 196   4              }
 197   3            
 198   3            }
 199   2            
 200   2            else
 201   2            {
 202   3              validador =1;
 203   3            
 204   3            }
 205   2          
 206   2          }
 207   1          
 208   1          else 
 209   1          {
 210   2            validador =1;
 211   2            
 212   2          }
 213   1        
 214   1        return validador;
 215   1        
 216   1      }
 217          /*------------------------------------------------------------------------------
 218          Escribo el reloj en ascii en bloque 
 219          
 220          ------------------------------------------------------------------------------*/
 221          
 222          void Block_write_clock_ascii(unsigned char *datos_clock)  
 223          
 224          {     
 225   1      //dia,mes,año,hora,minutos,segundos,Dia de la semana 
 226   1          
 227   1            /*dia*/
 228   1            wr_clk(WDIA,two_one(*datos_clock,*(datos_clock+1)));                    //dia
 229   1            datos_clock++;
 230   1            datos_clock++;
 231   1            datos_clock++;
 232   1            /*mes*/
 233   1            wr_clk(WMES,two_one(*datos_clock,*(datos_clock+1)));                    //mes
 234   1            datos_clock++;
 235   1            datos_clock++;
 236   1            datos_clock++;
 237   1            datos_clock++;
 238   1            datos_clock++;
 239   1            /*año*/
 240   1            wr_clk(WANO,two_one(*datos_clock,*(datos_clock+1)));                    //año
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 5   

 241   1            datos_clock++;
 242   1            datos_clock++;
 243   1            datos_clock++;
 244   1            /*hora*/
 245   1            wr_clk(WHORA,two_one(*datos_clock,*(datos_clock+1)));                   //hora
 246   1            datos_clock++;
 247   1            datos_clock++;
 248   1            datos_clock++;
 249   1            /*minutos*/
 250   1            wr_clk(WMIN,two_one(*datos_clock,*(datos_clock+1)));                    //minutos
 251   1            datos_clock++;
 252   1            datos_clock++;
 253   1            datos_clock++;
 254   1            /*segundos*/
 255   1            wr_clk(WSEG,two_one(*datos_clock,*(datos_clock+1)));                    //segundos
 256   1            datos_clock++;
 257   1            datos_clock++;
 258   1            datos_clock++;
 259   1            /*dia de la semana*/
 260   1            wr_clk(WDIA_SEMANA,(*datos_clock&0x0f));                                //dia de la semana
 261   1        
 262   1      }
 263          /*------------------------------------------------------------------------------
 264          rutinas de conversiones  de bcd a hex
 265          ------------------------------------------------------------------------------*/
 266          unsigned char bcd_hex (unsigned char l_data)
 267           {
 268   1        unsigned char temp,j;
 269   1        temp=l_data;
 270   1        temp>>=4;
 271   1        temp=temp & 0x0f;
 272   1        if (temp!=0x00)
 273   1        {
 274   2          l_data=l_data & 0x0f;
 275   2          for (j=0;j<temp;j++)
 276   2          {
 277   3              l_data=l_data+0x0a;
 278   3          } 
 279   2        }
 280   1        return l_data;
 281   1       }
 282           /*------------------------------------------------------------------------------
 283           Rutina que convierte de Hex a bcd 
 284          ------------------------------------------------------------------------------*/
 285           unsigned char hex_bcd (unsigned char byte)
 286          {
 287   1        unsigned char nibble_h; 
 288   1        unsigned char nibble_l;
 289   1        unsigned char k,byte_out;
 290   1      
 291   1        nibble_h=0x00;
 292   1        nibble_l=0x00;
 293   1      
 294   1        for (k=0;k<byte;k++)
 295   1        {
 296   2          nibble_l=nibble_l+0x01;
 297   2          if (nibble_l==0x0a)
 298   2          {
 299   3            nibble_l=0x00;
 300   3            nibble_h=nibble_h+0x01;
 301   3          }
 302   2         }
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 6   

 303   1         nibble_h<<=4;
 304   1         nibble_h=nibble_h & 0xf0;
 305   1         nibble_l=nibble_l & 0x0f;
 306   1         byte_out=(nibble_h | nibble_l);
 307   1         return byte_out;
 308   1        
 309   1      }
 310          /*------------------------------------------------------------------------------
 311            CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL                      
 312          valorhex= pasa el byte en Hex y lo convierte en decimal
 313          buffer=   se debuelve la conversion en un arreglo en ascii
 314          ------------------------------------------------------------------------------*/
 315          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex)
 316          {
 317   1        unsigned char numero, centena, decena;
 318   1      
 319   1        centena=0;
 320   1        decena=0;
 321   1        numero=valorhex;
 322   1      
 323   1        while (numero>=0x064)                           /* resto centena en ascii100*/
 324   1        {
 325   2          numero=numero-0x64;
 326   2          centena=centena+1;
 327   2        }
 328   1          *buffer=centena|0x30;
 329   1          buffer++;
 330   1        while (numero>=0x0a)                            /* resto 10 decena en ascii*/
 331   1        {
 332   2          numero=numero-0x0a;
 333   2          decena=decena+1;
 334   2        }
 335   1        *buffer=decena|0x30;
 336   1        buffer++;
 337   1        *buffer=numero|0x30;                            /*unidad en ascii */
 338   1        buffer++;
 339   1        *buffer= 0;
 340   1      
 341   1      }
 342          /*------------------------------------------------------------------------------
 343            CONVIERTE DE 2BYTE HEXADECIMAL A DECIMAL                      
 344          
 345          ------------------------------------------------------------------------------*/
 346          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l)
 347          {
 348   1        unsigned int valor,numero;
 349   1        unsigned char temp,dmil, mil, centena, decena;
 350   1      
 351   1        valor=0;
 352   1        dmil=0;
 353   1        mil=0;
 354   1        centena=0;
 355   1        decena=0;
 356   1        
 357   1         
 358   1        temp=id_h;
 359   1        temp=temp&0xf0;
 360   1        temp>>=4;
 361   1      
 362   1        valor=valor+(pow(16,3))*temp;
 363   1        temp=id_h;
 364   1        temp=temp&0x0f;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 7   

 365   1        valor=valor+(pow(16,2))*temp;
 366   1      
 367   1        temp=id_l;
 368   1        temp=temp&0xf0;
 369   1        temp>>=4;
 370   1        valor=valor+(pow(16,1))*temp;
 371   1        temp=id_l;
 372   1        temp=temp&0x0f;
 373   1        valor=valor+(pow(16,0))*temp;
 374   1        numero=valor;
 375   1      
 376   1        while (numero>=0x2710)        // resto 10.000 
 377   1        {
 378   2          numero=numero-0x2710;
 379   2          dmil=dmil+1;
 380   2        }
 381   1        *buffer=dmil|0x30;
 382   1          buffer++;
 383   1        while (numero>=0x03e8)        // resto 1.000
 384   1        {
 385   2          numero=numero-0x03e8;
 386   2          mil=mil+1;
 387   2        }
 388   1        *buffer=mil|0x30;
 389   1          buffer++;
 390   1        while (numero>=0x064)         // resto 100
 391   1        {
 392   2          numero=numero-0x64;
 393   2          centena=centena+1;
 394   2        }
 395   1        *buffer=centena|0x30;
 396   1          buffer++;
 397   1        while (numero>=0x0a)        // resto 10
 398   1        {
 399   2          numero=numero-0x0a;
 400   2          decena=decena+1;
 401   2        }
 402   1        *buffer=decena|0x30;
 403   1        buffer++;
 404   1        *buffer=numero|0x30;
 405   1        buffer++;
 406   1        *buffer=0;
 407   1        
 408   1      }
 409          /*------------------------------------------------------------------------------
 410           Lee el dato del reloj en bloque 
 411          ------------------------------------------------------------------------------*/
 412          void Block_read_clock_ascii(unsigned char *datos_clock)
 413          {
 414   1        unsigned char dato;
 415   1      
 416   1        //dia,mes,año,hora,minutos
 417   1          
 418   1          /*año*/
 419   1          dato=lee_clk(RANO);
 420   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 421   1          datos_clock++;
 422   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 423   1          datos_clock++;
 424   1        
 425   1        /*mes*/
 426   1          dato=lee_clk(RMES);
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 8   

 427   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 428   1          datos_clock++;
 429   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 430   1          datos_clock++;    
 431   1      
 432   1          /*dia*/
 433   1          dato=lee_clk(RDIA);                       //;bcd_hex(lee_clk(DIA));
 434   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 435   1          datos_clock++;
 436   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 437   1          datos_clock++;
 438   1          
 439   1          
 440   1          /*hora*/            
 441   1          dato=lee_clk(RHORA);
 442   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 443   1          datos_clock++;
 444   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 445   1          datos_clock++;        
 446   1          
 447   1          /*minutos*/         
 448   1          dato=lee_clk(RMIN);
 449   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 450   1          datos_clock++;
 451   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 452   1          datos_clock++;  
 453   1          *datos_clock=0;
 454   1                      
 455   1      } 
 456          void Block_read_Clock_Hex(unsigned char *datos_clock)
 457          {
 458   1        
 459   1        /*año*/
 460   1        *datos_clock=bcd_hex(lee_clk(RANO));      
 461   1         datos_clock++;
 462   1        /*mes*/
 463   1        *datos_clock=bcd_hex(lee_clk(RMES));      
 464   1         datos_clock++;
 465   1        /*Dia*/
 466   1        *datos_clock=bcd_hex(lee_clk(RDIA));      
 467   1         datos_clock++;
 468   1        /*hora*/  
 469   1        *datos_clock=bcd_hex(lee_clk(RHORA));     
 470   1         datos_clock++;
 471   1        /*minutos*/ 
 472   1        *datos_clock=bcd_hex(lee_clk(RMIN));      
 473   1         datos_clock++;
 474   1      
 475   1      }
 476          void hex_ascii(unsigned char * datos,unsigned char * fecha_asii)
 477          {
 478   1        unsigned char dato;
 479   1        //unsigned fecha_asii[7];
 480   1        
 481   1          dato=hex_bcd (*datos);
 482   1          *fecha_asii=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 483   1          *(fecha_asii+1)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 484   1          datos++;
 485   1        
 486   1          dato=hex_bcd (*(datos));
 487   1            *(fecha_asii+2)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 488   1            *(fecha_asii+3)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 9   

 489   1          datos++;
 490   1        
 491   1          dato=hex_bcd (*(datos));
 492   1            *(fecha_asii+4)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 493   1            *(fecha_asii+5)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 494   1          
 495   1            *(fecha_asii+6)=0;
 496   1        
 497   1      }
 498          
 499          //void Block_read_Clock_Rasberry(unsigned char *datos_clock)
 500          //{
 501              
 502          //unsigned char dato;
 503            /*mes*/
 504          //    dato=lee_clk(RMES);
 505          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 506          //    datos_clock++;
 507          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 508          //    datos_clock++;    
 509          
 510              /*dia*/
 511          //    dato=lee_clk(RDIA);                       //;bcd_hex(lee_clk(DIA));
 512          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 513          //    datos_clock++;
 514          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 515          //    datos_clock++;
 516              
 517              
 518              /*hora*/            
 519          //    dato=lee_clk(RHORA);
 520          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 521          //    datos_clock++;
 522          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 523          //    datos_clock++;        
 524              
 525              /*minutos*/         
 526          //    dato=lee_clk(RMIN);
 527          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 528          //    datos_clock++;
 529          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 530          //    datos_clock++;  
 531              
 532                  /*año*/
 533          //    dato=lee_clk(RANO);
 534          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 535          //    datos_clock++;
 536          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 537          //    datos_clock++;
 538              /*.*/
 539          //    *datos_clock= '.';
 540          //      datos_clock++;
 541                /*segundos*/          
 542          //    dato=lee_clk(RSEG);
 543          //    *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 544          //    datos_clock++;
 545          //    *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 546          //    datos_clock++;  
 547          //    *datos_clock=0;
 548                
 549          //}
 550          void Block_read_clock_ascii_rasberry(unsigned char *datos_clock)
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 10  

 551          {
 552   1        unsigned char dato;
 553   1      
 554   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 555   1        /*mes*/
 556   1          dato=(lee_clk(RMES));
 557   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 558   1          datos_clock++;
 559   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 560   1          datos_clock++;    
 561   1      
 562   1          /*dia*/
 563   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 564   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 565   1          datos_clock++;
 566   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 567   1          datos_clock++;
 568   1          
 569   1        
 570   1          /*año*/
 571   1          dato=(lee_clk(RANO));
 572   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 573   1          datos_clock++;
 574   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 575   1          datos_clock++;
 576   1        
 577   1        
 578   1          
 579   1          /*hora*/            
 580   1          dato=(lee_clk(RHORA));
 581   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 582   1          datos_clock++;
 583   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 584   1          datos_clock++;        
 585   1          
 586   1          /*minutos*/   
 587   1          dato=(lee_clk(RMIN));   
 588   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 589   1          datos_clock++;
 590   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 591   1          datos_clock++;  
 592   1          *datos_clock='.';
 593   1          datos_clock++;      
 594   1          
 595   1            /*segundos*/    
 596   1          dato=(lee_clk(RSEG));   
 597   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 598   1          datos_clock++;
 599   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 600   1          
 601   1          datos_clock++;  
 602   1          *datos_clock=0;
 603   1                      
 604   1      } 
 605          /*------------------------------------------------------------------------------
 606           Lee el dato del reloj en bloque 
 607          ------------------------------------------------------------------------------*/
 608          void Block_read_Clock(unsigned char *datos_clock)
 609          {
 610   1        /*año*/ 
 611   1        *datos_clock=lee_clk(RANO);     
 612   1         datos_clock++;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 11  

 613   1        /*mes*/
 614   1        *datos_clock=lee_clk(RMES);     
 615   1         datos_clock++;
 616   1        /*Dia*/
 617   1        *datos_clock=lee_clk(RDIA);     
 618   1         datos_clock++;
 619   1        /*hora*/  
 620   1        *datos_clock=lee_clk(RHORA);      
 621   1         datos_clock++;
 622   1        /*minutos*/ 
 623   1        *datos_clock=lee_clk(RMIN);     
 624   1         datos_clock++;
 625   1        /*segundos*/  
 626   1        *datos_clock=lee_clk(RSEG);
 627   1        datos_clock++;
 628   1        *datos_clock=00;
 629   1          
 630   1      }
 631          void cond_ini_clock()
 632          {
 633   1        sck=0;          //Reloj
 634   1        rst=0;
 635   1        io=1;
 636   1      }
 637          
 638          /*------------------------------------------------------------------------------
 639          funcion q verifica la fecha maxima de salida 
 640          VERIFICA PAGO (sin_pago)....                                      
 641          SI PAGO, VERIFICA QUE LA FECHA MAX DE SALIDA NO EXCEDE A LA ACTUAL (acceso_ok)              
 642          (0) pago parqueadero y esta entre el tiempo permitido
 643          (1) no hay pago
 644          (2) excede tiempo de gracia
 645          ------------------------------------------------------------------------------*/
 646          char check_fechaOut(char *buffer)
 647          {
 648   1        char temp=1;
 649   1        unsigned char datos_clk[6];
 650   1        
 651   1      
 652   1        /*se valida la fecha de salida si es cero no ha pagado*/
 653   1      
 654   1        if ((*buffer==0x00)&&(*(buffer+1)==0x00)&&(*(buffer+2)==0x00)&&(*(buffer+3)==0x00)&&(*(buffer+4)==0x00))
 655   1          {
 656   2          
 657   2          temp=1;                                                         /*no hay pago*/
 658   2            
 659   2          }
 660   1        else
 661   1          {
 662   2            
 663   2            Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 664   2        
 665   2          if (Debug_Tibbo==1)
 666   2          {
 667   3             Debug_Fecha_actual(datos_clk);                               /*muestro la fecha y hora actual*/
 668   3            
 669   3          } 
 670   2            
 671   2          
 672   2          if (datos_clk[0]<*buffer)                                       /*comparo el año leido de board_pcb con el dato de salida 
             -leido en  la MF */
 673   2          {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 12  

 674   3            temp=0;                                                       /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 675   3          }
 676   2          else if (datos_clk[0]==*buffer)                                 /*el año es igual*/
 677   2          {
 678   3            if (datos_clk[1]<*(buffer+1))                                 /*comparo el mes*/
 679   3            {
 680   4              temp=0;                                                     /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 681   4            }
 682   3            else if (datos_clk[1]==*(buffer+1))                           /*el mes es igual*/
 683   3            {
 684   4              if (datos_clk[2]<*(buffer+2))                               /*se compara el dia*/
 685   4              {
 686   5                  temp=0;                                                 /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 687   5              }
 688   4              else if(datos_clk[2]==*(buffer+2))                          /*el dia es igual*/
 689   4              {
 690   5                if (datos_clk[3]<*(buffer+3))                             /*comparo la hora del board_pcb con el dato de salida de 
             -la MF*/
 691   5                {
 692   6                      temp=0;                                             /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 693   6                }
 694   5                else if (datos_clk[3]==*(buffer+3))                       /*es igual la hora*/
 695   5                {
 696   6                  if (datos_clk[4]<*(buffer+4))   //(minut<=minutOut)
 697   6                  {
 698   7                    temp=0;                                               /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 699   7                  }
 700   6                  else 
 701   6                  {
 702   7                    temp=2;                                               /*Excede T.GRACIA*/
 703   7                  }
 704   6      
 705   6                }
 706   5                else
 707   5                {
 708   6                  temp=2;                                                 /*Excede T.GRACIA*/
 709   6                }
 710   5              }
 711   4              else
 712   4              {
 713   5                temp=2;                                                   /*Excede T.GRACIA*/
 714   5              } 
 715   4            }
 716   3            else
 717   3            {
 718   4              temp=2;                                                     /*Excede T.GRACIA*/
 719   4            }
 720   3          }
 721   2          else
 722   2          {
 723   3            temp=2;                                                       /*Excede T.GRACIA*/
 724   3       
 725   3          }
 726   2          
 727   2        }
 728   1        return temp;
 729   1      }
 730          unsigned char check_fechaOut_2(unsigned char *buffer)
 731          {
 732   1        unsigned long int fecha_inicio,fecha_fin;
 733   1        unsigned char datos_clk[6];
 734   1        char temp;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 13  

 735   1        
 736   1        
 737   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 738   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 739   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 740   1          
 741   1            
 742   1          if (fecha_fin >= fecha_inicio )           
 743   1          {
 744   2            temp = True;
 745   2          }
 746   1          else
 747   1          {
 748   2            temp = False;
 749   2          }
 750   1            
 751   1      
 752   1        
 753   1        return temp;
 754   1      }
 755          //*******************************************************************************************
 756          void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos)
 757          {
 758   1      
 759   1      
 760   1        int ano_inT;
 761   1        bit bisiesto=0;
 762   1      
 763   1        unsigned char ano_out, mes_out, dia_out, hora_out, min_out;
 764   1        unsigned char Horas_Dcto, Minutos_Dcto, Xtemp; 
 765   1      
 766   1        bit Tiempo_Dcto=0;
 767   1      
 768   1      if ((*(buffer+0x0b)==0x00)&&(*(buffer+0x0c)==0x00)&&(*(buffer+0x0d)==0x00)&&(*(buffer+0x0e)==0x00)&&(*(buf
             -fer+0x0f)==0x00))
 769   1      {
 770   2      
 771   2      //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 772   2      //  Descuento Maximo 999 minutos  = 16 Horas  39 Minutos
 773   2      //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 774   2        if (Val_DctoMinutos >= 60 )
 775   2        {
 776   3          Horas_Dcto=Val_DctoMinutos/60;
 777   3          Minutos_Dcto=Val_DctoMinutos-(Horas_Dcto*60);
 778   3      
 779   3        }
 780   2        else
 781   2        {
 782   3          Minutos_Dcto=Val_DctoMinutos;
 783   3          Horas_Dcto=0;
 784   3        }
 785   2      //********************************************************************************************************
             -*************************************
 786   2      //  Aumenta Primero Minutos
 787   2      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 788   2        if (Minutos_Dcto!=0)
 789   2        {
 790   3          min_out=*(buffer+4)+Minutos_Dcto;         
 791   3          if (min_out>59)                   // Si los minutos no sube de 60 no hay que aumentar nada
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 14  

 792   3          {
 793   4      //----------------------------------------------------
 794   4            Xtemp=(int)(min_out/60);          // Numero de Horas a aumentar
 795   4            min_out=min_out-(Xtemp*60);         // Total de minutos
 796   4      //----------------------------------------------------
 797   4            hora_out=*(buffer+3)+Xtemp;         /*horas*/
 798   4            if (hora_out>23)
 799   4            {
 800   5              Xtemp= hora_out/24;             // Numero Dias a aumentar
 801   5              hora_out=hora_out-(Xtemp*24);       // Total de Horas
 802   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 803   5              dia_out=*(buffer+2)+Xtemp;
 804   5              if ((*(buffer+1)==1)||(*(buffer+1)==3)||(*(buffer+1)==5)||(*(buffer+1)==7)||(*(buffer+1)==8)||(*(buffe
             -r+1)==10)||(*(buffer+1)==12))   // Meses de 31 dias
 805   5              {
 806   6                if (dia_out>31)
 807   6                {
 808   7                  dia_out=dia_out-31;
 809   7                  mes_out=*(buffer+1)+1;
 810   7                  if (mes_out>12)
 811   7                  {
 812   8                    ano_out=*(buffer+0)+1;
 813   8                    mes_out=1;
 814   8                  }
 815   7                  else
 816   7                  {
 817   8                    ano_out=*(buffer+0);
 818   8                  }
 819   7                }
 820   6                else
 821   6                {
 822   7                  mes_out=*(buffer+1);                        /*mes*/
 823   7                  ano_out=*(buffer+0);                        /*año*/
 824   7                } 
 825   6              }
 826   5              else if ((*(buffer+1)==4)||(*(buffer+1)==6)||(*(buffer+1)==9)||(*(buffer+1)==11))                   // Meses de
             - 30 dias
 827   5              {
 828   6                if (dia_out>30)
 829   6                {
 830   7                  dia_out=dia_out-30;
 831   7                  mes_out=*(buffer+1)+1;
 832   7                  ano_out=*(buffer+0);          
 833   7                }
 834   6                else
 835   6                {
 836   7                  mes_out=*(buffer+1);
 837   7                  ano_out=*(buffer+0);  
 838   7                }
 839   6      
 840   6              }
 841   5              else if (*(buffer+1)==2)                                        // Febtrero Es biciesto?
 842   5              {
 843   6      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 844   6                ano_inT=*(buffer+0)+2000;
 845   6                bisiesto=0;
 846   6      
 847   6      /*
 848   6                float flotante=12.345;
 849   6                int entero;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 15  

 850   6      
 851   6                entero=(int)flotante;
 852   6      */
 853   6        
 854   6      /*          division=(ano_inT/4);
 855   6                intpart=division;
 856   6                decpart= ano_inT - (intpart*4);
 857   6                if (decpart==0)
 858   6                {
 859   6                  division=(ano_inT/10);
 860   6                    intpart = division;
 861   6                    decpart = ano_inT - (intpart*10);
 862   6                  if (decpart==0)
 863   6                  {
 864   6                    division=(ano_inT/40);
 865   6                      intpart = division;
 866   6                      decpart = ano_inT - (intpart*40);
 867   6      
 868   6      
 869   6                    if (decpart==0)
 870   6                    {
 871   6                      bisiesto=1;
 872   6                    }
 873   6                    else
 874   6                    {
 875   6                      bisiesto=0;
 876   6                    }
 877   6                  }
 878   6                  else
 879   6                  {
 880   6                    bisiesto=1;
 881   6                  }
 882   6                }
 883   6      */
 884   6      
 885   6                if ((*(buffer+0)==16)||(*(buffer+0)==20)||(*(buffer+0)==24)||(*(buffer+0)==28)||(*(buffer+0)==32)||(*
             -(buffer+0)==36))
 886   6                {
 887   7                  bisiesto=1;
 888   7                }   
 889   6      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 890   6                if (bisiesto==1)
 891   6                {
 892   7                  if (dia_out>29)
 893   7                  {
 894   8                    ano_out=*(buffer+0);
 895   8                    dia_out=dia_out-29;
 896   8                    mes_out=*(buffer+1)+1;
 897   8                
 898   8                  }
 899   7                  else
 900   7                  {
 901   8                    ano_out=*(buffer+0);  
 902   8                    dia_out=dia_out;
 903   8                    mes_out=*(buffer+1);
 904   8                  }
 905   7                }
 906   6                else
 907   6                {
 908   7                  if (dia_out>28)
 909   7                  {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 16  

 910   8                    dia_out=dia_out-28;
 911   8                    mes_out=*(buffer+1)+1;
 912   8                    ano_out=*(buffer+0);
 913   8                  }
 914   7                  else
 915   7                  {
 916   8                    dia_out=dia_out;
 917   8                    mes_out=*(buffer+1);
 918   8                    ano_out=*(buffer+0);  
 919   8                  }
 920   7                }
 921   6      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 922   6              }
 923   5              else                                                // Error fecha
 924   5              {
 925   6                dia_out=dia_out;
 926   6                mes_out=*(buffer+1);
 927   6                ano_out=*(buffer+0);  
 928   6              }
 929   5            }
 930   4            else
 931   4            {
 932   5              dia_out=*(buffer+2);
 933   5              mes_out=*(buffer+1);
 934   5              ano_out=*(buffer+0);
 935   5            }
 936   4          }
 937   3          else
 938   3          {
 939   4            hora_out=*(buffer+3);
 940   4            dia_out=*(buffer+2);
 941   4            mes_out=*(buffer+1);
 942   4            ano_out=*(buffer+0);
 943   4          }
 944   3        }
 945   2        else
 946   2        {
 947   3          min_out=*(buffer+4);
 948   3          hora_out=*(buffer+3);
 949   3          dia_out=*(buffer+2);
 950   3          mes_out=*(buffer+1);
 951   3          ano_out=*(buffer+0);
 952   3        }
 953   2      //********************************************************************************************************
             -*************************************
 954   2      //  AUMENTA HORAS
 955   2      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 956   2          if (Horas_Dcto!=0)
 957   2          {
 958   3              hora_out=hora_out+Horas_Dcto;
 959   3              if (hora_out>23)
 960   3              {
 961   4                Xtemp= hora_out/24;             // Numero Dias a aumentar
 962   4                hora_out=hora_out-(Xtemp*24);       // Total de Horas
 963   4        //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 964   4                dia_out=dia_out+Xtemp;
 965   4                if ((mes_out==1)||(mes_out==3)||(mes_out==5)||(mes_out==7)||(mes_out==8)||(mes_out==10)||(mes_out==12
             -))    // Meses de 31 dias
 966   4                {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 17  

 967   5                  if (dia_out>31)
 968   5                  {
 969   6                    dia_out=dia_out-31;
 970   6                    mes_out=mes_out+1;
 971   6                    if (mes_out>12)
 972   6                    {
 973   7                      ano_out=ano_out+1;
 974   7                      mes_out=1;
 975   7                    }
 976   6                    else
 977   6                    {
 978   7                      ano_out=ano_out;
 979   7                    }
 980   6                  }
 981   5                }
 982   4                else if ((mes_out==4)||(mes_out==6)||(mes_out==9)||(mes_out==11))                   // Meses de 30 dias
 983   4                {
 984   5                  if (dia_out>30)
 985   5                  {
 986   6                    dia_out=dia_out-30;
 987   6                    mes_out=mes_out+1;
 988   6                    ano_out=ano_out;          
 989   6                  }
 990   5                  else
 991   5                  {
 992   6                    mes_out=mes_out;
 993   6                    ano_out=ano_out;  
 994   6                  }
 995   5                }
 996   4                else if (mes_out==2)                                        // Febtrero Es biciesto?
 997   4                {
 998   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 999   5                  ano_inT=ano_out+2000;
1000   5                  bisiesto=0;
1001   5      
1002   5      
1003   5      /*            division=(ano_inT/4);
1004   5                  intpart = division;
1005   5                  decpart= ano_inT - (intpart*4);
1006   5        
1007   5        
1008   5                  if (decpart==0)
1009   5                  {
1010   5                    division=(ano_inT/10);
1011   5                      intpart = division;
1012   5                      decpart = ano_inT - (intpart*10);
1013   5                    if (decpart==0)
1014   5                    {
1015   5                      division=(ano_inT/40);
1016   5                        intpart = division;
1017   5                        decpart = ano_inT - (intpart*40);
1018   5                      if (decpart==0)
1019   5                      {
1020   5                        bisiesto=1;
1021   5                      }
1022   5                      else
1023   5                      {
1024   5                        bisiesto=0;
1025   5                      }
1026   5                    }
1027   5                    else
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 18  

1028   5                    {
1029   5                      bisiesto=1;
1030   5                    }
1031   5                  }
1032   5      */
1033   5                  if ((ano_out==16)||(ano_out==20)||(ano_out==24)||(ano_out==28)||(ano_out==32)||(ano_out==36))
1034   5                  {
1035   6                    bisiesto=1;
1036   6                  }   
1037   5      
1038   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
1039   5                  if (bisiesto==1)
1040   5                  {
1041   6                    if (dia_out>29)
1042   6                    {
1043   7                      dia_out=dia_out-29;
1044   7                      mes_out=mes_out+1;
1045   7                      ano_out=ano_out;            
1046   7                    }
1047   6                    else
1048   6                    {
1049   7                      dia_out=dia_out;
1050   7                      mes_out=mes_out;
1051   7                      ano_out=ano_out;
1052   7                    }
1053   6                  }
1054   5                  else
1055   5                  {
1056   6                    if (dia_out>28)
1057   6                    {
1058   7                      dia_out=dia_out-28;
1059   7                      mes_out=mes_out+1;
1060   7                      ano_out=ano_out;                          
1061   7                    }
1062   6                  }
1063   5        //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
1064   5                }
1065   4        
1066   4              }
1067   3          }
1068   2      
1069   2      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
1070   2        *(buffer+0x0b)=ano_out;
1071   2        *(buffer+0x0c)=mes_out;
1072   2        *(buffer+0x0d)=dia_out;
1073   2        *(buffer+0x0e)=hora_out;
1074   2        *(buffer+0x0f)=min_out;   
1075   2      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
1076   2        }
1077   1        
1078   1      
1079   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4889    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      85
C51 COMPILER V9.59.0.0   CLOCK                                                             07/28/2021 11:20:15 PAGE 19  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
