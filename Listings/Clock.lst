C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Clock.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          
   2          #include <Clock.h>
   3          #include <reg51.h>
   4          
   5          /*funcion prototipo*/
   6          extern void Delay (void);
   7          extern void Delay_20us(unsigned int cnt);
   8          extern void Debug_Fecha_actual(unsigned char *buffer);
   9          extern float pow   (float x, float y);
  10          /*variables externas */
  11          extern unsigned char  Debug_Tibbo;
  12          
  13          sbit sck = P1^4 ;                 /* define I/O functions     */
  14          sbit io  = P1^5 ;
  15          sbit rst = P1^6 ;
  16          /*CMD DE ESCRITURA RELOJ*/
  17          #define WDIA            0x86
  18          #define WMES            0x88
  19          #define WANO            0x8C
  20          #define WHORA           0x84
  21          #define WMIN            0x82
  22          #define WSEG            0x80
  23          #define WDIA_SEMANA     0x8A
  24          /*CMD DE LECTURA DEL RELOJ*/
  25          #define RDIA            0x87
  26          #define RMES            0x89
  27          #define RANO            0x8D
  28          #define RHORA           0x85
  29          #define RMIN            0x83
  30          #define RSEG            0x81
  31          #define RDIA_SEMANA     0x8B
  32          
  33          unsigned char data_clk;
  34          //*********************************************************************************
  35          
  36          //*********************************************************************************
  37          void p_ck (void)
  38          {
  39   1          sck=1;
  40   1          Delay();
  41   1          sck=0;
  42   1      }
  43          //*********************************************************************************
  44          void eb_clk(char dir_clk) {
  45   1        int nbits;
  46   1        for (nbits=0; nbits<8; nbits++)
  47   1        {
  48   2          dir_clk >>=1;
  49   2          if (CY==1)
  50   2          { 
  51   3            io=1;
  52   3          }
  53   2          else
  54   2          {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 2   

  55   3            io=0;
  56   3          }
  57   2          p_ck();
  58   2        }
  59   1      }
  60          //*********************************************************************************
  61          char lee_clk (unsigned char dir_clk) {            
  62   1      int nbits;
  63   1        rst=1;
  64   1        Delay_20us(3);
  65   1        eb_clk(dir_clk);
  66   1        for (nbits=0; nbits<8; nbits++)
  67   1        {
  68   2          if (io==1) 
  69   2          {
  70   3          data_clk = data_clk | 0x80;
  71   3          if (nbits<=6) {
  72   4           data_clk >>=1;
  73   4           }
  74   3          }
  75   2          if (io==0)
  76   2          {
  77   3            data_clk = data_clk & 0x7F;
  78   3          if (nbits<=6) 
  79   3           {
  80   4            data_clk >>=1;
  81   4           }
  82   3          }
  83   2          p_ck();
  84   2          } 
  85   1        rst=0;
  86   1        return data_clk;
  87   1      }
  88          //*********************************************************************************
  89          void wr_clk (unsigned char dir_clk, unsigned char byte) {            
  90   1        rst=1;
  91   1        Delay_20us(3);
  92   1        eb_clk(dir_clk);
  93   1        dir_clk=byte;
  94   1        eb_clk(dir_clk);
  95   1        rst=0;
  96   1        
  97   1       }
  98          //****************************************************************************
  99           unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 100          {
 101   1        unsigned char byte_out;
 102   1        byte_h=byte_h&0x0f;
 103   1        byte_h<<=4;
 104   1        byte_l=byte_l&0x0f;
 105   1        byte_out=byte_h|byte_l;
 106   1        return byte_out;
 107   1      }
 108          /*------------------------------------------------------------------------------
 109          
 110          ------------------------------------------------------------------------------*/
 111          unsigned char validar_clk(unsigned char *datos_clock)
 112          {
 113   1        unsigned char validador=0;
 114   1        
 115   1        
 116   1          if ((*datos_clock >= '0') &&(*datos_clock <= '9'))                                /*valida el dia parte alta */
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 3   

 117   1          {
 118   2          
 119   2             if ((*(datos_clock+1) >= '0') &&(*(datos_clock+1) <= '9'))                     /*valida el dia parte baja*/
 120   2            {
 121   3              
 122   3               if ((*(datos_clock+3) >= '0') &&(*(datos_clock+3) <= '9'))             /*valida el mes parte alta*/
 123   3              {
 124   4                if ((*(datos_clock+4) >= '0') &&(*(datos_clock+4) <= '9'))            /*valida el mes parte baja */
 125   4                {
 126   5                 if ((*(datos_clock+8) >= '0') &&(*(datos_clock+8) <= '9'))         /*año baja*/      
 127   5                  {
 128   6                   if ((*(datos_clock+0x0b) >= '0')&&(*(datos_clock+0x0b) <= '9'))          /*hora alta*/ 
 129   6                    {
 130   7                    if ((*(datos_clock+0x0c) >= '0') &&(*(datos_clock+0x0c) <= '9'))          /*hora baja*/ 
 131   7                      {
 132   8                     if ((*(datos_clock+0x0e) >= '0') &&(*(datos_clock+0x0e) <= '9'))       /*minutos alta*/
 133   8                        {
 134   9                      if ((*(datos_clock+0x0f) >= '0') &&(*(datos_clock+0x0f) <= '9'))        /*minutos baja*/
 135   9                        {
 136  10                       if ((*(datos_clock+0x11) >= '0') &&(*(datos_clock+0x11) <= '9'))       /*segundos alta*/
 137  10                            {
 138  11                        if ((*(datos_clock+0x12) >= '0') &&(*(datos_clock+0x12) <= '9'))        /*segundos baja*/
 139  11                          {
 140  12                          if ((*(datos_clock+0x14) >= '0') &&(*(datos_clock+0x14) <= '9'))        /*dia de la semana*/
 141  12                           {
 142  13                                  validador=0;
 143  13                           }
 144  12                              }
 145  11                              else
 146  11                              {
 147  12                                validador =1;
 148  12                              }
 149  11                            }
 150  10                            else
 151  10                            {
 152  11                              validador =1;
 153  11                          
 154  11                            }
 155  10                          }
 156   9                          else
 157   9                          {
 158  10                            validador =1;
 159  10                        
 160  10                          }
 161   9                      
 162   9                        }
 163   8                        else
 164   8                        {
 165   9                          validador =1;
 166   9                        
 167   9                        }
 168   8                      }
 169   7                      else
 170   7                      {
 171   8                        validador =1;
 172   8                        //break;
 173   8                      }
 174   7                    }
 175   6                    else
 176   6                    {
 177   7                      validador =1;
 178   7                      
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 4   

 179   7                    }               
 180   6                  }
 181   5                  else
 182   5                  {
 183   6                    validador =1;
 184   6                    
 185   6                  }
 186   5                }
 187   4                
 188   4              }
 189   3              else
 190   3              {
 191   4                validador =1;
 192   4                
 193   4              }
 194   3            
 195   3            }
 196   2            
 197   2            else
 198   2            {
 199   3              validador =1;
 200   3            
 201   3            }
 202   2          
 203   2          }
 204   1          
 205   1          else 
 206   1          {
 207   2            validador =1;
 208   2            
 209   2          }
 210   1        
 211   1        return validador;
 212   1        
 213   1      }
 214          /*------------------------------------------------------------------------------
 215          Escribo el reloj en ascii en bloque 
 216          
 217          ------------------------------------------------------------------------------*/
 218          
 219          void Block_write_clock_ascii(unsigned char *datos_clock)  
 220          
 221          {     
 222   1      //dia,mes,año,hora,minutos,segundos,Dia de la semana 
 223   1          
 224   1            /*dia*/
 225   1            wr_clk(WDIA,two_one(*datos_clock,*(datos_clock+1)));                    //dia
 226   1            datos_clock++;
 227   1            datos_clock++;
 228   1            datos_clock++;
 229   1            /*mes*/
 230   1            wr_clk(WMES,two_one(*datos_clock,*(datos_clock+1)));                    //mes
 231   1            datos_clock++;
 232   1            datos_clock++;
 233   1            datos_clock++;
 234   1            datos_clock++;
 235   1            datos_clock++;
 236   1            /*año*/
 237   1            wr_clk(WANO,two_one(*datos_clock,*(datos_clock+1)));                    //año
 238   1            datos_clock++;
 239   1            datos_clock++;
 240   1            datos_clock++;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 5   

 241   1            /*hora*/
 242   1            wr_clk(WHORA,two_one(*datos_clock,*(datos_clock+1)));                   //hora
 243   1            datos_clock++;
 244   1            datos_clock++;
 245   1            datos_clock++;
 246   1            /*minutos*/
 247   1            wr_clk(WMIN,two_one(*datos_clock,*(datos_clock+1)));                    //minutos
 248   1            datos_clock++;
 249   1            datos_clock++;
 250   1            datos_clock++;
 251   1            /*segundos*/
 252   1            wr_clk(WSEG,two_one(*datos_clock,*(datos_clock+1)));                    //segundos
 253   1            datos_clock++;
 254   1            datos_clock++;
 255   1            datos_clock++;
 256   1            /*dia de la semana*/
 257   1            wr_clk(WDIA_SEMANA,(*datos_clock&0x0f));                                //dia de la semana
 258   1        
 259   1      }
 260          /*------------------------------------------------------------------------------
 261          rutinas de conversiones  de bcd a hex
 262          ------------------------------------------------------------------------------*/
 263          unsigned char bcd_hex (unsigned char l_data)
 264           {
 265   1        unsigned char temp,j;
 266   1        temp=l_data;
 267   1        temp>>=4;
 268   1        temp=temp & 0x0f;
 269   1        if (temp!=0x00)
 270   1        {
 271   2          l_data=l_data & 0x0f;
 272   2          for (j=0;j<temp;j++)
 273   2          {
 274   3              l_data=l_data+0x0a;
 275   3          } 
 276   2        }
 277   1        return l_data;
 278   1       }
 279           /*------------------------------------------------------------------------------
 280           Rutina que convierte de Hex a bcd 
 281          ------------------------------------------------------------------------------*/
 282           unsigned char hex_bcd (unsigned char byte)
 283          {
 284   1        unsigned char nibble_h; 
 285   1        unsigned char nibble_l;
 286   1        unsigned char k,byte_out;
 287   1      
 288   1        nibble_h=0x00;
 289   1        nibble_l=0x00;
 290   1      
 291   1        for (k=0;k<byte;k++)
 292   1        {
 293   2          nibble_l=nibble_l+0x01;
 294   2          if (nibble_l==0x0a)
 295   2          {
 296   3            nibble_l=0x00;
 297   3            nibble_h=nibble_h+0x01;
 298   3          }
 299   2         }
 300   1         nibble_h<<=4;
 301   1         nibble_h=nibble_h & 0xf0;
 302   1         nibble_l=nibble_l & 0x0f;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 6   

 303   1         byte_out=(nibble_h | nibble_l);
 304   1         return byte_out;
 305   1        
 306   1      }
 307          /*------------------------------------------------------------------------------
 308            CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL                      
 309          valorhex= pasa el byte en Hex y lo convierte en decimal
 310          buffer=   se debuelve la conversion en un arreglo en ascii
 311          ------------------------------------------------------------------------------*/
 312          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex)
 313          {
 314   1        unsigned char numero, centena, decena;
 315   1      
 316   1        centena=0;
 317   1        decena=0;
 318   1        numero=valorhex;
 319   1      
 320   1        while (numero>=0x064)                           /* resto centena en ascii100*/
 321   1        {
 322   2          numero=numero-0x64;
 323   2          centena=centena+1;
 324   2        }
 325   1          *buffer=centena|0x30;
 326   1          buffer++;
 327   1        while (numero>=0x0a)                            /* resto 10 decena en ascii*/
 328   1        {
 329   2          numero=numero-0x0a;
 330   2          decena=decena+1;
 331   2        }
 332   1        *buffer=decena|0x30;
 333   1        buffer++;
 334   1        *buffer=numero|0x30;                            /*unidad en ascii */
 335   1        
 336   1      
 337   1      }
 338          /*------------------------------------------------------------------------------
 339            CONVIERTE DE 2BYTE HEXADECIMAL A DECIMAL                      
 340          
 341          ------------------------------------------------------------------------------*/
 342          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l)
 343          {
 344   1        unsigned int valor,numero;
 345   1        unsigned char temp,dmil, mil, centena, decena;
 346   1      
 347   1        valor=0;
 348   1        dmil=0;
 349   1        mil=0;
 350   1        centena=0;
 351   1        decena=0;
 352   1        
 353   1         
 354   1        temp=id_h;
 355   1        temp=temp&0xf0;
 356   1        temp>>=4;
 357   1      
 358   1        valor=valor+(pow(16,3))*temp;
 359   1        temp=id_h;
 360   1        temp=temp&0x0f;
 361   1        valor=valor+(pow(16,2))*temp;
 362   1      
 363   1        temp=id_l;
 364   1        temp=temp&0xf0;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 7   

 365   1        temp>>=4;
 366   1        valor=valor+(pow(16,1))*temp;
 367   1        temp=id_l;
 368   1        temp=temp&0x0f;
 369   1        valor=valor+(pow(16,0))*temp;
 370   1        numero=valor;
 371   1      
 372   1        while (numero>=0x2710)        // resto 10.000 
 373   1        {
 374   2          numero=numero-0x2710;
 375   2          dmil=dmil+1;
 376   2        }
 377   1        *buffer=dmil|0x30;
 378   1          buffer++;
 379   1        while (numero>=0x03e8)        // resto 1.000
 380   1        {
 381   2          numero=numero-0x03e8;
 382   2          mil=mil+1;
 383   2        }
 384   1        *buffer=mil|0x30;
 385   1          buffer++;
 386   1        while (numero>=0x064)         // resto 100
 387   1        {
 388   2          numero=numero-0x64;
 389   2          centena=centena+1;
 390   2        }
 391   1        *buffer=centena|0x30;
 392   1          buffer++;
 393   1        while (numero>=0x0a)        // resto 10
 394   1        {
 395   2          numero=numero-0x0a;
 396   2          decena=decena+1;
 397   2        }
 398   1        *buffer=decena|0x30;
 399   1        buffer++;
 400   1        *buffer=numero|0x30;
 401   1        buffer++;
 402   1        *buffer=00;
 403   1        
 404   1      }
 405          /*------------------------------------------------------------------------------
 406           Lee el dato del reloj en bloque 
 407          ------------------------------------------------------------------------------*/
 408          void Block_read_clock_ascii(unsigned char *datos_clock)
 409          {
 410   1        unsigned char dato;
 411   1      
 412   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 413   1          
 414   1          /*año*/
 415   1          dato=lee_clk(RANO);
 416   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 417   1          datos_clock++;
 418   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 419   1          datos_clock++;
 420   1        
 421   1        /*mes*/
 422   1          dato=lee_clk(RMES);
 423   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 424   1          datos_clock++;
 425   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 426   1          datos_clock++;    
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 8   

 427   1      
 428   1          /*dia*/
 429   1          dato=lee_clk(RDIA);                       //;bcd_hex(lee_clk(DIA));
 430   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 431   1          datos_clock++;
 432   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 433   1          datos_clock++;
 434   1          
 435   1          
 436   1          /*hora*/            
 437   1          dato=lee_clk(RHORA);
 438   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 439   1          datos_clock++;
 440   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 441   1          datos_clock++;        
 442   1          
 443   1          /*minutos*/         
 444   1          dato=lee_clk(RMIN);
 445   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 446   1          datos_clock++;
 447   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 448   1          datos_clock++;  
 449   1        
 450   1          /*segundos*/    
 451   1          dato=lee_clk(RSEG);
 452   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 453   1          datos_clock++;
 454   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 455   1          datos_clock++;
 456   1        
 457   1          /*dia de la semana*/
 458   1          dato=lee_clk(RDIA_SEMANA);
 459   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 460   1          datos_clock++;
 461   1          *datos_clock=0;
 462   1                      
 463   1      } 
 464          void Block_read_clock_ascii_rasberry(unsigned char *datos_clock)
 465          {
 466   1        unsigned char dato;
 467   1      
 468   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 469   1        /*mes*/
 470   1          dato=(lee_clk(RMES));
 471   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 472   1          datos_clock++;
 473   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 474   1          datos_clock++;    
 475   1      
 476   1          /*dia*/
 477   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 478   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 479   1          datos_clock++;
 480   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 481   1          datos_clock++;
 482   1          
 483   1        
 484   1          /*año*/
 485   1          dato=(lee_clk(RANO));
 486   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 487   1          datos_clock++;
 488   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 9   

 489   1          datos_clock++;
 490   1        
 491   1        
 492   1          
 493   1          /*hora*/            
 494   1          dato=(lee_clk(RHORA));
 495   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 496   1          datos_clock++;
 497   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 498   1          datos_clock++;        
 499   1          
 500   1          /*minutos*/   
 501   1          dato=(lee_clk(RMIN));   
 502   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 503   1          datos_clock++;
 504   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 505   1          datos_clock++;  
 506   1          *datos_clock='.';
 507   1          datos_clock++;      
 508   1          
 509   1            /*segundos*/    
 510   1          dato=(lee_clk(RSEG));   
 511   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 512   1          datos_clock++;
 513   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 514   1          
 515   1          datos_clock++;  
 516   1          *datos_clock=0;
 517   1                      
 518   1      } 
 519          void Block_read_Clock_Hex(unsigned char *datos_clock)
 520          {
 521   1        
 522   1        /*año*/
 523   1        *datos_clock=bcd_hex(lee_clk(RANO));      
 524   1         datos_clock++;
 525   1        /*mes*/
 526   1        *datos_clock=bcd_hex(lee_clk(RMES));      
 527   1         datos_clock++;
 528   1        /*Dia*/
 529   1        *datos_clock=bcd_hex(lee_clk(RDIA));      
 530   1         datos_clock++;
 531   1        /*hora*/  
 532   1        *datos_clock=bcd_hex(lee_clk(RHORA));     
 533   1         datos_clock++;
 534   1        /*minutos*/ 
 535   1        *datos_clock=bcd_hex(lee_clk(RMIN));      
 536   1         datos_clock++;
 537   1      
 538   1      }
 539          /*
 540          void Block_read_Clock_Hex_bcd(unsigned char *datos_clock)
 541          {
 542              
 543            /*año*/
 544            /**datos_clock=hex_bcd(lee_clk(RANO));      
 545             datos_clock++;
 546            /*mes*/
 547          /*  *datos_clock=hex_bcd(lee_clk(RMES));      
 548             datos_clock++;
 549            /*Dia*/
 550            /**datos_clock=hex_bcd(lee_clk(RDIA));      
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 10  

 551             datos_clock++;
 552            /*hora*/  
 553            /**datos_clock=hex_bcd(lee_clk(RHORA));     
 554             datos_clock++;
 555            /*minutos*/ 
 556          /*  *datos_clock=hex_bcd(lee_clk(RMIN));      
 557             datos_clock++;
 558          }
 559          */
 560          /*------------------------------------------------------------------------------
 561           Lee el dato del reloj en bloque 
 562          ------------------------------------------------------------------------------*/
 563          void Block_read_Clock(unsigned char *datos_clock)
 564          {
 565   1        /*año*/ 
 566   1        *datos_clock=lee_clk(RANO);     
 567   1         datos_clock++;
 568   1        /*mes*/
 569   1        *datos_clock=lee_clk(RMES);     
 570   1         datos_clock++;
 571   1        /*Dia*/
 572   1        *datos_clock=lee_clk(RDIA);     
 573   1         datos_clock++;
 574   1        /*hora*/  
 575   1        *datos_clock=lee_clk(RHORA);      
 576   1         datos_clock++;
 577   1        /*minutos*/ 
 578   1        *datos_clock=lee_clk(RMIN);     
 579   1         datos_clock++;
 580   1        /*segundos*/  
 581   1        *datos_clock=lee_clk(RSEG);
 582   1        datos_clock++;
 583   1        *datos_clock=00;
 584   1          
 585   1      }
 586          void cond_ini_clock()
 587          {
 588   1        sck=0;          //Reloj
 589   1        rst=0;
 590   1        io=1;
 591   1      }
 592          
 593          /*------------------------------------------------------------------------------
 594          funcion q verifica la fecha maxima de salida 
 595          VERIFICA PAGO (sin_pago)....                                      
 596          SI PAGO, VERIFICA QUE LA FECHA MAX DE SALIDA NO EXCEDE A LA ACTUAL (acceso_ok)              
 597          (0) pago parqueadero y esta entre el tiempo permitido
 598          (1) no hay pago
 599          (2) excede tiempo de gracia
 600          ------------------------------------------------------------------------------*/
 601          char check_fechaOut(char *buffer)
 602          {
 603   1        char temp=1;
 604   1        unsigned char datos_clk[6];
 605   1        
 606   1      
 607   1        /*se valida la fecha de salida si es cero no ha pagado*/
 608   1      
 609   1        if ((*buffer==0x00)&&(*(buffer+1)==0x00)&&(*(buffer+2)==0x00)&&(*(buffer+3)==0x00)&&(*(buffer+4)==0x00))
 610   1          {
 611   2          
 612   2          temp=1;                                                         /*no hay pago*/
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 11  

 613   2            
 614   2          }
 615   1        else
 616   1          {
 617   2            
 618   2            Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 619   2        
 620   2          if (Debug_Tibbo==1)
 621   2          {
 622   3             Debug_Fecha_actual(datos_clk);                               /*muestro la fecha y hora actual*/
 623   3            
 624   3          } 
 625   2            
 626   2          
 627   2          if (datos_clk[0]<*buffer)                                       /*comparo el año leido de board_pcb con el dato de salida 
             -leido en  la MF */
 628   2          {
 629   3            temp=0;                                                       /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 630   3          }
 631   2          else if (datos_clk[0]==*buffer)                                 /*el año es igual*/
 632   2          {
 633   3            if (datos_clk[1]<*(buffer+1))                                 /*comparo el mes*/
 634   3            {
 635   4              temp=0;                                                     /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 636   4            }
 637   3            else if (datos_clk[1]==*(buffer+1))                           /*el mes es igual*/
 638   3            {
 639   4              if (datos_clk[2]<*(buffer+2))                               /*se compara el dia*/
 640   4              {
 641   5                  temp=0;                                                 /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 642   5              }
 643   4              else if(datos_clk[2]==*(buffer+2))                          /*el dia es igual*/
 644   4              {
 645   5                if (datos_clk[3]<*(buffer+3))                             /*comparo la hora del board_pcb con el dato de salida de 
             -la MF*/
 646   5                {
 647   6                      temp=0;                                             /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 648   6                }
 649   5                else if (datos_clk[3]==*(buffer+3))                       /*es igual la hora*/
 650   5                {
 651   6                  if (datos_clk[4]<*(buffer+4))   //(minut<=minutOut)
 652   6                  {
 653   7                    temp=0;                                               /*el tiempo esta entre el tiempo de gracia y activa la salida*/
 654   7                  }
 655   6                  else 
 656   6                  {
 657   7                    temp=2;                                               /*Excede T.GRACIA*/
 658   7                  }
 659   6      
 660   6                }
 661   5                else
 662   5                {
 663   6                  temp=2;                                                 /*Excede T.GRACIA*/
 664   6                }
 665   5              }
 666   4              else
 667   4              {
 668   5                temp=2;                                                   /*Excede T.GRACIA*/
 669   5              } 
 670   4            }
 671   3            else
 672   3            {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 12  

 673   4              temp=2;                                                     /*Excede T.GRACIA*/
 674   4            }
 675   3          }
 676   2          else
 677   2          {
 678   3            temp=2;                                                       /*Excede T.GRACIA*/
 679   3       
 680   3          }
 681   2          
 682   2        }
 683   1        return temp;
 684   1      }
 685          
 686          //*******************************************************************************************
 687          void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos)
 688          {
 689   1      
 690   1      
 691   1        int ano_inT;
 692   1        bit bisiesto=0;
 693   1      
 694   1        unsigned char ano_out, mes_out, dia_out, hora_out, min_out;
 695   1        unsigned char Horas_Dcto, Minutos_Dcto, Xtemp; 
 696   1      
 697   1        bit Tiempo_Dcto=0;
 698   1      
 699   1      if ((*(buffer+0x0b)==0x00)&&(*(buffer+0x0c)==0x00)&&(*(buffer+0x0d)==0x00)&&(*(buffer+0x0e)==0x00)&&(*(buf
             -fer+0x0f)==0x00))
 700   1      {
 701   2      
 702   2      //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 703   2      //  Descuento Maximo 999 minutos  = 16 Horas  39 Minutos
 704   2      //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 705   2        if (Val_DctoMinutos >= 60 )
 706   2        {
 707   3          Horas_Dcto=Val_DctoMinutos/60;
 708   3          Minutos_Dcto=Val_DctoMinutos-(Horas_Dcto*60);
 709   3      
 710   3        }
 711   2        else
 712   2        {
 713   3          Minutos_Dcto=Val_DctoMinutos;
 714   3          Horas_Dcto=0;
 715   3        }
 716   2      //********************************************************************************************************
             -*************************************
 717   2      //  Aumenta Primero Minutos
 718   2      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 719   2        if (Minutos_Dcto!=0)
 720   2        {
 721   3          min_out=*(buffer+4)+Minutos_Dcto;         
 722   3          if (min_out>59)                   // Si los minutos no sube de 60 no hay que aumentar nada
 723   3          {
 724   4      //----------------------------------------------------
 725   4            Xtemp=(int)(min_out/60);          // Numero de Horas a aumentar
 726   4            min_out=min_out-(Xtemp*60);         // Total de minutos
 727   4      //----------------------------------------------------
 728   4            hora_out=*(buffer+3)+Xtemp;         /*horas*/
 729   4            if (hora_out>23)
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 13  

 730   4            {
 731   5              Xtemp= hora_out/24;             // Numero Dias a aumentar
 732   5              hora_out=hora_out-(Xtemp*24);       // Total de Horas
 733   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 734   5              dia_out=*(buffer+2)+Xtemp;
 735   5              if ((*(buffer+1)==1)||(*(buffer+1)==3)||(*(buffer+1)==5)||(*(buffer+1)==7)||(*(buffer+1)==8)||(*(buffe
             -r+1)==10)||(*(buffer+1)==12))   // Meses de 31 dias
 736   5              {
 737   6                if (dia_out>31)
 738   6                {
 739   7                  dia_out=dia_out-31;
 740   7                  mes_out=*(buffer+1)+1;
 741   7                  if (mes_out>12)
 742   7                  {
 743   8                    ano_out=*(buffer+0)+1;
 744   8                    mes_out=1;
 745   8                  }
 746   7                  else
 747   7                  {
 748   8                    ano_out=*(buffer+0);
 749   8                  }
 750   7                }
 751   6                else
 752   6                {
 753   7                  mes_out=*(buffer+1);                        /*mes*/
 754   7                  ano_out=*(buffer+0);                        /*año*/
 755   7                } 
 756   6              }
 757   5              else if ((*(buffer+1)==4)||(*(buffer+1)==6)||(*(buffer+1)==9)||(*(buffer+1)==11))                   // Meses de
             - 30 dias
 758   5              {
 759   6                if (dia_out>30)
 760   6                {
 761   7                  dia_out=dia_out-30;
 762   7                  mes_out=*(buffer+1)+1;
 763   7                  ano_out=*(buffer+0);          
 764   7                }
 765   6                else
 766   6                {
 767   7                  mes_out=*(buffer+1);
 768   7                  ano_out=*(buffer+0);  
 769   7                }
 770   6      
 771   6              }
 772   5              else if (*(buffer+1)==2)                                        // Febtrero Es biciesto?
 773   5              {
 774   6      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 775   6                ano_inT=*(buffer+0)+2000;
 776   6                bisiesto=0;
 777   6      
 778   6      /*
 779   6                float flotante=12.345;
 780   6                int entero;
 781   6      
 782   6                entero=(int)flotante;
 783   6      */
 784   6        
 785   6      /*          division=(ano_inT/4);
 786   6                intpart=division;
 787   6                decpart= ano_inT - (intpart*4);
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 14  

 788   6                if (decpart==0)
 789   6                {
 790   6                  division=(ano_inT/10);
 791   6                    intpart = division;
 792   6                    decpart = ano_inT - (intpart*10);
 793   6                  if (decpart==0)
 794   6                  {
 795   6                    division=(ano_inT/40);
 796   6                      intpart = division;
 797   6                      decpart = ano_inT - (intpart*40);
 798   6      
 799   6      
 800   6                    if (decpart==0)
 801   6                    {
 802   6                      bisiesto=1;
 803   6                    }
 804   6                    else
 805   6                    {
 806   6                      bisiesto=0;
 807   6                    }
 808   6                  }
 809   6                  else
 810   6                  {
 811   6                    bisiesto=1;
 812   6                  }
 813   6                }
 814   6      */
 815   6      
 816   6                if ((*(buffer+0)==16)||(*(buffer+0)==20)||(*(buffer+0)==24)||(*(buffer+0)==28)||(*(buffer+0)==32)||(*
             -(buffer+0)==36))
 817   6                {
 818   7                  bisiesto=1;
 819   7                }   
 820   6      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 821   6                if (bisiesto==1)
 822   6                {
 823   7                  if (dia_out>29)
 824   7                  {
 825   8                    ano_out=*(buffer+0);
 826   8                    dia_out=dia_out-29;
 827   8                    mes_out=*(buffer+1)+1;
 828   8                
 829   8                  }
 830   7                  else
 831   7                  {
 832   8                    ano_out=*(buffer+0);  
 833   8                    dia_out=dia_out;
 834   8                    mes_out=*(buffer+1);
 835   8                  }
 836   7                }
 837   6                else
 838   6                {
 839   7                  if (dia_out>28)
 840   7                  {
 841   8                    dia_out=dia_out-28;
 842   8                    mes_out=*(buffer+1)+1;
 843   8                    ano_out=*(buffer+0);
 844   8                  }
 845   7                  else
 846   7                  {
 847   8                    dia_out=dia_out;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 15  

 848   8                    mes_out=*(buffer+1);
 849   8                    ano_out=*(buffer+0);  
 850   8                  }
 851   7                }
 852   6      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 853   6              }
 854   5              else                                                // Error fecha
 855   5              {
 856   6                dia_out=dia_out;
 857   6                mes_out=*(buffer+1);
 858   6                ano_out=*(buffer+0);  
 859   6              }
 860   5            }
 861   4            else
 862   4            {
 863   5              dia_out=*(buffer+2);
 864   5              mes_out=*(buffer+1);
 865   5              ano_out=*(buffer+0);
 866   5            }
 867   4          }
 868   3          else
 869   3          {
 870   4            hora_out=*(buffer+3);
 871   4            dia_out=*(buffer+2);
 872   4            mes_out=*(buffer+1);
 873   4            ano_out=*(buffer+0);
 874   4          }
 875   3        }
 876   2        else
 877   2        {
 878   3          min_out=*(buffer+4);
 879   3          hora_out=*(buffer+3);
 880   3          dia_out=*(buffer+2);
 881   3          mes_out=*(buffer+1);
 882   3          ano_out=*(buffer+0);
 883   3        }
 884   2      //********************************************************************************************************
             -*************************************
 885   2      //  AUMENTA HORAS
 886   2      //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 887   2          if (Horas_Dcto!=0)
 888   2          {
 889   3              hora_out=hora_out+Horas_Dcto;
 890   3              if (hora_out>23)
 891   3              {
 892   4                Xtemp= hora_out/24;             // Numero Dias a aumentar
 893   4                hora_out=hora_out-(Xtemp*24);       // Total de Horas
 894   4        //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 895   4                dia_out=dia_out+Xtemp;
 896   4                if ((mes_out==1)||(mes_out==3)||(mes_out==5)||(mes_out==7)||(mes_out==8)||(mes_out==10)||(mes_out==12
             -))    // Meses de 31 dias
 897   4                {
 898   5                  if (dia_out>31)
 899   5                  {
 900   6                    dia_out=dia_out-31;
 901   6                    mes_out=mes_out+1;
 902   6                    if (mes_out>12)
 903   6                    {
 904   7                      ano_out=ano_out+1;
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 16  

 905   7                      mes_out=1;
 906   7                    }
 907   6                    else
 908   6                    {
 909   7                      ano_out=ano_out;
 910   7                    }
 911   6                  }
 912   5                }
 913   4                else if ((mes_out==4)||(mes_out==6)||(mes_out==9)||(mes_out==11))                   // Meses de 30 dias
 914   4                {
 915   5                  if (dia_out>30)
 916   5                  {
 917   6                    dia_out=dia_out-30;
 918   6                    mes_out=mes_out+1;
 919   6                    ano_out=ano_out;          
 920   6                  }
 921   5                  else
 922   5                  {
 923   6                    mes_out=mes_out;
 924   6                    ano_out=ano_out;  
 925   6                  }
 926   5                }
 927   4                else if (mes_out==2)                                        // Febtrero Es biciesto?
 928   4                {
 929   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 930   5                  ano_inT=ano_out+2000;
 931   5                  bisiesto=0;
 932   5      
 933   5      
 934   5      /*            division=(ano_inT/4);
 935   5                  intpart = division;
 936   5                  decpart= ano_inT - (intpart*4);
 937   5        
 938   5        
 939   5                  if (decpart==0)
 940   5                  {
 941   5                    division=(ano_inT/10);
 942   5                      intpart = division;
 943   5                      decpart = ano_inT - (intpart*10);
 944   5                    if (decpart==0)
 945   5                    {
 946   5                      division=(ano_inT/40);
 947   5                        intpart = division;
 948   5                        decpart = ano_inT - (intpart*40);
 949   5                      if (decpart==0)
 950   5                      {
 951   5                        bisiesto=1;
 952   5                      }
 953   5                      else
 954   5                      {
 955   5                        bisiesto=0;
 956   5                      }
 957   5                    }
 958   5                    else
 959   5                    {
 960   5                      bisiesto=1;
 961   5                    }
 962   5                  }
 963   5      */
 964   5                  if ((ano_out==16)||(ano_out==20)||(ano_out==24)||(ano_out==28)||(ano_out==32)||(ano_out==36))
 965   5                  {
C51 COMPILER V9.59.0.0   CLOCK                                                             07/27/2021 14:31:09 PAGE 17  

 966   6                    bisiesto=1;
 967   6                  }   
 968   5      
 969   5      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 970   5                  if (bisiesto==1)
 971   5                  {
 972   6                    if (dia_out>29)
 973   6                    {
 974   7                      dia_out=dia_out-29;
 975   7                      mes_out=mes_out+1;
 976   7                      ano_out=ano_out;            
 977   7                    }
 978   6                    else
 979   6                    {
 980   7                      dia_out=dia_out;
 981   7                      mes_out=mes_out;
 982   7                      ano_out=ano_out;
 983   7                    }
 984   6                  }
 985   5                  else
 986   5                  {
 987   6                    if (dia_out>28)
 988   6                    {
 989   7                      dia_out=dia_out-28;
 990   7                      mes_out=mes_out+1;
 991   7                      ano_out=ano_out;                          
 992   7                    }
 993   6                  }
 994   5        //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 995   5                }
 996   4        
 997   4              }
 998   3          }
 999   2      
1000   2      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
1001   2        *(buffer+0x0b)=ano_out;
1002   2        *(buffer+0x0c)=mes_out;
1003   2        *(buffer+0x0d)=dia_out;
1004   2        *(buffer+0x0e)=hora_out;
1005   2        *(buffer+0x0f)=min_out;   
1006   2      //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
1007   2        }
1008   1        
1009   1      
1010   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4624    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      61
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
