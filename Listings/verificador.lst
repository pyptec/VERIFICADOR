C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include "verificador.h"
   5          #include <reg51.h>
   6          
   7          
   8          /*funciones prototipo externas */
   9          
  10          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  11          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_txt_Tibbo(unsigned char * str);
  14          extern unsigned char  ValidaSensoresPaso(void);
  15          extern void send_portERR(unsigned char cod_err);
  16          extern void Debug_chr_Tibbo(unsigned char Dat);
  17          extern void Debug_HexDec(unsigned char xfc);
  18          extern char check_fechaOut(char *buffer);
  19          extern unsigned char Dir_board();
  20          extern void PantallaLCD(unsigned char cod_msg);
  21          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  23          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  24          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  25          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  26          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          
  29          extern void Inicializa(unsigned char TipoMovimiento);
  30          extern void Check_Status(unsigned char Detalle);
  31          extern void Aut_Card_check_Status(void);
  32          extern void Mov_Card(unsigned char Posicion);
  33          extern void SecuenciaExpedidor(void);
  34          extern void Card_Insercion(char Tipo);
  35          extern void Dwload_EEprom (void);
  36          extern void LoadVerify_EEprom(void);
  37          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  38          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);
  39          extern int sprintf  (char *, const char *, ...);
  40          extern void Debug_Dividir_texto();
  41          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  42          extern void Delay_1ms(unsigned int cnt);
  43          extern void Delay_10ms(unsigned int cnt);
  44          extern unsigned char  ValidaSensores_Out(void);
  45          extern char  *strcpy  (char *s1, const char *s2);
  46          extern char lee_clk (unsigned char dir_clk);
  47          extern char check_fechaOut_2(unsigned char *buffer); 
  48          extern void Unique_Identifier_UID(void);
  49          extern void Power_off(void);
  50          extern void  send_port(unsigned char *buffer_port, unsigned char length_char);
  51          
  52          /*funcion prototipo programacion*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 2   

  53          extern unsigned char *Addr_Horarios();
  54          
  55          sbit lock = P1^7;           //Relevo  
  56          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  57          sbit led_err_imp = P0^2;      //Error 
  58          sbit busy = P3^3;           /*bussy de Entrada Interrupcion del Procesador principal      */
  59          sbit ready = P3^2;          //Salida. solicitud envio Datos   
  60          /*variables externas*/
  61          extern bit aSk;
  62          extern unsigned char g_cEstadoComSoft;
  63          extern unsigned char ValTimeOutCom;
  64          extern unsigned char g_cEstadoComSeqMF;
  65          extern unsigned char g_cContByteRx;
  66          extern unsigned char xdata Buffer_Rta_Lintech[];
  67          extern idata unsigned char rbuf [];
  68          extern int ID_CLIENTE;
  69          extern int COD_PARK;
  70          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  71          extern unsigned char Timer_wait;
  72          extern unsigned int  SIN_COBRO;
  73          extern unsigned char error_rx;
  74          unsigned char buffer_S_B[17];
  75          extern idata unsigned char placa[];
  76          
  77          /*externo bit*/
  78          
  79          extern bit buffer_ready;
  80          extern bit prto_ready;
  81          extern unsigned char USE_LPR;
  82          
  83          /*----------------------------------------------------------------------------
  84          Definiciones de sequencias de verificador y expedidor
  85          ------------------------------------------------------------------------------*/
  86          
  87          #define SEQ_INICIO            0X00  
  88          #define SEQ_CARD_INSERCION    0X01
  89          #define SEQ_CHECK_STATUS      0X02
  90          #define SEQ_RTA_CARD_POS      0x03
  91          #define SEQ_RTA_CAPTURE       0X04
  92          #define SEQ_RTA_CAPTURE_RPTA  0x05
  93          #define SEQ_REQUEST           0x06
  94          #define SEQ_MF_LINTECH        0x07
  95          #define SEQ_RD_S1B1           0x08
  96          #define SEQ_RD_S1B1_RPTA      0x09
  97          #define SEQ_RD_S1B2           0x0a
  98          #define SEQ_RD_S1B2_RPTA      0x0b
  99          #define SEQ_RD_S1B0           0x0c
 100          #define SEQ_RD_S1B0_RPTA      0x0d
 101          #define SEQ_WR_S1B2           0x0e
 102          #define SEQ_WR_S1B2_RPTA      0x0f
 103          
 104          #define SEQ_WR_S2B0           0x10
 105          #define SEQ_WR_S2B0_RPTA      0X11
 106          #define SEQ_RD_S1B0_EJECT     0x12
 107          #define SEQ_RD_S1B0_EJECT_RPTA      0x13
 108          //#define SEQ_TIPO_TARJETAS 0X14
 109          #define SEQ_ROTACION      0X15
 110          #define SEQ_MENSUAL       0X16
 111          #define SEQ_LOAD_PASSWORD 0X17
 112          #define SEQ_UID           0X18
 113          #define SEQ_UID_RPTA        0x19
 114          #define SEQ_POWER_OFF     0X1a
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 3   

 115          #define SEQ_POWER_ON      0X1b
 116          #define SEQ_TIPO_CARD     0X1c
 117          
 118          #define SEQ_EXPULSAR_TARJ     0x20
 119          #define SEQ_EXPULSAR_CHECK    0x21
 120          #define SEQ_EXPULSAR          0x22
 121          #define SEQ_EXPULSAR_FROM     0x23
 122          
 123          
 124          /*----------------------------------------------------------------------------
 125           definiciones de lintech en la inicializacion de expedidor o verificador
 126          ------------------------------------------------------------------------------*/
 127          
 128          #define INICIA_LINTECH          0x30
 129          #define SEQ_CAPTURE_DATOS_INI   0x31
 130          #define GRABA_EEPROM            0x32
 131          #define SEQ_CAPTURA_OK_EEPROM   0X33
 132          #define FIN_OK                  0x00
 133          
 134          #define True                    0x01
 135          #define False                   0x00
 136          
 137          /*----------------------------------------------------------------------------
 138           definiciones de lintech en el comando Check_Status
 139          ------------------------------------------------------------------------------*/
 140          
 141          #define S_DETAIL        0x31
 142          #define S_NORMAL        0x30
 143          
 144          /*------------------------------------------------------------------------------
 145           definiciones de lintech en el comando Card_Insercion
 146          ------------------------------------------------------------------------------*/
 147          
 148          #define Habilita        0x30
 149          #define Inhabilita      0x31
 150          
 151          /*------------------------------------------------------------------------------
 152          Definicion de Lintech en el comando Inicializa
 153          ------------------------------------------------------------------------------*/
 154          
 155          #define TO_FRONT        '0'
 156          #define CAPTURE_BOX     '1'
 157          #define SIN_MOVIMIENTO  '3'
 158          
 159          /*------------------------------------------------------------------------------
 160          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 161          ------------------------------------------------------------------------------*/
 162          
 163          #define   MovPos_Front        '0'   
 164          #define   MovPos_IC           '1'
 165          #define   MovPos_RF           '2'
 166          #define   MovPos_Capture      '3'
 167          #define   MovPos_EjectFront   '9'
 168          
 169          /*------------------------------------------------------------------------------
 170          Definicion de la trama Lintech de las respuestas de los cmd
 171          ------------------------------------------------------------------------------*/
 172          
 173          #define Pos_TipoResp        4
 174          #define Pos_Length          3
 175          #define Pos_St0             7
 176          #define Pos_St1             8
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 4   

 177          #define Pos_St2             9
 178          #define Pos_IniDatMF        0x0a
 179          #define Card_type_H         0x0a
 180          #define Card_type_L         0x0b
 181          
 182          /*----------------------------------------------------------------------------
 183          definicion de recepcion serial 
 184          ------------------------------------------------------------------------------*/
 185          
 186          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 187          
 188          /*----------------------------------------------------------------------------
 189          tiempo de delay entre funciones
 190          ------------------------------------------------------------------------------*/
 191          
 192          #define   TIME_CARD         50    //50
 193          
 194          
 195          /*----------------------------------------------------------------------------
 196          definicion de datos de trama lintech
 197          ------------------------------------------------------------------------------*/
 198          
 199          #define   ETX               03
 200          #define   STX_LINTECH       0xf2
 201          
 202          /*----------------------------------------------------------------------------
 203          msj de lcd tarjeta y lcd serie SALIDA
 204          ------------------------------------------------------------------------------*/
 205          
 206          #define INGRESE                 85    //    0xDF
 207          #define SIN_INGRESO             86    //      0XE6
 208          #define SIN_PAGO                87    //0XE7
 209          #define EXCEDE_GRACIA           88    //0XE8
 210          #define MENSUAL_NO_PARK         89
 211          #define DIRIJASE_CAJA           90
 212          #define GRACIAS                 91    //0XFF
 213          #define ACERQUESE_CAJA          0XEB
 214          
 215          /*MENSAJES INFORMATIVOS*/
 216          
 217          #define ERROR_COD_PARK          170     //0XE5
 218          #define ERROR_LOOP              171         //0XE0
 219          #define TARJETA_INVALIDA        172     //0XE1
 220          #define TARJETA_SIN_FORMATO     173     //0xDF
 221          
 222          /*MENSAJES PRINCIPAL ACTIVA RELES*/
 223          
 224          #define AUDIO_ENTRADA     0XA0
 225          #define AUDIO_CAJA        0XA1
 226          #define AUDIO_GRACIAS     0XA2
 227          /*----------------------------------------------------------------------------
 228          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 229          ------------------------------------------------------------------------------*/
 230          
 231          #define   ENVIADOS          0X0
 232          #define   RESPUESTA         0X01
 233          /*----------------------------------------------------------------------------
 234          definiciones para, funcion horario. 0 esta inhabilitado 1 habilitado
 235          ------------------------------------------------------------------------------*/
 236          
 237          #define   HABILITA_ADDR     15
 238          #define   Segundo_Tiempo    16
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 5   

 239          /*
 240          definicion  de daos del reloj
 241                    */
 242          
 243          #define RDIA            0x87
 244          #define RMES            0x89
 245          #define RANO            0x8D
 246          #define RDIA_SEMANA     0x8B
 247          #define RHORA           0x85
 248          #define RMIN            0x83
 249          #define Sabado          7
 250          #define Domingo         1
 251          
 252          /*----------------------------------------------------------------------------
 253          posicion de  MF  bloque 1 sector 1
 254          (0) tipo de tarjeta 
 255          (01) el id del cliente
 256          (03)codigo del parqueadero  
 257          ------------------------------------------------------------------------------*/
 258          #define   MF_TIPO_TARJETA   0X00
 259          #define   MF_ID_CLIENTE     0x01
 260          #define   MF_COD_PARK       0x03
 261          
 262          /*----------------------------------------------------------------------------
 263          posicion de  MF bloque 2 sector 1
 264          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 265          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 266          MF_LSB_SDCT=0 SIN DESCUENTO
 267          MF_LSB_FECHA_OUT=1 FIJA LA FECHA DE SALIDA EN LA TARJETA
 268          MF_LSB_POR_CNTJ=2   DESCUENTO POR PORCENTAJE
 269          MF_LSB_POR_DNR=3    DESCUENTO POR DINERO
 270          ------------------------------------------------------------------------------*/
 271          
 272          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 273          
 274          
 275          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 276                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o 
 277                                                                                                                                */
 278          #define   MF_LSB            0x06        /*codigo de descuento que programa el checpoint o el software */
 279          
 280          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 281          
 282          #define   MF_IN_PAGO        0x09            /*xx11xxxx los dos bits en (1) son la parte alta del tiempo de descuento*
             -/
 283          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 284          
 285          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 286          
 287          #define   MF_MENSUAL_ANO      0X05
 288          #define   MF_MENSUAL_MES      0X06
 289          #define   MF_MENSUAL_DIA      0X07
 290          #define   MF_UID_0      0X04
 291          #define   MF_UID_1      0X05
 292          #define   MF_UID_2      0X06
 293          #define   MF_UID_3      0X07
 294          
 295          #define   MF_EXPIRA_ANO     0X08
 296          #define   MF_EXPIRA_MES     0X09
 297          #define   MF_EXPIRA_DIA     0X0A
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 6   

 298          
 299          /*----------------------------------------------------------------------------
 300          define posiciones de memoria EEPROM
 301          ------------------------------------------------------------------------------*/
 302          #define EE_DCTO_PASA_CAJA     0X000F
 303          #define EE_CPRCN_ACTIVA       0x000C
 304          
 305          
 306          enum Hora_Minutos_addr{
 307            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 308            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 309          };
 310          /*----------------------------------------------------------------------------
 311          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 312          (0) si el dato es cero esta inactiva
 313          (1) activa o ROTACION
 314          (2) mensualidad
 315          ------------------------------------------------------------------------------*/
 316          enum Tipos_MF_TIPO_TARJETA{
 317            INACTIVA,         
 318            ROTACION,           
 319            MENSUALIDAD,
 320            PREPAGO,
 321            CORTESIA,
 322            LOCATARIO,
 323            TARJETA_PERDIDA = 0X10,
 324            INHABILITADA = 0X11
 325          };
 326          
 327          enum expedidor {
 328           fecha_Int_Ano,
 329           fecha_Int_Mes, 
 330           fecha_Int_Dia, 
 331           fecha_Int_Hora,
 332           fecha_Int_Min,   
 333           Tipo_Tarjeta,
 334           Apb,
 335           Horario,
 336           Pico_Placa,
 337           Type_Vehiculo,
 338           Uid_0,
 339           Uid_1,
 340           Uid_2,
 341           Uid_3,
 342           Expira_ano,
 343           Expira_mes,
 344           Expira_dia
 345           
 346          };
 347          /*comandos pto paralelo*/
 348          enum CMD_Trama_Pto_Paralelo{
 349            STX=02,
 350            CMD_PTO_PARALELO_EXPEDIDOR='a',
 351          //  ETX= 03,
 352            NULL=0,
 353            CMD_MONITOR_EXPEDIDOR='E',
 354            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 355          };
 356          enum Tipos_Vehiculos{
 357              AUTOMOVIL,          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 7   

 358              MOTO,
 359              BICICLETA
 360          };
 361          /*----------------------------------------------------------------------------
 362          Definicion de varaibles globales del objeto
 363          ------------------------------------------------------------------------------*/
 364          
 365          static unsigned char Estado=INICIA_LINTECH;
 366          
 367          
 368          
 369          /*------------------------------------------------------------------------------
 370          funcion que valida la trama del verificador o transporte lintech
 371          (0) significa que la trama es valida y sigue en el proceso
 372          (1) falla en la respuesta por pto serie o trama invalida
 373          (2) no ha recibido la trama del verificador o transporte
 374          (3) ERROR DE TRAMA CMD (N)
 375          ------------------------------------------------------------------------------*/
 376          
 377          char Trama_Validacion_P_N()
 378          {
 379   1        char Trama_Validacion_P_N=2;                                                    /*no ha llegado inf al pto serie*/
 380   1        
 381   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 382   1            {
 383   2              if (buffer_ready==1)
 384   2              {
 385   3                buffer_ready=0;
 386   3                  
 387   3              
 388   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 389   3                {
 390   4                          
 391   4                  Trama_Validacion_P_N=0;                                                 /*trama ok*/
 392   4                    
 393   4                }
 394   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 395   3                {
 396   4                  
 397   4                  Trama_Validacion_P_N=3;                                                 /*error de trama*/
 398   4                  
 399   4                }
 400   3                else
 401   3                {
 402   4                  //Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocid
             -a*/
 403   4                  Trama_Validacion_P_N=3;   
 404   4                  
 405   4                }
 406   3              }
 407   2              else
 408   2              {
 409   3                          
 410   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 411   3                                                  
 412   3              }
 413   2      
 414   2            }
 415   1            
 416   1        return Trama_Validacion_P_N;
 417   1      }
 418          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 8   

 419          /*------------------------------------------------------------------------------
 420          funcion de error de envios pto serie
 421          
 422          variable en uart error_rx=cuenta los numeros de error pto serie y reset de transporte 
 423          se limpia cuando llega la respuesta del transporte
 424          
 425          cont_error_rx= cuenta el tiempo de ASK si completa 5 tiempos borra ek ask 
 426          
 427          error_rx_pto=0 nos da mas tiempo para esperar la trama
 428          
 429          error_rx_pto=1 reenvia la trama al transporte
 430          
 431          aSk= significa que llego al pto serie el 06 y el transporte esta ejecutando y no ha contestado necesita ti
             -empo
 432          
 433          ------------------------------------------------------------------------------*/
 434          unsigned char error_rx_pto(void)
 435          {
 436   1      static unsigned cont_error_rx=0;
 437   1      unsigned char error_rx_pto=0;
 438   1      
 439   1          
 440   1                
 441   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 442   1            Debug_chr_Tibbo (error_rx); 
 443   1            Debug_chr_Tibbo (cont_error_rx);
 444   1            Debug_chr_Tibbo (error_rx_pto);
 445   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 446   1                if (aSk==0)
 447   1            
 448   1            { 
 449   2                error_rx++;
 450   2              if(error_rx>=10)
 451   2              {                                                                                   /*no contesta debe reset el transporte*/
 452   3                Atascado=1;                                                                       /*off el rele de reset del verificador*/    
 453   3                Delay_10ms(110);
 454   3                error_rx=0;
 455   3                cont_error_rx=0;
 456   3                error_rx_pto=0;
 457   3                Atascado=0; 
 458   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 459   3                ValTimeOutCom=TIME_CARD;
 460   3              }
 461   2              else
 462   2              {
 463   3                error_rx_pto=1;                                                                 /*reenvia el cmd y espera la respuesta*/
 464   3                ValTimeOutCom=TIME_CARD;
 465   3              }
 466   2            }
 467   1            else
 468   1            {
 469   2                cont_error_rx++;
 470   2              if(cont_error_rx>=3)
 471   2              {
 472   3                error_rx=0;                                     /*paso tiempo de espera y no contesta limpio los reg y reenvio la trama
             -*/
 473   3                cont_error_rx=0;
 474   3                error_rx_pto=1;
 475   3                aSk=0;
 476   3                ValTimeOutCom=TIME_CARD;
 477   3              }
 478   2              else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 9   

 479   2              {
 480   3                error_rx=0;                                   /*damos tiempo de espera de la trama del transporte*/
 481   3                error_rx_pto=0;
 482   3                ValTimeOutCom=TIME_CARD;
 483   3              }
 484   2            }
 485   1              return (error_rx_pto);
 486   1      }
 487          /*------------------------------------------------------------------------------
 488          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 489          
 490          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 491          ------------------------------------------------------------------------------*/
 492          
 493          unsigned char  Secuencia_inicio_expedidor(void)
 494          {
 495   1        char temp;
 496   1        
 497   1        
 498   1        switch (Estado)
 499   1        {
 500   2          case INICIA_LINTECH:
 501   2      
 502   2              Atascado=0; 
 503   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 504   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 505   2              
 506   2            
 507   2            return (Estado);
 508   2          break;
 509   2      
 510   2      
 511   2      /*------------------------------------------------------------------------------
 512   2      Envia la primera trama de inicializacion del transporte sin movimiento
 513   2            (0) LA RESPUESTA ES OK
 514   2            (1) NO RESPONDE EL PTO SERIE
 515   2            (2) NO RECIBIDO LA TRAMA 
 516   2            (3) ERROR DE TRAMA CMD (N)
 517   2      ------------------------------------------------------------------------------*/
 518   2            
 519   2          case SEQ_CAPTURE_DATOS_INI:
 520   2      
 521   2            if((temp=Trama_Validacion_P_N())!=0)
 522   2          {
 523   3            if(temp==2)
 524   3            {
 525   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 526   4            } 
 527   3            else if (temp==3)
 528   3            {
 529   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 530   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 531   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 532   4            }
 533   3            else
 534   3            {
 535   4              
 536   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 537   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 538   4            }
 539   3          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 10  

 540   2          else
 541   2          {
 542   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 543   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 544   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 545   3          }     
 546   2          return (Estado);
 547   2          break;
 548   2            
 549   2      /*------------------------------------------------------------------------------
 550   2      Envia el cmd de grabar claves a la eeprom del transporte 
 551   2      ------------------------------------------------------------------------------*/
 552   2            
 553   2            case GRABA_EEPROM:
 554   2              
 555   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 556   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 557   2            
 558   2            
 559   2      
 560   2            return (Estado);
 561   2              break;
 562   2        
 563   2      /*------------------------------------------------------------------------------
 564   2      se analiza la respuesta 
 565   2            (0) LA RESPUESTA ES OK
 566   2            (1) NO RESPONDE EL PTO SERIE
 567   2            (2) NO RECIBIDO LA TRAMA 
 568   2            (3) ERROR DE TRAMA CMD (N)
 569   2      ------------------------------------------------------------------------------*/
 570   2            
 571   2          case SEQ_CAPTURA_OK_EEPROM:
 572   2          
 573   2          if((temp=Trama_Validacion_P_N())!=0)
 574   2          {
 575   3            if(temp==2)
 576   3            {
 577   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 578   4            }
 579   3            else if (temp==3)
 580   3            {
 581   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 582   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 583   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 584   4            }     
 585   3            else
 586   3            {
 587   4              
 588   4              
 589   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 590   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 591   4            }       
 592   3          }
 593   2          else
 594   2          {
 595   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 596   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 597   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 598   3          }     
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 11  

 599   2      
 600   2          return (Estado);
 601   2          break;
 602   2      
 603   2      /*------------------------------------------------------------------------------
 604   2      Fin de la secuencia de comandos con exito 
 605   2      ------------------------------------------------------------------------------*/    
 606   2            
 607   2              case FIN_OK:
 608   2      
 609   2              return (Estado);
 610   2          break;
 611   2            
 612   2                
 613   2              default:
 614   2              return Estado=INICIA_LINTECH; 
 615   2              break;
 616   2        }
 617   1      }
 618          
 619          /*------------------------------------------------------------------------------
 620          Prosedimiento  q hace paso a paso la secuencia de la MF
 621          contador= numero de ciclos q pasa para mostrar el mensaje de loop solo se muestra el msj cuando contador=0
 622          temp= atributo para uso general
 623          Tiempo= trae el dato de mf tiempo de descuento maximo 999
 624          Estado_Tiempo = arreglo del tiempo a ascii
 625          error_rx= no llega la respuesta en el tiempo solicitado y espera otro tiempo maximo 3
 626          cont_error_rx= envio la trama otra vez solo una vez
 627          ------------------------------------------------------------------------------*/
 628          unsigned char Horarios(unsigned char Horario)
 629          {
 630   1        unsigned char Estado_Horario;
 631   1        
 632   1        unsigned char Addr_horarios [11];
 633   1        unsigned char dia_semana,EE_dia_semana;
 634   1        unsigned int addr;
 635   1        if (Horario != False )
 636   1        {
 637   2          /*se Lee la direccion del horario*/
 638   2          strcpy (Addr_horarios,(Addr_Horarios()));
 639   2          
 640   2          addr= Addr_horarios[Horario -1] ;
 641   2          
 642   2           /*leemos si esta habilitado*/
 643   2          
 644   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
 645   2          {
 646   3            /*miramos si el dia de la semana esta habilitado*/
 647   3            dia_semana = lee_clk(RDIA_SEMANA);
 648   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
 649   3            Debug_chr_Tibbo(dia_semana);
 650   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 651   3            
 652   3          
 653   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
 654   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
 655   3            Debug_chr_Tibbo(EE_dia_semana);
 656   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 657   3          
 658   3            if ( EE_dia_semana == dia_semana)
 659   3            {
 660   4              /*miramos si esta en el rango del horario*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 12  

 661   4              Estado_Horario = Bloque_Horario(addr);
 662   4            }
 663   3            else
 664   3            {
 665   4      
 666   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
 667   4              Estado_Horario= False;
 668   4            }
 669   3          }
 670   2          else 
 671   2          {
 672   3            
 673   3            Estado_Horario= False;
 674   3          //  PantallaLCD(HORARIO_NO_PROG);
 675   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
 676   3            
 677   3          }
 678   2          
 679   2        }
 680   1        else
 681   1        {
 682   2          Estado_Horario = True;
 683   2        
 684   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
 685   2        }
 686   1        return Estado_Horario;
 687   1      }
 688          unsigned int Hora_Maxima(unsigned int addr)
 689          {
 690   1        unsigned char Hora_High,  Minuto_High;
 691   1        unsigned char HoraIni , MinutoIni; 
 692   1        unsigned int  Hora_Prog;
 693   1        
 694   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
 695   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
 696   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
 697   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
 698   1         Debug_chr_Tibbo(HoraIni);
 699   1         Debug_chr_Tibbo(MinutoIni);
 700   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
 701   1        
 702   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
 703   1      }
 704          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
 705          {
 706   1        unsigned char Estado_Horario; 
 707   1        
 708   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
 709   1        {
 710   2          
 711   2          /*hasta la hora que puede ingresar el vehiculo */
 712   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
 713   2          Hora_Prog = Hora_Maxima(addr+4);
 714   2      
 715   2        
 716   2          if( HoraNow <= Hora_Prog)
 717   2          {
 718   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 719   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 720   3            Estado_Horario = True;
 721   3          }
 722   2          else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 13  

 723   2          {
 724   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 725   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
 726   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 727   3            Estado_Horario = False;
 728   3          }
 729   2          
 730   2        }
 731   1        else
 732   1        {
 733   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 734   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
 735   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
 736   2              Estado_Horario = False;
 737   2            
 738   2        }
 739   1        return Estado_Horario;
 740   1      }
 741          
 742          unsigned Bloque_Horario(unsigned int addr)
 743          {
 744   1        unsigned char Estado_Horario; 
 745   1        unsigned int HoraNow, Hora_Prog;
 746   1        
 747   1        /*la hora del momento de entrada del vehiculo*/
 748   1        
 749   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 750   1        Debug_chr_Tibbo(lee_clk(RHORA));
 751   1        Debug_chr_Tibbo(lee_clk(RMIN));
 752   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
 753   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 754   1        
 755   1        /* desde la hora en que puede ingresar vehiculo */
 756   1        
 757   1        
 758   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
 759   1        Hora_Prog = Hora_Maxima(addr);
 760   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
 761   1        if(Estado_Horario == False )
 762   1        {
 763   2          
 764   2            
 765   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
 766   2            {
 767   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
 768   3              Hora_Prog = Hora_Maxima(addr+10);
 769   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
 770   3            }
 771   2            else
 772   2            {
 773   3      //        send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 774   3        //      PantallaLCD(MENSUAL_FUERA_HORARIO);
 775   3              Estado_Horario = False;
 776   3            }
 777   2        }
 778   1      
 779   1      return Estado_Horario;
 780   1      }
 781          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
 782          {
 783   1        unsigned char temp;
 784   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 14  

 785   1        
 786   1        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA V
             -ERIFICA*/
 787   1                                      
 788   1            
 789   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 790   1            {
 791   2              
 792   2                for (temp=0; temp<16; temp++)
 793   2                {
 794   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
 795   3                }
 796   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);                               /*imprimo la trama recibida*/ 
 797   2                if (((buffer_S_B[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S_B[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE==0)&
             -&(COD_PARK==0)))    
 798   2                {
 799   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
 800   3                  Debug_HexDec(buffer_S_B[MF_ID_CLIENTE]);
 801   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 802   3                  
 803   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
 804   3                  Debug_HexDec(buffer_S_B[MF_COD_PARK]);
 805   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 806   3                  
 807   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
 808   3                  Debug_chr_Tibbo(buffer_S_B [MF_TIPO_TARJETA]);
 809   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 810   3                  
 811   3                  
 812   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S_B [MF_TIPO_TARJETA];
 813   3                
 814   3                  /*fecha de vencimiento de mensual o prepago*/
 815   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S_B [MF_EXPIRA_ANO];
 816   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S_B [MF_EXPIRA_MES];
 817   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S_B [MF_EXPIRA_DIA];
 818   3                                                                                    
 819   3                    Estado_expedidor=SEQ_RD_S1B2;
 820   3                
 821   3                }
 822   2                else
 823   2                {
 824   3                  send_portERR(0XE5);
 825   3                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
 826   3                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* codigo de parqueo erro expulso la tar
             -jeta */    
 827   3                }
 828   2            }
 829   1            else
 830   1            {
 831   2              send_portERR(0XDF);
 832   2              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
 833   2              Estado_expedidor=SEQ_EXPULSAR_TARJ;
 834   2            }
 835   1            return Estado_expedidor;
 836   1      }     
 837          
 838          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
 839          {
 840   1        unsigned char temp;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 15  

 841   1        unsigned char Estado_expedidor;
 842   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 843   1           {
 844   2            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA
             - VERIFICA*/
 845   2                            
 846   2            for (temp=0; temp<16; temp++)
 847   2            {
 848   3              buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de MF 
             -en un arreglo*/
 849   3            }
 850   2            DebugBufferMF(buffer_S_B,16,RESPUESTA); 
 851   2            /*fecha entrada*/
 852   2      
 853   2            *(Atributos_Expedidor + fecha_Int_Ano) =    buffer_S_B [MF_FECHA_INT] ;
 854   2            *(Atributos_Expedidor + fecha_Int_Mes) =    buffer_S_B [MF_FECHA_INT+1] ;
 855   2            *(Atributos_Expedidor + fecha_Int_Dia) =    buffer_S_B [MF_FECHA_INT+2] ;
 856   2            *(Atributos_Expedidor + fecha_Int_Hora)=    buffer_S_B [MF_FECHA_INT+3] ;
 857   2            *(Atributos_Expedidor + fecha_Int_Min) =    buffer_S_B [MF_FECHA_INT+4] ;
 858   2            /*horario*/
 859   2            Debug_txt_Tibbo((unsigned char *) "HORARIO:");
 860   2            Debug_chr_Tibbo((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
 861   2            *(Atributos_Expedidor + Horario)= ((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
 862   2              Debug_txt_Tibbo((unsigned char *) "\r\n");
 863   2            /*pico y placa*/
 864   2            *(Atributos_Expedidor + Pico_Placa)= ((buffer_S_B [MF_IN_PAGO] & 0XF0) >> 4);     
 865   2            /*APB*/
 866   2            *(Atributos_Expedidor + Apb)=   buffer_S_B [MF_APB] ;
 867   2            /*tipo de tarjeta*/
 868   2            *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S_B [MF_TIPO_VEHICULO]& 0x0f;
 869   2          //  Estado_expedidor=SEQ_TIPO_TARJETAS;
 870   2             /*------------------------------------------------------------------------------ 
 871   2            APB
 872   2            ------------------------------------------------------------------------------*/
 873   2              //if (*(Atributos_Expedidor + Tipo_Tarjeta) == MENSUALIDAD)
 874   2              //{
 875   2              //  *(Atributos_Expedidor + Apb)= 3;
 876   2              //}
 877   2              if((*(Atributos_Expedidor + Apb) == 02)||(*(Atributos_Expedidor + Apb) == 0) )                              /*Pregunt
             -o por el antipasban si es 02 ya salio y no posee entrada*/
 878   2              {                                                                                                             /*00 inhabilitada la tarjeta*/
 879   3              Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n");
 880   3              send_portERR(0xA2);                                                             /*error audio*/ 
 881   3              send_portERR(0XE6);
 882   3              PantallaLCD(SIN_INGRESO);
 883   3              Estado_expedidor=SEQ_EXPULSAR_TARJ;
 884   3              
 885   3              }
 886   2              else
 887   2              {
 888   3              
 889   3             /*------------------------------------------------------------------------------ 
 890   3              tipo de tarjeta
 891   3              ------------------------------------------------------------------------------*/
 892   3      
 893   3              if  (*(Atributos_Expedidor + Tipo_Tarjeta) ==ROTACION)          
 894   3              {
 895   4                Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n");
 896   4                Estado_expedidor=SEQ_ROTACION;
 897   4                
 898   4              }
 899   3              else if (*(Atributos_Expedidor + Tipo_Tarjeta)== MENSUALIDAD) 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 16  

 900   3              {
 901   4                Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
 902   4                Estado_expedidor=SEQ_MENSUAL;
 903   4                
 904   4              }
 905   3              else
 906   3              {
 907   4                Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n");
 908   4                Estado_expedidor=SEQ_EXPULSAR_TARJ;
 909   4                
 910   4              }
 911   3             }
 912   2          }
 913   1        else
 914   1           {
 915   2             g_cEstadoComSeqMF=SEQ_RD_S1B2;
 916   2           }
 917   1           
 918   1           return Estado_expedidor;
 919   1        
 920   1      }
 921          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Atributos_Expedidor)
 922          {
 923   1        unsigned char temp;
 924   1        unsigned char Estado_expedidor;
 925   1        unsigned char buffer_S1_B0[17];
 926   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 927   1           {
 928   2        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n");                              /* trama OK CARGA numero de ticket
             -*/
 929   2                                          
 930   2            
 931   2        for (temp=0; temp<16; temp++)
 932   2            {
 933   3              
 934   3              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
 935   3              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
 936   3              {
 937   4                break;
 938   4              }
 939   3            }
 940   2            
 941   2            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
 942   2            Debug_txt_Tibbo(buffer_S1_B0);
 943   2            Debug_txt_Tibbo((unsigned char *) "\r\n");
 944   2            
 945   2            /*transmito pto paralelo*/  
 946   2            if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
 947   2            {
 948   3            Timer_wait=0;                                                                               /*activo la barrera*/
 949   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S_B,'s');
 950   3            }
 951   2            else
 952   2            {
 953   3            
 954   3            Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor);
 955   3            }
 956   2            if(USE_LPR)
 957   2            {
 958   3              /*envio datos a Monitor*/
 959   3              if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 17  

 960   3              {
 961   4              Cmd_LPR_Salida(buffer_S1_B0,buffer_S_B);  
 962   4              }
 963   3              else
 964   3              {
 965   4              Cmd_LPR_Salida(Atributos_Expedidor,buffer_S_B); 
 966   4              }
 967   3            }
 968   2            
 969   2            
 970   2            
 971   2            Estado_expedidor=SEQ_WR_S1B2;
 972   2            
 973   2          }else
 974   1           {
 975   2            Estado_expedidor= SEQ_RD_S1B0;
 976   2           }
 977   1           return Estado_expedidor;
 978   1      }
 979          
 980          void Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor)
 981          {
 982   1        static unsigned char buffer[28];
 983   1        //unsigned char j;
 984   1        /*la trama esta compuesta de
 985   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
 986   1      
 987   1        buffer[0]=STX;
 988   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
 989   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
 990   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
 991   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
 992   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
 993   1        
 994   1        //leo la fecha de entrada
 995   1        //Block_read_Clock_Hex(buffer+6);         
 996   1        
 997   1        buffer[6]=*(Atributos_Expedidor + fecha_Int_Ano)+0x030;             /*año de entrada*/
 998   1        buffer[7]=*(Atributos_Expedidor + fecha_Int_Mes)+0x030;         /*mes de entrada*/
 999   1        buffer[8]=*(Atributos_Expedidor + fecha_Int_Dia)+0x030;         /*dia de entrada*/
1000   1        buffer[9]=*(Atributos_Expedidor + fecha_Int_Hora)+0x030;          /*hora de entrada*/
1001   1        buffer[10]=*(Atributos_Expedidor + fecha_Int_Min)+0x030;          /*minutos de entrada*/
1002   1      
1003   1        /*placa*/
1004   1        if (rd_eeprom(0xa8,EE_CPRCN_ACTIVA)!=0)
1005   1        {   
1006   2          
1007   2            buffer[11]= placa[0];
1008   2            buffer[12]= placa[1];
1009   2            buffer[13]= placa[2];
1010   2            buffer[14]= placa[3];
1011   2            buffer[15]= placa[4];
1012   2            buffer[16]= placa[5];
1013   2      
1014   2        }
1015   1      
1016   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1017   1        {
1018   2          buffer[17]= 'C';
1019   2        }
1020   1        else
1021   1        {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 18  

1022   2          buffer[17]= 'M';
1023   2        }
1024   1        
1025   1        buffer[18]= ETX;
1026   1        buffer[19]= NULL;
1027   1        ready=0;
1028   1            while(busy==0);
1029   1          send_port(buffer,19);                         /*trama transmitida pto paralelo*/
1030   1          
1031   1            Debug_Dividir_texto();                                              /*division del texto */
1032   1            Debug_txt_Tibbo((unsigned char *) "Datos enviados pto paral=");       
1033   1            DebugBufferMF(buffer,19,0);   
1034   1            Debug_Dividir_texto();
1035   1      }
1036          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
1037          {
1038   1        unsigned char Estado_expedidor;
1039   1        unsigned char temp;
1040   1            if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
1041   1            {
1042   2              
1043   2                for (temp=0; temp<16; ++temp)
1044   2                {
1045   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
1046   3                 
1047   3                }
1048   2                
1049   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
1050   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);
1051   2                
1052   2        
1053   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
1054   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_0]));  
1055   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_1]));  
1056   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_2]));  
1057   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_3]));
1058   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1059   2                
1060   2              *(Atributos_Expedidor + Uid_0) = buffer_S_B [MF_UID_0];   
1061   2              *(Atributos_Expedidor + Uid_1) = buffer_S_B [MF_UID_1];     
1062   2              *(Atributos_Expedidor + Uid_2) = buffer_S_B [MF_UID_2];     
1063   2              *(Atributos_Expedidor + Uid_3) = buffer_S_B [MF_UID_3]; 
1064   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
1065   2            }   
1066   1            else
1067   1            {
1068   2              Estado_expedidor=SEQ_POWER_OFF;
1069   2            } 
1070   1            return Estado_expedidor;
1071   1      }
1072          void SecuenciaExpedidor(void)
1073          {
1074   1        unsigned char temp;
1075   1        unsigned int tiempo;
1076   1        unsigned char Estado_Tiempo[4];
1077   1        static unsigned char Atributos_Expedidor[18];
1078   1        static unsigned char buffer_S1_B0[17];
1079   1        unsigned char clock_temp[6];
1080   1        static unsigned char contador=0;
1081   1        unsigned char *atributos;
1082   1        switch (g_cEstadoComSeqMF)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 19  

1083   1        {
1084   2      //***********************************************************************************************
1085   2          
1086   2          case SEQ_INICIO:
1087   2      
1088   2            if (ValTimeOutCom==1)
1089   2            {
1090   3              
1091   3              Atascado=0;                                                                       /*activo el rele de reset del verificador*/   
1092   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
1093   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
1094   3              
1095   3            }
1096   2       
1097   2          break;
1098   2      
1099   2      /*------------------------------------------------------------------------------
1100   2      Analizo la trama de insercion por boca
1101   2            (0) LA RESPUESTA ES OK
1102   2            (1) NO RESPONDE EL PTO SERIE
1103   2            (2) NO RECIBIDO LA TRAMA 
1104   2            (3) ERROR DE TRAMA CMD (N)
1105   2      ------------------------------------------------------------------------------*/      
1106   2          
1107   2          case SEQ_CARD_INSERCION:  
1108   2            
1109   2          if((temp=Trama_Validacion_P_N())!=0)
1110   2          {
1111   3            if(temp==2)
1112   3            {
1113   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
1114   4            } 
1115   3            else if (temp==3)
1116   3            {
1117   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
1118   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1119   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1120   4            }     
1121   3            else
1122   3            {
1123   4              /*Dispensador No Responde PTO SERIE ...*/
1124   4          
1125   4              if(temp=error_rx_pto()==0)
1126   4              {
1127   5                g_cEstadoComSeqMF=SEQ_CARD_INSERCION;
1128   5              }
1129   4              else if(temp=error_rx_pto()==1)
1130   4              {
1131   5                g_cEstadoComSeqMF=SEQ_INICIO;
1132   5              }
1133   4                                  
1134   4            }       
1135   3          }
1136   2          else
1137   2          {
1138   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
1139   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1140   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 20  

1141   3          }     
1142   2            
1143   2          break;
1144   2            
1145   2      /*------------------------------------------------------------------------------
1146   2      chequeo el estado de los sensores 
1147   2      ------------------------------------------------------------------------------*/      
1148   2          
1149   2          case SEQ_CHECK_STATUS:  
1150   2                if (ValTimeOutCom==1)
1151   2            {       
1152   3              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
1153   3              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
1154   3            }
1155   2            break;      
1156   2              
1157   2      /*------------------------------------------------------------------------------
1158   2      Valido la informacion de los sensores
1159   2            (0) LA RESPUESTA ES OK
1160   2            (1) NO RESPONDE EL PTO SERIE
1161   2            (2) NO RECIBIDO LA TRAMA 
1162   2            (3) ERROR DE TRAMA CMD (N)
1163   2      ------------------------------------------------------------------------------*/    
1164   2      
1165   2          case SEQ_RTA_CARD_POS:
1166   2            
1167   2          if((temp=Trama_Validacion_P_N())!=0)
1168   2          {
1169   3            if(temp==2)
1170   3            {
1171   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
1172   4            } 
1173   3            else if (temp==3)
1174   3            {
1175   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n");                     /* trama no valida*/
1176   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
1177   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
1178   4            }     
1179   3            else
1180   3            {
1181   4              
1182   4              /*Dispensador No Responde PTO SERIE ...*/
1183   4          
1184   4              if(temp=error_rx_pto()==0)
1185   4              {
1186   5                g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;
1187   5              }
1188   4              else if(temp=error_rx_pto()==1)
1189   4              {
1190   5                g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
1191   5              }
1192   4            
1193   4            }
1194   3          }
1195   2          else
1196   2          {
1197   3            Debug_txt_Tibbo((unsigned char *) "CHECK STATUS OK\r\n");                                 /* trama valida Habilitado */
1198   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
1199   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 21  

             - el mecanismo*/
1200   3                  {
1201   4                    
1202   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n");       /* trama valida Habi
             -litado insercion por boca*/
1203   4                    ValTimeOutCom=TIME_CARD;
1204   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
1205   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1206   4                    {
1207   5                      if(contador==0)                                                                   /*contador si es cero envia el msj a la pantala*/
1208   5                      { 
1209   6                        contador++;
1210   6                        Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor 
             -activo*/
1211   6                        send_portERR(0xA0);                                                                 /*audio ingrese tarjeta con rele*/
1212   6                        PantallaLCD(INGRESE);                                                             /*msj por raspberry "ingrese su tarjeta"*/
1213   6                                          
1214   6                      } else
1215   5                      {
1216   6                        contador++;                                                                       /*espera 20 ciclos para poder enviar msj nueva men
             -te*/
1217   6                        if (contador>= 20)contador=0;
1218   6                      } 
1219   5                    }else contador=0;
1220   4                    
1221   4                    
1222   4                  }
1223   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
1224   3                  {
1225   4                    
1226   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                      /* trama valida Habilitado i
             -nsercion por boca*/
1227   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1228   4                    //g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
1229   4                                           
1230   4                  }
1231   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
1232   3                  {
1233   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n");             /* trama valida Habil
             -itado insercion por boca*/
1234   4                                
1235   4                    
1236   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1237   4                    {
1238   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor ac
             -tivo*/
1239   5                    //Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF5
             -0*/
1240   5                                                                                                        /*tarjeta presente prioridad  */
1241   5                    g_cEstadoComSeqMF=SEQ_TIPO_CARD;//SEQ_REQUEST;                                                      /*vamos al siguiente paso 
             -a con validar el cmd*/    
1242   5                    }
1243   4                    else
1244   4                    {
1245   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n");              /* no hay vehiculo en el lo
             -op*/
1246   5                      send_portERR(0XE0);                                                               /*envio msj al PRINCIPAL lcd tarjeta*/
1247   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
1248   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
1249   5                      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 22  

1250   5                    }
1251   4                                                                  
1252   4                  }
1253   3                                                                    
1254   3          }     
1255   2            
1256   2          break;
1257   2        
1258   2      
1259   2      /*------------------------------------------------------------------------------
1260   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
1261   2      (1 0)  es una tarjeta valida Mf50 
1262   2      las demas combinaciones son tomadas como no validas
1263   2            (0) LA RESPUESTA ES OK
1264   2            (1) NO RESPONDE EL PTO SERIE
1265   2            (2) NO RECIBIDO LA TRAMA 
1266   2            (3) ERROR DE TRAMA CMD (N)    
1267   2      ------------------------------------------------------------------------------*/  
1268   2      
1269   2        case SEQ_REQUEST:
1270   2          
1271   2        if((temp=Trama_Validacion_P_N())!=0)
1272   2          {
1273   3            if(temp==2)
1274   3            {
1275   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
1276   4            } 
1277   3              else if (temp==3)
1278   3            {
1279   4              
1280   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n");                       /* trama no valida*/
1281   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
1282   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
1283   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
1284   4            } 
1285   3            else
1286   3            {
1287   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n");      /* pto serie no res
             -ponde*/
1288   4              send_portERR(0XE1);                                                                       /*la tarjeta no es valida no la puede identif
             -icar*/
1289   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1290   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
1291   4            
1292   4            }       
1293   3          }
1294   2          else
1295   2          {
1296   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
1297   3                    {
1298   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
1299   4                        {
1300   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
1301   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
1302   5                          //LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tr
             -ansporte
1303   5                          g_cEstadoComSeqMF=SEQ_UID;  //SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
1304   5                          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 23  

1305   5                       }else
1306   4                        {
1307   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
1308   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
1309   5                        send_portERR(0xA2);                                                             /*error audio*/ 
1310   5                        send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
1311   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1312   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
1313   5                         
1314   5                        }
1315   4                   }
1316   3                    else 
1317   3                    {
1318   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
1319   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
1320   4                    send_portERR(0xA2);                                                             /*error audio*/ 
1321   4                    send_portERR(0xe1);                                                     //la tarjeta no es valida 
1322   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1323   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
1324   4                  
1325   4                    }
1326   3                                                                                                            /*respuesta ok inicia revisando sensores*/
1327   3          }     
1328   2                
1329   2            break;
1330   2      /*------------------------------------------------------------------------------
1331   2      Verifica la eeprom 
1332   2            (0) LA RESPUESTA ES OK
1333   2            (1) NO RESPONDE EL PTO SERIE
1334   2            (2) NO RECIBIDO LA TRAMA 
1335   2            (3) ERROR DE TRAMA CMD (N)
1336   2      ------------------------------------------------------------------------------*/  
1337   2        case SEQ_MF_LINTECH:
1338   2          
1339   2        if((temp=Trama_Validacion_P_N())!=0)
1340   2          {
1341   3            if(temp==2)
1342   3            {
1343   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1344   4            }
1345   3            else if (temp==3)
1346   3            {
1347   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1348   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1349   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1350   4            }       
1351   3            else
1352   3            { 
1353   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1354   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1355   4            }
1356   3          }
1357   2          else
1358   2          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 24  

1359   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n");                       /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1360   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1361   3                                                                                                      /*leo MF */
1362   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1363   3          }     
1364   2      
1365   2        
1366   2        break;
1367   2      /*------------------------------------------------------------------------------
1368   2      Leo la Mf en el sector 1  bloque 1
1369   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1370   2      ------------------------------------------------------------------------------*/    
1371   2      
1372   2        case SEQ_RD_S1B1:
1373   2          
1374   2          RD_MF(1,1);                                                                                 /*leo MF */
1375   2          g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA; 
1376   2        
1377   2        break;
1378   2      /*------------------------------------------------------------------------------
1379   2      Analiso lo leido en Mf en el sector 1  bloque 1
1380   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1381   2      ------------------------------------------------------------------------------*/      
1382   2        
1383   2        case SEQ_RD_S1B1_RPTA:
1384   2          
1385   2          if((temp=Trama_Validacion_P_N())!=0)
1386   2          {
1387   3            if(temp==2)
1388   3            {
1389   4            g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;                                                           /*no ha respondido*/
1390   4            }
1391   3            else if (temp==3)
1392   3            {
1393   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1394   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1395   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1396   4            }       
1397   3            else
1398   3            { 
1399   4              
1400   4                /*Dispensador No Responde PTO SERIE ...*/
1401   4          
1402   4              if(temp=error_rx_pto()==0)
1403   4              {
1404   5                g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;
1405   5              }
1406   4              else if(temp=error_rx_pto()==1)
1407   4              {
1408   5                g_cEstadoComSeqMF=SEQ_RD_S1B1;;
1409   5              }
1410   4                                                              /* respuesta incorrecta*/
1411   4            }
1412   3          }
1413   2          else
1414   2          {
1415   3            g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque1(Atributos_Expedidor);
1416   3          }     
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 25  

1417   2        break;
1418   2      /*------------------------------------------------------------------------------
1419   2      Leo la Mf en el  sector 1 bloque 2
1420   2        Se lee Fecha in, fecha out
1421   2      ------------------------------------------------------------------------------*/    
1422   2        case SEQ_RD_S1B2: 
1423   2        
1424   2        RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1425   2        g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1426   2        break;  
1427   2          
1428   2      /*------------------------------------------------------------------------------
1429   2      ANALIZO LO LEIDO  Mf en el  sector 1 bloque 2
1430   2        Se lee Fecha in, fecha out
1431   2      ------------------------------------------------------------------------------*/
1432   2        case SEQ_RD_S1B2_RPTA:
1433   2              
1434   2        if((temp=Trama_Validacion_P_N())!=0)
1435   2          {
1436   3            if(temp==2)
1437   3            {
1438   4            g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;                                                           /*no ha respondido*/
1439   4            }
1440   3            else if (temp==3)
1441   3            {
1442   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta falla en la escritura de la clave*/
1443   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1444   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1445   4            }       
1446   3            else
1447   3            { 
1448   4                /*Dispensador No Responde PTO SERIE ...*/
1449   4          
1450   4              if(temp=error_rx_pto()==0)
1451   4              {
1452   5                g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1453   5              }
1454   4              else if(temp=error_rx_pto()==1)
1455   4              {
1456   5                g_cEstadoComSeqMF=SEQ_RD_S1B2;
1457   5              }
1458   4                                                                  
1459   4            }
1460   3          }
1461   2          else
1462   2          {
1463   3           g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor);
1464   3          // if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1465   3           //{
1466   3              
1467   3        //    Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n");                              /* trama OK CARGA LA EEPROM Y 
             -LA VERIFICA*/
1468   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/  
1469   3          //  for (temp=0; temp<16; temp++)
1470   3          //  {
1471   3          //    buffer_S1_B2[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de
             - MF en un arreglo*/
1472   3          //  }
1473   3          //  DebugBufferMF(buffer_S1_B2,16,RESPUESTA); 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 26  

1474   3              /*------------------------------------------------------------------------------  
1475   3            APB
1476   3            ------------------------------------------------------------------------------*/
1477   3          
1478   3          //  if((buffer_S1_B2[MF_APB]==02)||(buffer_S1_B2[MF_APB]==0) )                              /*Pregunto por el antipasban
             - si es 02 ya salio y no posee entrada*/
1479   3          //  {                                                                                                             /*00 inhabilitada la tarjeta*/
1480   3          //  Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n");
1481   3          //  send_portERR(0xA2);                                                             /*error audio*/ 
1482   3          //  send_portERR(0XE6);
1483   3          //  PantallaLCD(SIN_INGRESO);
1484   3          //  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1485   3              
1486   3          //  }
1487   3          //  else
1488   3          //  {
1489   3              
1490   3             /*------------------------------------------------------------------------------ 
1491   3              tipo de tarjeta
1492   3              ------------------------------------------------------------------------------*/
1493   3          
1494   3            //  if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
1495   3            //  {
1496   3              //  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n");
1497   3              //  g_cEstadoComSeqMF=SEQ_ROTACION;
1498   3                
1499   3            //  }
1500   3            //  else if ((buffer_S1_B1[MF_TIPO_TARJETA]== MENSUALIDAD)) 
1501   3            //  {
1502   3            //    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1503   3            //    g_cEstadoComSeqMF=SEQ_MENSUAL;
1504   3                
1505   3            //  }
1506   3            //  else
1507   3            //  {
1508   3            //    Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n");
1509   3            //    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1510   3                
1511   3            //  }
1512   3          //  }
1513   3          //  break;
1514   3          // }
1515   3          // else
1516   3          //{
1517   3            //g_cEstadoComSeqMF=SEQ_RD_S1B2;
1518   3            
1519   3        //  }
1520   3        }
1521   2          break;
1522   2        case SEQ_ROTACION:
1523   2          
1524   2            
1525   2            /*------------------------------------------------------------------------------  
1526   2            sinc0bro  por  programacion
1527   2          ------------------------------------------------------------------------------*/  
1528   2            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1529   2            {
1530   3              if (SIN_COBRO==1)
1531   3              {
1532   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1533   4                                                                                                    
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 27  

1534   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
1535   4                break;
1536   4              }
1537   3              else if( SIN_COBRO ==2)
1538   3              {
1539   4                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1540   4                        
1541   4          
1542   4                if ((buffer_S_B[0]==clock_temp[0])&&(buffer_S_B[1]==clock_temp[1])&&(buffer_S_B[2]==clock_temp[2]))   
             -/*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1543   4                {
1544   5                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1545   5                                                                                                                            /* Leo el ticket */
1546   5                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1547   5                  break;
1548   5                }                                                                                         
1549   4                  else
1550   4                  {
1551   5                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n");                                             /*excede el timepo d
             -e gracia del dia */
1552   5                  send_portERR(0XE8);
1553   5                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1554   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1555   5                  break;              
1556   5                  }
1557   4                
1558   4                
1559   4              }
1560   3            }
1561   2      /*------------------------------------------------------------------------------
1562   2          validacion descuentos  se maneja en 2 posiciones de memoria del MF
1563   2            MF_LSB= tipo de descuento       
1564   2      ------------------------------------------------------------------------------*/      
1565   2            else if(buffer_S_B[MF_LSB]!=0)
1566   2            {
1567   3              
1568   3             if((rd_eeprom(0xa8,EE_DCTO_PASA_CAJA))!= 0)  
1569   3            {
1570   4              Debug_Dividir_texto();
1571   4              Debug_txt_Tibbo((unsigned char *) "CODIGO DE DCTO: ");                                                      /*codigo de descuento
             - es elnumero de descuento del cliente*/
1572   4              Debug_chr_Tibbo(buffer_S_B[MF_LSB]);
1573   4              Debug_txt_Tibbo((unsigned char *) "\r\n");  
1574   4              /*parte alta del tiempo libre*/
1575   4              temp=(buffer_S_B[MF_IN_PAGO]&0x70)>>4 ;                                                                   /*se lee la parte alta del ti
             -empo libre y se rotsa 4 bits a la derecha*/
1576   4              tiempo=temp;                                                                                                /*se carga en un entero*/
1577   4              tiempo=(tiempo <<8) | buffer_S_B[MF_DCTO] ;                                                               /*MF_DCTO= tiene la parte b
             -aja del tiempo libre, se une la parte alta con la baja */
1578   4                                                                                                                          /*creando un int del tiemo de dcto*/
1579   4              Debug_txt_Tibbo((unsigned char *) "TIEMPO DE DCTO: ");
1580   4              sprintf( Estado_Tiempo,"%u",tiempo);                                                                        /*se muestra el tiempo de desc
             -uento*/
1581   4              Debug_txt_Tibbo((unsigned char *)Estado_Tiempo);
1582   4              Debug_txt_Tibbo((unsigned char *) "\r\n");
1583   4              Debug_Dividir_texto();  
1584   4              
1585   4            /*tipo de descuento es el bit 8 de MF_IN_PAGO*/ 
1586   4            /*por fecha que es fijar fecha de salida*/
1587   4                if ((buffer_S_B[MF_IN_PAGO]&0x80)==0)                                                                   /*tipo de descuento por fecha 
             -de salida*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 28  

1588   4                {
1589   5                Debug_txt_Tibbo((unsigned char *) "DCTO FIJA FECHA DE OUT: ");                                            /**/
1590   5                analiza_tiempo(buffer_S_B,tiempo); 
1591   5              /*fijar fecha de salida*/
1592   5                }
1593   4                else
1594   4                {
1595   5                  if (tiempo== 0x64)                                                                                  /*tipo de dcto por porcentaje al 100 %*/
1596   5                  {
1597   6                    Debug_txt_Tibbo((unsigned char *) "DCTO PORCENTAJE 100% ");
1598   6                    Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1599   6                                                                                                                      /* Leo el ticket */
1600   6                    g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                    /**/                                              
1601   6                    break;              
1602   6                  }
1603   5                  else
1604   5                  {
1605   6                    Debug_txt_Tibbo((unsigned char *) "DCTO NO EL 100%: ");
1606   6                    send_portERR(ACERQUESE_CAJA); 
1607   6                    PantallaLCD(DIRIJASE_CAJA); 
1608   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                
1609   6                  }             
1610   5                }
1611   4            }
1612   3          }
1613   2        /*------------------------------------------------------------------------------  
1614   2            tiempo de gracia
1615   2          T_GRACIA=1 tiene tiempo de gracia 
1616   2          ------------------------------------------------------------------------------*/  
1617   2            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1618   2            {
1619   3              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1620   3              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1621   3              Debug_txt_Tibbo((unsigned char *) "\r\n");    
1622   3              analiza_tiempo(buffer_S_B,T_GRACIA);                                                // Simula Fecha Max de Salida.
1623   3            
1624   3            }
1625   2          /*------------------------------------------------------------------------------  
1626   2          comun para todos
1627   2          ------------------------------------------------------------------------------*/    
1628   2            temp=check_fechaOut(buffer_S_B+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1629   2              if(temp==1)
1630   2              {
1631   3                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n");
1632   3                  send_portERR(0xA2);                                                             /*error audio*/ 
1633   3                  send_portERR(0XE7);
1634   3                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
1635   3                                                                                    /**leo el ticket*/  
1636   3                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1637   3                              
1638   3              }
1639   2              else if (temp==2)
1640   2              {
1641   3                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1642   3                send_portERR(0xA2);                                                               /*error audio*/         
1643   3                send_portERR(0XE8);
1644   3                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1645   3                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1646   3              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 29  

1647   2              else
1648   2              {
1649   3                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1650   3                                                                                                  /* Leo el ticket */
1651   3                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1652   3              }
1653   2            
1654   2          
1655   2        
1656   2            
1657   2            
1658   2            
1659   2        break;
1660   2        case SEQ_MENSUAL:
1661   2          /*cheque la fecha de expiracion del mensual*/
1662   2        
1663   2        if (Horarios(Atributos_Expedidor [Horario]) == True)
1664   2        {
1665   3          atributos = &Atributos_Expedidor [Expira_ano];//;buffer_S1_B1[MF_EXPIRA_ANO];
1666   3          
1667   3          if ( check_fechaOut_2(atributos) == True )
1668   3            {
1669   4              /*valida el vehiculo en el loop y en la card*/
1670   4              
1671   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1672   4              
1673   4              //  Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1674   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1675   4              
1676   4            }
1677   3              else 
1678   3            {
1679   4              //send_portERR(PRMR_TARJETA_VENCIDA); 
1680   4                  
1681   4      //        PantallaLCD(TARJETA_VENCIDA);
1682   4              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1683   4              g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1684   4              
1685   4            }
1686   3        }
1687   2        else
1688   2        {
1689   3          
1690   3          g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1691   3        }
1692   2            break;
1693   2        case SEQ_RD_S1B0:
1694   2            
1695   2            RD_MF(1, 0);                                                                    /* Leo el ticket */
1696   2            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1697   2        break;
1698   2      /*------------------------------------------------------------------------------
1699   2      Leo la Mf en el  sector 1 bloque 0
1700   2          lee el ticket
1701   2      ------------------------------------------------------------------------------*/    
1702   2          
1703   2        case SEQ_RD_S1B0_RPTA:
1704   2        
1705   2        if((temp=Trama_Validacion_P_N())!=0)
1706   2          {
1707   3            if(temp==2)
1708   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 30  

1709   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;                                                           /*no ha respondido*/
1710   4            }
1711   3            else if (temp==3)
1712   3            {
1713   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1714   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1715   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1716   4            }       
1717   3            else
1718   3            { 
1719   4              /*Dispensador No Responde PTO SERIE ...*/
1720   4          
1721   4              if(temp=error_rx_pto()==0)
1722   4              {
1723   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1724   5              }
1725   4              else if(temp=error_rx_pto()==1)
1726   4              {
1727   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1728   5              }                                                       /* respuesta incorrecta*/
1729   4            }
1730   3          }
1731   2          else
1732   2          {
1733   3            g_cEstadoComSeqMF=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Atributos_Expedidor);
1734   3        
1735   3          }
1736   2        break;
1737   2      
1738   2            
1739   2      /*------------------------------------------------------------------------------
1740   2      envio a escribir en  la Mf en el  sector 1 bloque 2
1741   2          
1742   2      ------------------------------------------------------------------------------*/    
1743   2        case SEQ_WR_S1B2:
1744   2        
1745   2              
1746   2              WR_MF(1, 2,Atributos_Expedidor);//buffer_S_B+MF_TIPO_VEHICULO
1747   2              g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1748   2            
1749   2        break;
1750   2      /*------------------------------------------------------------------------------
1751   2      espero la respuesta de la escritura en  la Mf en el  sector 1 bloque 2
1752   2          
1753   2      ------------------------------------------------------------------------------*/  
1754   2        case SEQ_WR_S1B2_RPTA:
1755   2          if((temp=Trama_Validacion_P_N())!=0)
1756   2          {
1757   3            if(temp==2)
1758   3            {
1759   4            g_cEstadoComSeqMF= SEQ_WR_S1B2_RPTA;                                                            /*no ha respondido*/
1760   4            }
1761   3            else if (temp==3)
1762   3            {
1763   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1764   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1765   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1766   4            }       
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 31  

1767   3            else
1768   3            { 
1769   4              
1770   4                /*Dispensador No Responde PTO SERIE ...*/
1771   4          
1772   4              if(temp=error_rx_pto()==0)
1773   4              {
1774   5                g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1775   5              }
1776   4              else if(temp=error_rx_pto()==1)
1777   4              {
1778   5                g_cEstadoComSeqMF=SEQ_WR_S1B2;
1779   5              }         
1780   4              
1781   4              
1782   4            
1783   4            }
1784   3          }
1785   2          else
1786   2          {
1787   3          
1788   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1789   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1790   3            g_cEstadoComSeqMF=SEQ_WR_S2B0;  
1791   3          }
1792   2          break;
1793   2        case SEQ_WR_S2B0:
1794   2          WR_MF(2, 0,buffer_S_B+MF_TIPO_VEHICULO);//s1b2
1795   2        
1796   2          g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA; 
1797   2          break;
1798   2        
1799   2        
1800   2        case SEQ_WR_S2B0_RPTA:
1801   2      
1802   2        if((temp=Trama_Validacion_P_N())!=0)
1803   2          {
1804   3            if(temp==2)
1805   3            {
1806   4            g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;                                                           /*no ha respondido*/
1807   4            }
1808   3            else if (temp==3)
1809   3            {
1810   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n");                            /* trama no valida respuesta 
             -incorrecta el leer el bloque*/
1811   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1812   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1813   4            }       
1814   3            else
1815   3            { 
1816   4                  /*Dispensador No Responde PTO SERIE ...*/
1817   4          
1818   4              if(temp=error_rx_pto()==0)
1819   4              {
1820   5                g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;
1821   5              }
1822   4              else if(temp=error_rx_pto()==1)
1823   4              {
1824   5                g_cEstadoComSeqMF=SEQ_WR_S2B0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 32  

1825   5              }         
1826   4          
1827   4                  
1828   4            }
1829   3          }
1830   2          else
1831   2          {
1832   3          
1833   3            /*capturo la tarjeta*/
1834   3            lock=1;   
1835   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n");                             /* trama OK CARGA numero de tic
             -ket*/
1836   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1837   3            send_portERR(0xA1);                                                                         /*audio gracias*/ 
1838   3            send_portERR(0XFF);
1839   3            PantallaLCD(GRACIAS); 
1840   3        
1841   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n");                              /* pto serie no responde*/
1842   3            
1843   3          if (Atributos_Expedidor [ Tipo_Tarjeta]!= MENSUALIDAD)  
1844   3            {
1845   4                  
1846   4            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1847   4            }
1848   3            else
1849   3            {
1850   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1851   4            }
1852   3          }
1853   2          break;
1854   2          
1855   2          case SEQ_RTA_CAPTURE:
1856   2            
1857   2            Mov_Card(MovPos_Capture); 
1858   2            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;
1859   2            prto_ready=1;                                                       /*le da prioridad a la respuesta de la captura de tarjeta*/
1860   2            break;
1861   2      /*------------------------------------------------------------------------------
1862   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1863   2            (0) LA RESPUESTA ES OK
1864   2            (1) NO RESPONDE EL PTO SERIE
1865   2            (2) NO RECIBIDO LA TRAMA 
1866   2            (3) ERROR DE TRAMA CMD (N)
1867   2      ------------------------------------------------------------------------------*/  
1868   2      
1869   2        case SEQ_RTA_CAPTURE_RPTA:
1870   2          
1871   2          if((temp=Trama_Validacion_P_N())!=0)
1872   2          {
1873   3            if(temp==2)
1874   3            {
1875   4              
1876   4                if (ValidaSensores_Out()==1)
1877   4              {
1878   5                lock=0;
1879   5                Debug_txt_Tibbo((unsigned char *) "rele off\r\n");                          /* trama ok la tarjeta fue ejectada*/
1880   5              
1881   5              }
1882   4            
1883   4                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;     
1884   4              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 33  

1885   4              
1886   4            } 
1887   3              else if (temp==3)
1888   3            {
1889   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n");                   /* Tama incorrecta no ejecta l
             -a tarjeta*/
1890   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1891   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1892   4            } 
1893   3            else
1894   3            {
1895   4                    /*Dispensador No Responde PTO SERIE ...*/
1896   4            
1897   4            
1898   4          
1899   4              
1900   4                if(temp=error_rx_pto()==0)
1901   4                {
1902   5                  g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;   
1903   5                }
1904   4                else if(temp=error_rx_pto()==1)
1905   4                {
1906   5                  
1907   5                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1908   5                }         
1909   4          
1910   4              
1911   4            
1912   4            }       
1913   3          }
1914   2          else
1915   2          {
1916   3                    
1917   3            prto_ready=0;
1918   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1919   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1920   3            
1921   3            lock=0;
1922   3            ValTimeOutCom=3;    
1923   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                   //SEQ_INICIO;                                                     /*respuesta ok ini
             -cia revisando sensores*/
1924   3                                                          
1925   3          }     
1926   2            
1927   2      
1928   2          break;
1929   2          
1930   2      
1931   2      
1932   2      case SEQ_RD_S1B0_EJECT: 
1933   2          RD_MF(1, 0);                                                                      /**leo el ticket*/  
1934   2          g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA; 
1935   2        break;  
1936   2      /*------------------------------------------------------------------------------
1937   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1938   2      LA tarjeta no tiene pago    
1939   2        
1940   2      ------------------------------------------------------------------------------*/
1941   2        
1942   2        
1943   2        case SEQ_RD_S1B0_EJECT_RPTA:  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 34  

1944   2          
1945   2          if((temp=Trama_Validacion_P_N())!=0)
1946   2          {
1947   3            if(temp==2)
1948   3            {
1949   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;                                                           /*no ha respondido*/
1950   4            }
1951   3            else if (temp==3)
1952   3            {
1953   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1954   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1955   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1956   4            }       
1957   3            else
1958   3            { 
1959   4                  /*Dispensador No Responde PTO SERIE ...*/
1960   4          
1961   4              if(temp=error_rx_pto()==0)
1962   4              {
1963   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;
1964   5              }
1965   4              else if(temp=error_rx_pto()==1)
1966   4              {
1967   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;
1968   5              }         
1969   4                                                  /* respuesta incorrecta*/
1970   4            }
1971   3          }
1972   2          else
1973   2          {
1974   3            
1975   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n");                              /* trama OK CARGA numero d
             -e ticket*/
1976   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/    
1977   3            
1978   3        for (temp=0; temp<16; temp++)
1979   3            {
1980   4              
1981   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1982   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1983   4              {
1984   5                break;
1985   5              }
1986   4            }
1987   3            DebugBufferMF(buffer_S1_B0,16,RESPUESTA); 
1988   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S_B,'P');    
1989   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1990   3          } 
1991   2            break;
1992   2        case SEQ_UID:
1993   2          Unique_Identifier_UID();
1994   2        g_cEstadoComSeqMF = SEQ_UID_RPTA;
1995   2        break;
1996   2        case SEQ_UID_RPTA:
1997   2            if((temp=Trama_Validacion_P_N())!=0)
1998   2          {
1999   3            if(temp==2)
2000   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 35  

2001   4            g_cEstadoComSeqMF=SEQ_UID_RPTA;                                                       /*no ha respondido*/
2002   4            } 
2003   3            else if (temp==3)
2004   3            {
2005   4            Debug_txt_Tibbo((unsigned char *) "SEQ_UID_RPTA FALLO\r\n");                      /* trama no valida*/
2006   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2007   4            g_cEstadoComSeqMF=SEQ_UID;                                                          /* (3) Trama invalida cmd (N)*/ 
2008   4            }     
2009   3            else
2010   3            {
2011   4              
2012   4              /*Dispensador No Responde PTO SERIE ...*/
2013   4          
2014   4              if(temp=error_rx_pto()==0)
2015   4              {
2016   5                g_cEstadoComSeqMF=SEQ_UID_RPTA;
2017   5              }
2018   4              else if(temp=error_rx_pto()==1)
2019   4              {
2020   5                g_cEstadoComSeqMF=SEQ_UID;
2021   5              }
2022   4            
2023   4            }
2024   3          }
2025   2          else
2026   2          {
2027   3            g_cEstadoComSeqMF = Analiza_Uid_Card(Atributos_Expedidor );
2028   3          }
2029   2          break;
2030   2        case SEQ_LOAD_PASSWORD:
2031   2          LoadVerify_EEprom();
2032   2          g_cEstadoComSeqMF=SEQ_MF_LINTECH;   
2033   2          break;
2034   2        case SEQ_POWER_OFF:
2035   2          Power_off();
2036   2          g_cEstadoComSeqMF=SEQ_UID;
2037   2          break;
2038   2        case SEQ_POWER_ON:
2039   2          Power_off();
2040   2        g_cEstadoComSeqMF = SEQ_LOAD_PASSWORD;
2041   2          break;
2042   2        case SEQ_TIPO_CARD:
2043   2          Aut_Card_check_Status();
2044   2          g_cEstadoComSeqMF=SEQ_REQUEST;            
2045   2          break;
2046   2      /*------------------------------------------------------------------------------
2047   2      expulsa la tarjeta por que no pertenece a MF50
2048   2      ------------------------------------------------------------------------------*/    
2049   2        
2050   2        case SEQ_EXPULSAR_TARJ:
2051   2            Card_Insercion(Inhabilita); 
2052   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
2053   2        break;
2054   2        
2055   2        
2056   2        case SEQ_EXPULSAR_CHECK:
2057   2        if((temp=Trama_Validacion_P_N())!=0)
2058   2          {
2059   3            if(temp==2)
2060   3            {
2061   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
2062   4            } 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/02/2020 07:28:02 PAGE 36  

2063   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
2064   3          }
2065   2          else
2066   2          {
2067   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
2068   3          }   
2069   2          
2070   2          break;
2071   2          
2072   2        case SEQ_EXPULSAR:
2073   2          Mov_Card(MovPos_EjectFront);
2074   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
2075   2        
2076   2        case SEQ_EXPULSAR_FROM:                       
2077   2          if((temp=Trama_Validacion_P_N())!=0)
2078   2          {
2079   3            if(temp==2)
2080   3            {
2081   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
2082   4            } 
2083   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
2084   3          }
2085   2          else
2086   2          {
2087   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
2088   3          }   
2089   2          
2090   2        break;
2091   2        
2092   2      /*------------------------------------------------------------------------------
2093   2      expulsa la tarjeta por que no pertenece a MF50
2094   2      ------------------------------------------------------------------------------*/      
2095   2          
2096   2              default:
2097   2              g_cEstadoComSeqMF=SEQ_INICIO; 
2098   2              break;  
2099   2            
2100   2        } 
2101   1      }
2102          
2103          
2104            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5492    ----
   CONSTANT SIZE    =   1637    ----
   XDATA SIZE       =     84      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
