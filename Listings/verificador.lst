C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include "verificador.h"
   5          #include <reg51.h>
   6          
   7          
   8          /*funciones prototipo externas */
   9          
  10          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  11          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_txt_Tibbo(unsigned char * str);
  14          extern unsigned char  ValidaSensoresPaso(void);
  15          extern void send_portERR(unsigned char cod_err);
  16          extern void Debug_chr_Tibbo(unsigned char Dat);
  17          extern void Debug_HexDec(unsigned char xfc);
  18          extern char check_fechaOut(char *buffer);
  19          extern unsigned char Dir_board();
  20          extern void PantallaLCD(unsigned char cod_msg);
  21          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  23          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  24          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  25          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  26          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          
  29          extern void Inicializa(unsigned char TipoMovimiento);
  30          extern void Check_Status(unsigned char Detalle);
  31          extern void Aut_Card_check_Status(void);
  32          extern void Mov_Card(unsigned char Posicion);
  33          extern void SecuenciaExpedidor(void);
  34          extern void Card_Insercion(char Tipo);
  35          extern void Dwload_EEprom (void);
  36          extern void LoadVerify_EEprom(void);
  37          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  38          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);
  39          extern int sprintf  (char *, const char *, ...);
  40          extern void Debug_Dividir_texto();
  41          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  42          extern void Delay_1ms(unsigned int cnt);
  43          extern void Delay_10ms(unsigned int cnt);
  44          extern unsigned char  ValidaSensores_Out(void);
  45          
  46          sbit lock = P1^7;           //Relevo  
  47          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  48          sbit led_err_imp = P0^2;      //Error   
  49          /*variables externas*/
  50          extern bit aSk;
  51          extern unsigned char g_cEstadoComSoft;
  52          extern unsigned char ValTimeOutCom;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 2   

  53          extern unsigned char g_cEstadoComSeqMF;
  54          extern unsigned char g_cContByteRx;
  55          extern unsigned char xdata Buffer_Rta_Lintech[];
  56          extern idata unsigned char rbuf [];
  57          extern int ID_CLIENTE;
  58          extern int COD_PARK;
  59          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  60          extern unsigned char Timer_wait;
  61          extern unsigned int  SIN_COBRO;
  62          extern unsigned char error_rx;
  63          
  64          
  65          /*externo bit*/
  66          
  67          extern bit buffer_ready;
  68          extern bit prto_ready;
  69          extern unsigned char USE_LPR;
  70          
  71          /*----------------------------------------------------------------------------
  72          Definiciones de sequencias de verificador y expedidor
  73          ------------------------------------------------------------------------------*/
  74          
  75          #define SEQ_INICIO            0X00  
  76          #define SEQ_CARD_INSERCION    0X01
  77          #define SEQ_CHECK_STATUS      0X02
  78          #define SEQ_RTA_CARD_POS      0x03
  79          #define SEQ_RTA_CAPTURE       0X04
  80          #define SEQ_RTA_CAPTURE_RPTA  0x05
  81          #define SEQ_REQUEST           0x06
  82          #define SEQ_MF_LINTECH        0x07
  83          #define SEQ_RD_S1B1           0x08
  84          #define SEQ_RD_S1B1_RPTA      0x09
  85          #define SEQ_RD_S1B2           0x0a
  86          #define SEQ_RD_S1B2_RPTA      0x0b
  87          #define SEQ_RD_S1B0           0x0c
  88          #define SEQ_RD_S1B0_RPTA      0x0d
  89          #define SEQ_WR_S1B2           0x0e
  90          #define SEQ_WR_S1B2_RPTA      0x0f
  91          
  92          #define SEQ_WR_S2B0           0x10
  93          #define SEQ_WR_S2B0_RPTA      0X11
  94          #define SEQ_RD_S1B0_EJECT     0x12
  95          #define SEQ_RD_S1B0_EJECT_RPTA      0x13
  96          
  97          #define SEQ_EXPULSAR_TARJ     0x20
  98          #define SEQ_EXPULSAR_CHECK    0x21
  99          #define SEQ_EXPULSAR          0x22
 100          #define SEQ_EXPULSAR_FROM     0x23
 101          
 102          
 103          /*----------------------------------------------------------------------------
 104           definiciones de lintech en la inicializacion de expedidor o verificador
 105          ------------------------------------------------------------------------------*/
 106          
 107          #define INICIA_LINTECH          0x30
 108          #define SEQ_CAPTURE_DATOS_INI   0x31
 109          #define GRABA_EEPROM            0x32
 110          #define SEQ_CAPTURA_OK_EEPROM   0X33
 111          #define FIN_OK                  0x00
 112          
 113          /*----------------------------------------------------------------------------
 114           definiciones de lintech en el comando Check_Status
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 3   

 115          ------------------------------------------------------------------------------*/
 116          
 117          #define S_DETAIL        0x31
 118          #define S_NORMAL        0x30
 119          
 120          /*------------------------------------------------------------------------------
 121           definiciones de lintech en el comando Card_Insercion
 122          ------------------------------------------------------------------------------*/
 123          
 124          #define Habilita        0x30
 125          #define Inhabilita      0x31
 126          
 127          /*------------------------------------------------------------------------------
 128          Definicion de Lintech en el comando Inicializa
 129          ------------------------------------------------------------------------------*/
 130          
 131          #define TO_FRONT        '0'
 132          #define CAPTURE_BOX     '1'
 133          #define SIN_MOVIMIENTO  '3'
 134          
 135          /*------------------------------------------------------------------------------
 136          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 137          ------------------------------------------------------------------------------*/
 138          
 139          #define   MovPos_Front        '0'   
 140          #define   MovPos_IC           '1'
 141          #define   MovPos_RF           '2'
 142          #define   MovPos_Capture      '3'
 143          #define   MovPos_EjectFront   '9'
 144          
 145          /*------------------------------------------------------------------------------
 146          Definicion de la trama Lintech de las respuestas de los cmd
 147          ------------------------------------------------------------------------------*/
 148          
 149          #define Pos_TipoResp        4
 150          #define Pos_Length          3
 151          #define Pos_St0             7
 152          #define Pos_St1             8
 153          #define Pos_St2             9
 154          #define Pos_IniDatMF        0x0a
 155          #define Card_type_H         0x0a
 156          #define Card_type_L         0x0b
 157          
 158          /*----------------------------------------------------------------------------
 159          definicion de recepcion serial 
 160          ------------------------------------------------------------------------------*/
 161          
 162          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 163          
 164          /*----------------------------------------------------------------------------
 165          tiempo de delay entre funciones
 166          ------------------------------------------------------------------------------*/
 167          
 168          #define   TIME_CARD         50    //50
 169          
 170          
 171          /*----------------------------------------------------------------------------
 172          definicion de datos de trama lintech
 173          ------------------------------------------------------------------------------*/
 174          
 175          #define   ETX               03
 176          #define   STX_LINTECH       0xf2
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 4   

 177          
 178          /*----------------------------------------------------------------------------
 179          msj de lcd tarjeta y lcd serie SALIDA
 180          ------------------------------------------------------------------------------*/
 181          
 182          #define INGRESE                 85    //    0xDF
 183          #define SIN_INGRESO             86    //      0XE6
 184          #define SIN_PAGO                87    //0XE7
 185          #define EXCEDE_GRACIA           88    //0XE8
 186          #define MENSUAL_NO_PARK         89
 187          #define DIRIJASE_CAJA           90
 188          #define GRACIAS                 91    //0XFF
 189          #define ACERQUESE_CAJA          0XEB
 190          
 191          /*MENSAJES INFORMATIVOS*/
 192          
 193          #define ERROR_COD_PARK          170     //0XE5
 194          #define ERROR_LOOP              171         //0XE0
 195          #define TARJETA_INVALIDA        172     //0XE1
 196          #define TARJETA_SIN_FORMATO     173     //0xDF
 197          
 198          /*MENSAJES PRINCIPAL ACTIVA RELES*/
 199          
 200          #define AUDIO_ENTRADA     0XA0
 201          #define AUDIO_CAJA        0XA1
 202          #define AUDIO_GRACIAS     0XA2
 203          /*----------------------------------------------------------------------------
 204          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 205          ------------------------------------------------------------------------------*/
 206          
 207          #define   ENVIADOS          0X0
 208          #define   RESPUESTA         0X01
 209          
 210          /*----------------------------------------------------------------------------
 211          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 212          (0) si el dato es cero esta inactiva
 213          (1) activa o ROTACION
 214          
 215          ------------------------------------------------------------------------------*/
 216          
 217          #define INACTIVA          0x00
 218          #define ROTACION          0x01
 219          
 220          /*----------------------------------------------------------------------------
 221          posicion de  MF  bloque 1 sector 1
 222          (0) tipo de tarjeta 
 223          (01) el id del cliente
 224          (03)codigo del parqueadero  
 225          ------------------------------------------------------------------------------*/
 226          #define   MF_TIPO_TARJETA   0X00
 227          #define   MF_ID_CLIENTE     0x01
 228          #define   MF_COD_PARK       0x03
 229          
 230          /*----------------------------------------------------------------------------
 231          posicion de  MF bloque 2 sector 1
 232          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 233          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 234          MF_LSB_SDCT=0 SIN DESCUENTO
 235          MF_LSB_FECHA_OUT=1 FIJA LA FECHA DE SALIDA EN LA TARJETA
 236          MF_LSB_POR_CNTJ=2   DESCUENTO POR PORCENTAJE
 237          MF_LSB_POR_DNR=3    DESCUENTO POR DINERO
 238          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 5   

 239          
 240          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 241          
 242          
 243          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 244                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o 
 245                                                                                                                                */
 246          #define   MF_LSB            0x06        /*codigo de descuento que programa el checpoint o el software */
 247          
 248          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 249          
 250          #define   MF_IN_PAGO        0x09            /*xx11xxxx los dos bits en (1) son la parte alta del tiempo de descuento*
             -/
 251          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 252          
 253          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 254          
 255          /*----------------------------------------------------------------------------
 256          define posiciones de memoria EEPROM
 257          ------------------------------------------------------------------------------*/
 258          #define EE_DCTO_PASA_CAJA     0X000F
 259          
 260          /*----------------------------------------------------------------------------
 261          Definicion de varaibles globales del objeto
 262          ------------------------------------------------------------------------------*/
 263          
 264          static unsigned char Estado=INICIA_LINTECH;
 265          
 266          
 267          
 268          /*------------------------------------------------------------------------------
 269          funcion que valida la trama del verificador o transporte lintech
 270          (0) significa que la trama es valida y sigue en el proceso
 271          (1) falla en la respuesta por pto serie o trama invalida
 272          (2) no ha recibido la trama del verificador o transporte
 273          (3) ERROR DE TRAMA CMD (N)
 274          ------------------------------------------------------------------------------*/
 275          
 276          char Trama_Validacion_P_N()
 277          {
 278   1        char Trama_Validacion_P_N=2;                                                    /*no ha llegado inf al pto serie*/
 279   1        
 280   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 281   1            {
 282   2              if (buffer_ready==1)
 283   2              {
 284   3                buffer_ready=0;
 285   3                  
 286   3              
 287   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 288   3                {
 289   4                          
 290   4                  Trama_Validacion_P_N=0;                                                 /*trama ok*/
 291   4                    
 292   4                }
 293   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 294   3                {
 295   4                  
 296   4                  Trama_Validacion_P_N=3;                                                 /*error de trama*/
 297   4                  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 6   

 298   4                }
 299   3                else
 300   3                {
 301   4                  //Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocid
             -a*/
 302   4                  Trama_Validacion_P_N=3;   
 303   4                  
 304   4                }
 305   3              }
 306   2              else
 307   2              {
 308   3                          
 309   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 310   3                                                  
 311   3              }
 312   2      
 313   2            }
 314   1            
 315   1        return Trama_Validacion_P_N;
 316   1      }
 317          
 318          /*------------------------------------------------------------------------------
 319          funcion de error de envios pto serie
 320          
 321          variable en uart error_rx=cuenta los numeros de error pto serie y reset de transporte 
 322          se limpia cuando llega la respuesta del transporte
 323          
 324          cont_error_rx= cuenta el tiempo de ASK si completa 5 tiempos borra ek ask 
 325          
 326          error_rx_pto=0 nos da mas tiempo para esperar la trama
 327          
 328          error_rx_pto=1 reenvia la trama al transporte
 329          
 330          aSk= significa que llego al pto serie el 06 y el transporte esta ejecutando y no ha contestado necesita ti
             -empo
 331          
 332          ------------------------------------------------------------------------------*/
 333          unsigned char error_rx_pto(void)
 334          {
 335   1      static unsigned cont_error_rx=0;
 336   1      unsigned char error_rx_pto=0;
 337   1      
 338   1          
 339   1                
 340   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 341   1            Debug_chr_Tibbo (error_rx); 
 342   1            Debug_chr_Tibbo (cont_error_rx);
 343   1            Debug_chr_Tibbo (error_rx_pto);
 344   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 345   1                if (aSk==0)
 346   1            
 347   1            { 
 348   2                error_rx++;
 349   2              if(error_rx>=10)
 350   2              {                                                                                   /*no contesta debe reset el transporte*/
 351   3                Atascado=1;                                                                       /*off el rele de reset del verificador*/    
 352   3                Delay_10ms(110);
 353   3                error_rx=0;
 354   3                cont_error_rx=0;
 355   3                error_rx_pto=0;
 356   3                Atascado=0; 
 357   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 7   

 358   3                ValTimeOutCom=TIME_CARD;
 359   3              }
 360   2              else
 361   2              {
 362   3                error_rx_pto=1;                                                                 /*reenvia el cmd y espera la respuesta*/
 363   3                ValTimeOutCom=TIME_CARD;
 364   3              }
 365   2            }
 366   1            else
 367   1            {
 368   2                cont_error_rx++;
 369   2              if(cont_error_rx>=3)
 370   2              {
 371   3                error_rx=0;                                     /*paso tiempo de espera y no contesta limpio los reg y reenvio la trama
             -*/
 372   3                cont_error_rx=0;
 373   3                error_rx_pto=1;
 374   3                aSk=0;
 375   3                ValTimeOutCom=TIME_CARD;
 376   3              }
 377   2              else
 378   2              {
 379   3                error_rx=0;                                   /*damos tiempo de espera de la trama del transporte*/
 380   3                error_rx_pto=0;
 381   3                ValTimeOutCom=TIME_CARD;
 382   3              }
 383   2            }
 384   1              return (error_rx_pto);
 385   1      }
 386          /*------------------------------------------------------------------------------
 387          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 388          
 389          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 390          ------------------------------------------------------------------------------*/
 391          
 392          unsigned char  Secuencia_inicio_expedidor(void)
 393          {
 394   1        char temp;
 395   1        
 396   1        
 397   1        switch (Estado)
 398   1        {
 399   2          case INICIA_LINTECH:
 400   2      
 401   2              Atascado=0; 
 402   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 403   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 404   2              
 405   2            
 406   2            return (Estado);
 407   2          break;
 408   2      
 409   2      
 410   2      /*------------------------------------------------------------------------------
 411   2      Envia la primera trama de inicializacion del transporte sin movimiento
 412   2            (0) LA RESPUESTA ES OK
 413   2            (1) NO RESPONDE EL PTO SERIE
 414   2            (2) NO RECIBIDO LA TRAMA 
 415   2            (3) ERROR DE TRAMA CMD (N)
 416   2      ------------------------------------------------------------------------------*/
 417   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 8   

 418   2          case SEQ_CAPTURE_DATOS_INI:
 419   2      
 420   2            if((temp=Trama_Validacion_P_N())!=0)
 421   2          {
 422   3            if(temp==2)
 423   3            {
 424   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 425   4            } 
 426   3            else if (temp==3)
 427   3            {
 428   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 429   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 430   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 431   4            }
 432   3            else
 433   3            {
 434   4              
 435   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 436   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 437   4            }
 438   3          }
 439   2          else
 440   2          {
 441   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 442   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 443   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 444   3          }     
 445   2          return (Estado);
 446   2          break;
 447   2            
 448   2      /*------------------------------------------------------------------------------
 449   2      Envia el cmd de grabar claves a la eeprom del transporte 
 450   2      ------------------------------------------------------------------------------*/
 451   2            
 452   2            case GRABA_EEPROM:
 453   2              
 454   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 455   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 456   2            
 457   2            
 458   2      
 459   2            return (Estado);
 460   2              break;
 461   2        
 462   2      /*------------------------------------------------------------------------------
 463   2      se analiza la respuesta 
 464   2            (0) LA RESPUESTA ES OK
 465   2            (1) NO RESPONDE EL PTO SERIE
 466   2            (2) NO RECIBIDO LA TRAMA 
 467   2            (3) ERROR DE TRAMA CMD (N)
 468   2      ------------------------------------------------------------------------------*/
 469   2            
 470   2          case SEQ_CAPTURA_OK_EEPROM:
 471   2          
 472   2          if((temp=Trama_Validacion_P_N())!=0)
 473   2          {
 474   3            if(temp==2)
 475   3            {
 476   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 477   4            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 9   

 478   3            else if (temp==3)
 479   3            {
 480   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 481   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 482   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 483   4            }     
 484   3            else
 485   3            {
 486   4              
 487   4              
 488   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 489   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 490   4            }       
 491   3          }
 492   2          else
 493   2          {
 494   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 495   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 496   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 497   3          }     
 498   2      
 499   2          return (Estado);
 500   2          break;
 501   2      
 502   2      /*------------------------------------------------------------------------------
 503   2      Fin de la secuencia de comandos con exito 
 504   2      ------------------------------------------------------------------------------*/    
 505   2            
 506   2              case FIN_OK:
 507   2      
 508   2              return (Estado);
 509   2          break;
 510   2            
 511   2                
 512   2              default:
 513   2              return Estado=INICIA_LINTECH; 
 514   2              break;
 515   2        }
 516   1      }
 517          
 518          /*------------------------------------------------------------------------------
 519          Prosedimiento  q hace paso a paso la secuencia de la MF
 520          contador= numero de ciclos q pasa para mostrar el mensaje de loop solo se muestra el msj cuando contador=0
 521          temp= atributo para uso general
 522          Tiempo= trae el dato de mf tiempo de descuento maximo 999
 523          Estado_Tiempo = arreglo del tiempo a ascii
 524          error_rx= no llega la respuesta en el tiempo solicitado y espera otro tiempo maximo 3
 525          cont_error_rx= envio la trama otra vez solo una vez
 526          ------------------------------------------------------------------------------*/
 527          
 528          void SecuenciaExpedidor(void)
 529          {
 530   1        unsigned char temp;
 531   1        unsigned int tiempo;
 532   1        unsigned char Estado_Tiempo[4];
 533   1        static unsigned char buffer_S1_B0[17];
 534   1        static unsigned char buffer_S1_B1[17];
 535   1        static unsigned char buffer_S1_B2[17];
 536   1        unsigned char clock_temp[6];
 537   1        static unsigned char contador=0;
 538   1        switch (g_cEstadoComSeqMF)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 10  

 539   1        {
 540   2      //***********************************************************************************************
 541   2          
 542   2          case SEQ_INICIO:
 543   2      
 544   2            if (ValTimeOutCom==1)
 545   2            {
 546   3              
 547   3              Atascado=0;                                                                       /*activo el rele de reset del verificador*/   
 548   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
 549   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
 550   3              
 551   3            }
 552   2       
 553   2          break;
 554   2      
 555   2      /*------------------------------------------------------------------------------
 556   2      Analizo la trama de insercion por boca
 557   2            (0) LA RESPUESTA ES OK
 558   2            (1) NO RESPONDE EL PTO SERIE
 559   2            (2) NO RECIBIDO LA TRAMA 
 560   2            (3) ERROR DE TRAMA CMD (N)
 561   2      ------------------------------------------------------------------------------*/      
 562   2          
 563   2          case SEQ_CARD_INSERCION:  
 564   2            
 565   2          if((temp=Trama_Validacion_P_N())!=0)
 566   2          {
 567   3            if(temp==2)
 568   3            {
 569   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
 570   4            } 
 571   3            else if (temp==3)
 572   3            {
 573   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
 574   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 575   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
 576   4            }     
 577   3            else
 578   3            {
 579   4              /*Dispensador No Responde PTO SERIE ...*/
 580   4          
 581   4              if(temp=error_rx_pto()==0)
 582   4              {
 583   5                g_cEstadoComSeqMF=SEQ_CARD_INSERCION;
 584   5              }
 585   4              else if(temp=error_rx_pto()==1)
 586   4              {
 587   5                g_cEstadoComSeqMF=SEQ_INICIO;
 588   5              }
 589   4                                  
 590   4            }       
 591   3          }
 592   2          else
 593   2          {
 594   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
 595   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 596   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 11  

 597   3          }     
 598   2            
 599   2          break;
 600   2            
 601   2      /*------------------------------------------------------------------------------
 602   2      chequeo el estado de los sensores 
 603   2      ------------------------------------------------------------------------------*/      
 604   2          
 605   2          case SEQ_CHECK_STATUS:  
 606   2                if (ValTimeOutCom==1)
 607   2            {       
 608   3              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
 609   3              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
 610   3            }
 611   2            break;      
 612   2              
 613   2      /*------------------------------------------------------------------------------
 614   2      Valido la informacion de los sensores
 615   2            (0) LA RESPUESTA ES OK
 616   2            (1) NO RESPONDE EL PTO SERIE
 617   2            (2) NO RECIBIDO LA TRAMA 
 618   2            (3) ERROR DE TRAMA CMD (N)
 619   2      ------------------------------------------------------------------------------*/    
 620   2      
 621   2          case SEQ_RTA_CARD_POS:
 622   2            
 623   2          if((temp=Trama_Validacion_P_N())!=0)
 624   2          {
 625   3            if(temp==2)
 626   3            {
 627   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
 628   4            } 
 629   3            else if (temp==3)
 630   3            {
 631   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n\r\n");                     /* trama no valida*/
 632   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
 633   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
 634   4            }     
 635   3            else
 636   3            {
 637   4              
 638   4              /*Dispensador No Responde PTO SERIE ...*/
 639   4          
 640   4              if(temp=error_rx_pto()==0)
 641   4              {
 642   5                g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;
 643   5              }
 644   4              else if(temp=error_rx_pto()==1)
 645   4              {
 646   5                g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
 647   5              }
 648   4            
 649   4            }
 650   3          }
 651   2          else
 652   2          {
 653   3            Debug_txt_Tibbo((unsigned char *) "CHECK SATUS OK\r\n\r\n");                                  /* trama valida Habilitado
             - */
 654   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 12  

 655   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
             - el mecanismo*/
 656   3                  {
 657   4                    
 658   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n\r\n");       /* trama valida 
             -Habilitado insercion por boca*/
 659   4                    ValTimeOutCom=TIME_CARD;
 660   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
 661   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 662   4                    {
 663   5                      if(contador==0)                                                                   /*contador si es cero envia el msj a la pantala*/
 664   5                      { 
 665   6                        contador++;
 666   6                        Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un sen
             -sor activo*/
 667   6                        send_portERR(0xA0);                                                                 /*audio ingrese tarjeta con rele*/
 668   6                        PantallaLCD(INGRESE);                                                             /*msj por raspberry "ingrese su tarjeta"*/
 669   6                                          
 670   6                      } else
 671   5                      {
 672   6                        contador++;                                                                       /*espera 20 ciclos para poder enviar msj nueva men
             -te*/
 673   6                        if (contador>= 20)contador=0;
 674   6                      } 
 675   5                    }else contador=0;
 676   4                    
 677   4                    
 678   4                  }
 679   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
 680   3                  {
 681   4                    
 682   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n\r\n");                      /* trama valida Habilita
             -do insercion por boca*/
 683   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
 684   4                    //g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
 685   4                                           
 686   4                  }
 687   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
 688   3                  {
 689   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n\r\n");             /* trama valida H
             -abilitado insercion por boca*/
 690   4                                
 691   4                    
 692   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 693   4                    {
 694   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un senso
             -r activo*/
 695   5                    Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF50*
             -/
 696   5                                                                                                        /*tarjeta presente prioridad  */
 697   5                    g_cEstadoComSeqMF=SEQ_REQUEST;                                                      /*vamos al siguiente paso a con validar el
             - cmd*/    
 698   5                    }
 699   4                    else
 700   4                    {
 701   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en e
             -l loop*/
 702   5                      send_portERR(0XE0);                                                               /*envio msj al PRINCIPAL lcd tarjeta*/
 703   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
 704   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 13  

 705   5                      
 706   5                    }
 707   4                                                                  
 708   4                  }
 709   3                                                                    
 710   3          }     
 711   2            
 712   2          break;
 713   2        
 714   2      
 715   2      /*------------------------------------------------------------------------------
 716   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
 717   2      (1 0)  es una tarjeta valida Mf50 
 718   2      las demas combinaciones son tomadas como no validas
 719   2            (0) LA RESPUESTA ES OK
 720   2            (1) NO RESPONDE EL PTO SERIE
 721   2            (2) NO RECIBIDO LA TRAMA 
 722   2            (3) ERROR DE TRAMA CMD (N)    
 723   2      ------------------------------------------------------------------------------*/  
 724   2      
 725   2        case SEQ_REQUEST:
 726   2          
 727   2        if((temp=Trama_Validacion_P_N())!=0)
 728   2          {
 729   3            if(temp==2)
 730   3            {
 731   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
 732   4            } 
 733   3              else if (temp==3)
 734   3            {
 735   4              
 736   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n\r\n");                       /* trama no valida*/
 737   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
 738   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
 739   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
 740   4            } 
 741   3            else
 742   3            {
 743   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n\r\n");      /* pto serie no
             - responde*/
 744   4              send_portERR(0XE1);                                                                       /*la tarjeta no es valida no la puede identif
             -icar*/
 745   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 746   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
 747   4            
 748   4            }       
 749   3          }
 750   2          else
 751   2          {
 752   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
 753   3                    {
 754   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
 755   4                        {
 756   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
 757   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
 758   5                          LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tran
             -sporte
 759   5                          g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 14  

 760   5                          
 761   5                       }else
 762   4                        {
 763   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
 764   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
 765   5                        send_portERR(0xA2);                                                             /*error audio*/ 
 766   5                        send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
 767   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 768   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
 769   5                         
 770   5                        }
 771   4                   }
 772   3                    else 
 773   3                    {
 774   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
 775   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
 776   4                    send_portERR(0xA2);                                                             /*error audio*/ 
 777   4                    send_portERR(0xe1);                                                     //la tarjeta no es valida 
 778   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 779   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
 780   4                  
 781   4                    }
 782   3                                                                                                            /*respuesta ok inicia revisando sensores*/
 783   3          }     
 784   2                
 785   2            break;
 786   2      /*------------------------------------------------------------------------------
 787   2      Verifica la eeprom 
 788   2            (0) LA RESPUESTA ES OK
 789   2            (1) NO RESPONDE EL PTO SERIE
 790   2            (2) NO RECIBIDO LA TRAMA 
 791   2            (3) ERROR DE TRAMA CMD (N)
 792   2      ------------------------------------------------------------------------------*/  
 793   2        case SEQ_MF_LINTECH:
 794   2          
 795   2        if((temp=Trama_Validacion_P_N())!=0)
 796   2          {
 797   3            if(temp==2)
 798   3            {
 799   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
 800   4            }
 801   3            else if (temp==3)
 802   3            {
 803   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
 804   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 805   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
 806   4            }       
 807   3            else
 808   3            { 
 809   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
 810   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
 811   4            }
 812   3          }
 813   2          else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 15  

 814   2          {
 815   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n\r\n");                       /* trama OK CARGA LA EEP
             -ROM Y LA VERIFICA*/
 816   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 817   3                                                                                                      /*leo MF */
 818   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
 819   3          }     
 820   2      
 821   2        
 822   2        break;
 823   2      /*------------------------------------------------------------------------------
 824   2      Leo la Mf en el sector 1  bloque 1
 825   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
 826   2      ------------------------------------------------------------------------------*/    
 827   2      
 828   2        case SEQ_RD_S1B1:
 829   2          
 830   2          RD_MF(1,1);                                                                                 /*leo MF */
 831   2          g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA; 
 832   2        
 833   2        break;
 834   2      /*------------------------------------------------------------------------------
 835   2      Analiso lo leido en Mf en el sector 1  bloque 1
 836   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
 837   2      ------------------------------------------------------------------------------*/      
 838   2        
 839   2        case SEQ_RD_S1B1_RPTA:
 840   2          
 841   2          if((temp=Trama_Validacion_P_N())!=0)
 842   2          {
 843   3            if(temp==2)
 844   3            {
 845   4            g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;                                                           /*no ha respondido*/
 846   4            }
 847   3            else if (temp==3)
 848   3            {
 849   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
 850   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 851   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
 852   4            }       
 853   3            else
 854   3            { 
 855   4              
 856   4                /*Dispensador No Responde PTO SERIE ...*/
 857   4          
 858   4              if(temp=error_rx_pto()==0)
 859   4              {
 860   5                g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;
 861   5              }
 862   4              else if(temp=error_rx_pto()==1)
 863   4              {
 864   5                g_cEstadoComSeqMF=SEQ_RD_S1B1;;
 865   5              }
 866   4                                                              /* respuesta incorrecta*/
 867   4            }
 868   3          }
 869   2          else
 870   2          {
 871   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 16  

             -Y LA VERIFICA*/
 872   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 873   3            
 874   3            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 875   3            {
 876   4              
 877   4                for (temp=0; temp<16; temp++)
 878   4                {
 879   5                  buffer_S1_B1[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de 
             -MF en un arreglo*/
 880   5                }
 881   4                if (((buffer_S1_B1[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S1_B1[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE=
             -=0)&&(COD_PARK==0)))    
 882   4                {
 883   5                    
 884   5                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
 885   5                  Debug_HexDec(buffer_S1_B1[MF_ID_CLIENTE]);
 886   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 887   5                  
 888   5                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
 889   5                  Debug_HexDec(buffer_S1_B1[MF_COD_PARK]);
 890   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 891   5      
 892   5      
 893   5                  
 894   5                  if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
 895   5                  {
 896   6                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA 1 ROTACION: ");
 897   6                    Debug_chr_Tibbo(buffer_S1_B1[MF_TIPO_TARJETA]);
 898   6                    Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 899   6                    
 900   6                                                                                      
 901   6                    g_cEstadoComSeqMF=SEQ_RD_S1B2;
 902   6                    
 903   6                  }
 904   5                  else 
 905   5                  {
 906   6                    send_portERR(0xe1);
 907   6                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 908   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* expulso la tarjeta */    
 909   6                  }
 910   5                }
 911   4                else
 912   4                {
 913   5                  send_portERR(0XE5);
 914   5                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
 915   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* codigo de parqueo erro expulso la tar
             -jeta */    
 916   5                }
 917   4            }
 918   3            else
 919   3            {
 920   4              send_portERR(0XDF);
 921   4              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
 922   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
 923   4            }
 924   3            
 925   3          }     
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 17  

 926   2        break;
 927   2      /*------------------------------------------------------------------------------
 928   2      Leo la Mf en el  sector 1 bloque 2
 929   2        Se lee Fecha in, fecha out
 930   2      ------------------------------------------------------------------------------*/    
 931   2        case SEQ_RD_S1B2: 
 932   2        
 933   2        RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
 934   2        g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
 935   2        break;  
 936   2          
 937   2      /*------------------------------------------------------------------------------
 938   2      ANALIZO LO LEIDO  Mf en el  sector 1 bloque 2
 939   2        Se lee Fecha in, fecha out
 940   2      ------------------------------------------------------------------------------*/
 941   2        case SEQ_RD_S1B2_RPTA:
 942   2              
 943   2        if((temp=Trama_Validacion_P_N())!=0)
 944   2          {
 945   3            if(temp==2)
 946   3            {
 947   4            g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;                                                           /*no ha respondido*/
 948   4            }
 949   3            else if (temp==3)
 950   3            {
 951   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
 952   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 953   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
 954   4            }       
 955   3            else
 956   3            { 
 957   4                /*Dispensador No Responde PTO SERIE ...*/
 958   4          
 959   4              if(temp=error_rx_pto()==0)
 960   4              {
 961   5                g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
 962   5              }
 963   4              else if(temp=error_rx_pto()==1)
 964   4              {
 965   5                g_cEstadoComSeqMF=SEQ_RD_S1B2;
 966   5              }
 967   4                                                                  
 968   4            }
 969   3          }
 970   2          else
 971   2          {
 972   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
 973   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
 974   3            for (temp=0; temp<16; temp++)
 975   3            {
 976   4              buffer_S1_B2[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de M
             -F en un arreglo*/
 977   4            }
 978   3            
 979   3            if((buffer_S1_B2[MF_APB]==02)||(buffer_S1_B2[MF_APB]==0) )                              /*Pregunto por el antipasban s
             -i es 02 ya salio y no posee entrada*/
 980   3            {                                                                                                             /*00 inhabilitada la tarjeta*/
 981   4            Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 18  

 982   4            send_portERR(0xA2);                                                             /*error audio*/ 
 983   4            send_portERR(0XE6);
 984   4            PantallaLCD(SIN_INGRESO);
 985   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
 986   4              break;
 987   4            }
 988   3          /*------------------------------------------------------------------------------  
 989   3            sinc0bro 
 990   3          ------------------------------------------------------------------------------*/  
 991   3            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
 992   3            {
 993   4              if (SIN_COBRO==1)
 994   4              {
 995   5                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
 996   5                                                                                                    
 997   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
 998   5                break;
 999   5              }
1000   4              else if( SIN_COBRO ==2)
1001   4              {
1002   5                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1003   5                        
1004   5          
1005   5                if ((buffer_S1_B2[0]==clock_temp[0])&&(buffer_S1_B2[1]==clock_temp[1])&&(buffer_S1_B2[2]==clock_temp[
             -2]))    /*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1006   5                {
1007   6                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1008   6                                                                                                                            /* Leo el ticket */
1009   6                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1010   6                  break;
1011   6                }                                                                                         
1012   5                  else
1013   5                  {
1014   6                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");                                             /*excede el time
             -po de gracia del dia */
1015   6                  send_portERR(0XE8);
1016   6                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1017   6                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1018   6                  break;              
1019   6                  }
1020   5                
1021   5                
1022   5              }
1023   4            }
1024   3      /*------------------------------------------------------------------------------
1025   3          validacion descuentos  se maneja en 2 posiciones de memoria del MF
1026   3            MF_LSB= tipo de descuento       
1027   3      ------------------------------------------------------------------------------*/      
1028   3            else if(buffer_S1_B2[MF_LSB]!=0)
1029   3            {
1030   4              
1031   4             if((rd_eeprom(0xa8,EE_DCTO_PASA_CAJA))!= 0)  
1032   4            {
1033   5              Debug_Dividir_texto();
1034   5              Debug_txt_Tibbo((unsigned char *) "CODIGO DE DCTO: ");                                                      /*codigo de descuento
             - es elnumero de descuento del cliente*/
1035   5              Debug_chr_Tibbo(buffer_S1_B2[MF_LSB]);
1036   5              Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");  
1037   5              /*parte alta del tiempo libre*/
1038   5              temp=(buffer_S1_B2[MF_IN_PAGO]&0x70)>>4 ;                                                                   /*se lee la parte alta del 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 19  

             -tiempo libre y se rotsa 4 bits a la derecha*/
1039   5              tiempo=temp;                                                                                                /*se carga en un entero*/
1040   5              tiempo=(tiempo <<8) | buffer_S1_B2[MF_DCTO] ;                                                               /*MF_DCTO= tiene la parte
             - baja del tiempo libre, se une la parte alta con la baja */
1041   5                                                                                                                          /*creando un int del tiemo de dcto*/
1042   5              Debug_txt_Tibbo((unsigned char *) "TIEMPO DE DCTO: ");
1043   5              sprintf( Estado_Tiempo,"%u",tiempo);                                                                        /*se muestra el tiempo de desc
             -uento*/
1044   5              Debug_txt_Tibbo((unsigned char *)Estado_Tiempo);
1045   5              Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1046   5              Debug_Dividir_texto();  
1047   5              
1048   5            /*tipo de descuento es el bit 8 de MF_IN_PAGO*/ 
1049   5            /*por fecha que es fijar fecha de salida*/
1050   5                if ((buffer_S1_B2[MF_IN_PAGO]&0x80)==0)                                                                   /*tipo de descuento por fech
             -a de salida*/
1051   5                {
1052   6                Debug_txt_Tibbo((unsigned char *) "DCTO FIJA FECHA DE OUT: ");                                            /**/
1053   6                analiza_tiempo(buffer_S1_B2,tiempo); 
1054   6              /*fijar fecha de salida*/
1055   6                }
1056   5                else
1057   5                {
1058   6                  if (tiempo== 0x64)                                                                                  /*tipo de dcto por porcentaje al 100 %*/
1059   6                  {
1060   7                    Debug_txt_Tibbo((unsigned char *) "DCTO PORCENTAJE 100% ");
1061   7                    Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1062   7                                                                                                                      /* Leo el ticket */
1063   7                    g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                    /**/                                              
1064   7                    break;              
1065   7                  }
1066   6                  else
1067   6                  {
1068   7                    Debug_txt_Tibbo((unsigned char *) "DCTO NO EL 100%: ");
1069   7                    send_portERR(ACERQUESE_CAJA); 
1070   7                    PantallaLCD(DIRIJASE_CAJA); 
1071   7                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                
1072   7                  }             
1073   6                }
1074   5            }
1075   4          }
1076   3        /*------------------------------------------------------------------------------  
1077   3            tiempo de gracia
1078   3          T_GRACIA=1 tiene tiempo de gracia 
1079   3          ------------------------------------------------------------------------------*/  
1080   3            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1081   3            {
1082   4              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1083   4              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1084   4              Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");    
1085   4              analiza_tiempo(buffer_S1_B2,T_GRACIA);                                                // Simula Fecha Max de Salida.
1086   4            
1087   4            }
1088   3          /*------------------------------------------------------------------------------  
1089   3          comun para todos
1090   3          ------------------------------------------------------------------------------*/    
1091   3            temp=check_fechaOut(buffer_S1_B2+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1092   3              if(temp==1)
1093   3              {
1094   4                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n\r\n");
1095   4                  send_portERR(0xA2);                                                             /*error audio*/ 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 20  

1096   4                  send_portERR(0XE7);
1097   4                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
1098   4                  //RD_MF(1, 0);                                                                      /**leo el ticket*/  
1099   4                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1100   4                              
1101   4              }
1102   3              else if (temp==2)
1103   3              {
1104   4                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1105   4                send_portERR(0xA2);                                                               /*error audio*/         
1106   4                send_portERR(0XE8);
1107   4                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1108   4                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1109   4              }
1110   3              else
1111   3              {
1112   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1113   4                                                                                                  /* Leo el ticket */
1114   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1115   4              }
1116   3            
1117   3          }
1118   2        
1119   2            
1120   2            
1121   2            
1122   2        break;
1123   2        case SEQ_RD_S1B0:
1124   2            
1125   2            RD_MF(1, 0);                                                                    /* Leo el ticket */
1126   2            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1127   2        break;
1128   2      /*------------------------------------------------------------------------------
1129   2      Leo la Mf en el  sector 1 bloque 0
1130   2          lee el ticket
1131   2      ------------------------------------------------------------------------------*/    
1132   2          
1133   2        case SEQ_RD_S1B0_RPTA:
1134   2        
1135   2        if((temp=Trama_Validacion_P_N())!=0)
1136   2          {
1137   3            if(temp==2)
1138   3            {
1139   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;                                                           /*no ha respondido*/
1140   4            }
1141   3            else if (temp==3)
1142   3            {
1143   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1144   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1145   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1146   4            }       
1147   3            else
1148   3            { 
1149   4              /*Dispensador No Responde PTO SERIE ...*/
1150   4          
1151   4              if(temp=error_rx_pto()==0)
1152   4              {
1153   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 21  

1154   5              }
1155   4              else if(temp=error_rx_pto()==1)
1156   4              {
1157   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1158   5              }                                                       /* respuesta incorrecta*/
1159   4            }
1160   3          }
1161   2          else
1162   2          {
1163   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1164   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1165   3            
1166   3        for (temp=0; temp<16; temp++)
1167   3            {
1168   4              
1169   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1170   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1171   4              {
1172   5                break;
1173   5              }
1174   4            }
1175   3            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
1176   3            Debug_txt_Tibbo(buffer_S1_B0);
1177   3            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1178   3            
1179   3            //lock=1;   
1180   3            
1181   3            Timer_wait=0;                                                                               /*activo la barrera*/
1182   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S1_B2,'s');                                      /*transmito pto paralelo*/
1183   3            if(USE_LPR)
1184   3            {
1185   4              Cmd_LPR_Salida(buffer_S1_B0,buffer_S1_B2);                                                /*envio datos a Monitor*/
1186   4            }
1187   3            
1188   3            
1189   3            
1190   3            g_cEstadoComSeqMF=SEQ_WR_S1B2;
1191   3          }
1192   2        break;
1193   2      
1194   2            
1195   2      /*------------------------------------------------------------------------------
1196   2      envio a escribir en  la Mf en el  sector 1 bloque 2
1197   2          
1198   2      ------------------------------------------------------------------------------*/    
1199   2        case SEQ_WR_S1B2:
1200   2        
1201   2              
1202   2              WR_MF(1, 2,buffer_S1_B2+MF_TIPO_VEHICULO);
1203   2              g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1204   2            
1205   2        break;
1206   2      /*------------------------------------------------------------------------------
1207   2      espero la respuesta de la escritura en  la Mf en el  sector 1 bloque 2
1208   2          
1209   2      ------------------------------------------------------------------------------*/  
1210   2        case SEQ_WR_S1B2_RPTA:
1211   2          if((temp=Trama_Validacion_P_N())!=0)
1212   2          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 22  

1213   3            if(temp==2)
1214   3            {
1215   4            g_cEstadoComSeqMF= SEQ_WR_S1B2_RPTA;                                                            /*no ha respondido*/
1216   4            }
1217   3            else if (temp==3)
1218   3            {
1219   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1220   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1221   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1222   4            }       
1223   3            else
1224   3            { 
1225   4              
1226   4                /*Dispensador No Responde PTO SERIE ...*/
1227   4          
1228   4              if(temp=error_rx_pto()==0)
1229   4              {
1230   5                g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1231   5              }
1232   4              else if(temp=error_rx_pto()==1)
1233   4              {
1234   5                g_cEstadoComSeqMF=SEQ_WR_S1B2;
1235   5              }         
1236   4              
1237   4              
1238   4            
1239   4            }
1240   3          }
1241   2          else
1242   2          {
1243   3          
1244   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1245   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1246   3            g_cEstadoComSeqMF=SEQ_WR_S2B0;  
1247   3          }
1248   2          break;
1249   2        case SEQ_WR_S2B0:
1250   2          WR_MF(2, 0,buffer_S1_B2+MF_TIPO_VEHICULO);
1251   2        
1252   2          g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA; 
1253   2          break;
1254   2        
1255   2        
1256   2        case SEQ_WR_S2B0_RPTA:
1257   2      
1258   2        if((temp=Trama_Validacion_P_N())!=0)
1259   2          {
1260   3            if(temp==2)
1261   3            {
1262   4            g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;                                                           /*no ha respondido*/
1263   4            }
1264   3            else if (temp==3)
1265   3            {
1266   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n\r\n");                            /* trama no valida respue
             -sta incorrecta el leer el bloque*/
1267   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1268   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 23  

1269   4            }       
1270   3            else
1271   3            { 
1272   4                  /*Dispensador No Responde PTO SERIE ...*/
1273   4          
1274   4              if(temp=error_rx_pto()==0)
1275   4              {
1276   5                g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;
1277   5              }
1278   4              else if(temp=error_rx_pto()==1)
1279   4              {
1280   5                g_cEstadoComSeqMF=SEQ_WR_S2B0;
1281   5              }         
1282   4          
1283   4                  
1284   4            }
1285   3          }
1286   2          else
1287   2          {
1288   3          
1289   3            /*capturo la tarjeta*/
1290   3            lock=1;   
1291   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n\r\n");                             /* trama OK CARGA numero de
             - ticket*/
1292   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1293   3            send_portERR(0xA1);                                                                         /*audio gracias*/ 
1294   3            send_portERR(0XFF);
1295   3            PantallaLCD(GRACIAS); 
1296   3        
1297   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n\r\n");                              /* pto serie no responde*/
1298   3            
1299   3          
1300   3                  
1301   3            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1302   3          }
1303   2          break;
1304   2          
1305   2          case SEQ_RTA_CAPTURE:
1306   2            
1307   2            Mov_Card(MovPos_Capture); 
1308   2            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;
1309   2            prto_ready=1;                                                       /*le da prioridad a la respuesta de la captura de tarjeta*/
1310   2            break;
1311   2      /*------------------------------------------------------------------------------
1312   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1313   2            (0) LA RESPUESTA ES OK
1314   2            (1) NO RESPONDE EL PTO SERIE
1315   2            (2) NO RECIBIDO LA TRAMA 
1316   2            (3) ERROR DE TRAMA CMD (N)
1317   2      ------------------------------------------------------------------------------*/  
1318   2      
1319   2        case SEQ_RTA_CAPTURE_RPTA:
1320   2          
1321   2          if((temp=Trama_Validacion_P_N())!=0)
1322   2          {
1323   3            if(temp==2)
1324   3            {
1325   4              
1326   4                if (ValidaSensores_Out()==1)
1327   4              {
1328   5                lock=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 24  

1329   5                Debug_txt_Tibbo((unsigned char *) "rele off\r\n\r\n");                          /* trama ok la tarjeta fue ejectad
             -a*/
1330   5              
1331   5              }
1332   4            
1333   4                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;     
1334   4              
1335   4              
1336   4            } 
1337   3              else if (temp==3)
1338   3            {
1339   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n\r\n");                   /* Tama incorrecta no ejec
             -ta la tarjeta*/
1340   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1341   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1342   4            } 
1343   3            else
1344   3            {
1345   4                    /*Dispensador No Responde PTO SERIE ...*/
1346   4            
1347   4            
1348   4          
1349   4              
1350   4                if(temp=error_rx_pto()==0)
1351   4                {
1352   5                  g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;   
1353   5                }
1354   4                else if(temp=error_rx_pto()==1)
1355   4                {
1356   5                  
1357   5                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1358   5                }         
1359   4          
1360   4              
1361   4            
1362   4            }       
1363   3          }
1364   2          else
1365   2          {
1366   3                    
1367   3            prto_ready=0;
1368   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1369   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1370   3            
1371   3            lock=0;
1372   3            ValTimeOutCom=3;    
1373   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                   //SEQ_INICIO;                                                     /*respuesta ok ini
             -cia revisando sensores*/
1374   3                                                          
1375   3          }     
1376   2            
1377   2      
1378   2          break;
1379   2          
1380   2      
1381   2      
1382   2      case SEQ_RD_S1B0_EJECT: 
1383   2          RD_MF(1, 0);                                                                      /**leo el ticket*/  
1384   2          g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA; 
1385   2        break;  
1386   2      /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 25  

1387   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1388   2      LA tarjeta no tiene pago    
1389   2        
1390   2      ------------------------------------------------------------------------------*/
1391   2        
1392   2        
1393   2        case SEQ_RD_S1B0_EJECT_RPTA:  
1394   2          
1395   2          if((temp=Trama_Validacion_P_N())!=0)
1396   2          {
1397   3            if(temp==2)
1398   3            {
1399   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;                                                           /*no ha respondido*/
1400   4            }
1401   3            else if (temp==3)
1402   3            {
1403   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1404   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1405   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1406   4            }       
1407   3            else
1408   3            { 
1409   4                  /*Dispensador No Responde PTO SERIE ...*/
1410   4          
1411   4              if(temp=error_rx_pto()==0)
1412   4              {
1413   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;
1414   5              }
1415   4              else if(temp=error_rx_pto()==1)
1416   4              {
1417   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;
1418   5              }         
1419   4                                                  /* respuesta incorrecta*/
1420   4            }
1421   3          }
1422   2          else
1423   2          {
1424   3            
1425   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n\r\n");                              /* trama OK CARGA nume
             -ro de ticket*/
1426   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1427   3            
1428   3        for (temp=0; temp<16; temp++)
1429   3            {
1430   4              
1431   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1432   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1433   4              {
1434   5                break;
1435   5              }
1436   4            }
1437   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S1_B2,'P');    
1438   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1439   3          } 
1440   2            break;
1441   2        
1442   2      /*------------------------------------------------------------------------------
1443   2      expulsa la tarjeta por que no pertenece a MF50
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 26  

1444   2      ------------------------------------------------------------------------------*/    
1445   2        
1446   2        case SEQ_EXPULSAR_TARJ:
1447   2            Card_Insercion(Inhabilita); 
1448   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
1449   2        break;
1450   2        
1451   2        
1452   2        case SEQ_EXPULSAR_CHECK:
1453   2        if((temp=Trama_Validacion_P_N())!=0)
1454   2          {
1455   3            if(temp==2)
1456   3            {
1457   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
1458   4            } 
1459   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1460   3          }
1461   2          else
1462   2          {
1463   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
1464   3          }   
1465   2          
1466   2          break;
1467   2          
1468   2        case SEQ_EXPULSAR:
1469   2          Mov_Card(MovPos_EjectFront);
1470   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
1471   2        
1472   2        case SEQ_EXPULSAR_FROM:                       
1473   2          if((temp=Trama_Validacion_P_N())!=0)
1474   2          {
1475   3            if(temp==2)
1476   3            {
1477   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
1478   4            } 
1479   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1480   3          }
1481   2          else
1482   2          {
1483   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
1484   3          }   
1485   2          
1486   2        break;
1487   2        
1488   2      /*------------------------------------------------------------------------------
1489   2      expulsa la tarjeta por que no pertenece a MF50
1490   2      ------------------------------------------------------------------------------*/      
1491   2          
1492   2              default:
1493   2              g_cEstadoComSeqMF=SEQ_INICIO; 
1494   2              break;  
1495   2            
1496   2        } 
1497   1      }
1498          
1499          
1500            


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/27/2021 14:31:10 PAGE 27  

   CODE SIZE        =   3544    ----
   CONSTANT SIZE    =   1163    ----
   XDATA SIZE       =     55      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
