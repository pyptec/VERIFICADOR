C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include "verificador.h"
   5          #include <reg51.h>
   6          
   7          
   8          /*funciones prototipo externas */
   9          
  10          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  11          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_txt_Tibbo(unsigned char * str);
  14          extern unsigned char  ValidaSensoresPaso(void);
  15          extern void send_portERR(unsigned char cod_err);
  16          extern void Debug_chr_Tibbo(unsigned char Dat);
  17          extern void Debug_HexDec(unsigned char xfc);
  18          extern char check_fechaOut(char *buffer);
  19          extern unsigned char Dir_board();
  20          extern void PantallaLCD(unsigned char cod_msg);
  21          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  23          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  24          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  25          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  26          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          
  29          extern void Inicializa(unsigned char TipoMovimiento);
  30          extern void Check_Status(unsigned char Detalle);
  31          extern void Aut_Card_check_Status(void);
  32          extern void Mov_Card(unsigned char Posicion);
  33          extern void SecuenciaExpedidor(void);
  34          extern void Card_Insercion(char Tipo);
  35          extern void Dwload_EEprom (void);
  36          extern void LoadVerify_EEprom(void);
  37          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  38          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);
  39          extern int sprintf  (char *, const char *, ...);
  40          extern void Debug_Dividir_texto();
  41          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  42          extern void Delay_1ms(unsigned int cnt);
  43          extern void Delay_10ms(unsigned int cnt);
  44          extern unsigned char  ValidaSensores_Out(void);
  45          extern char  *strcpy  (char *s1, const char *s2);
  46          extern char lee_clk (unsigned char dir_clk);
  47          extern char check_fechaOut_2(unsigned char *buffer); 
  48          
  49          /*funcion prototipo programacion*/
  50          extern unsigned char *Addr_Horarios();
  51          
  52          sbit lock = P1^7;           //Relevo  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 2   

  53          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  54          sbit led_err_imp = P0^2;      //Error   
  55          /*variables externas*/
  56          extern bit aSk;
  57          extern unsigned char g_cEstadoComSoft;
  58          extern unsigned char ValTimeOutCom;
  59          extern unsigned char g_cEstadoComSeqMF;
  60          extern unsigned char g_cContByteRx;
  61          extern unsigned char xdata Buffer_Rta_Lintech[];
  62          extern idata unsigned char rbuf [];
  63          extern int ID_CLIENTE;
  64          extern int COD_PARK;
  65          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  66          extern unsigned char Timer_wait;
  67          extern unsigned int  SIN_COBRO;
  68          extern unsigned char error_rx;
  69          
  70          
  71          /*externo bit*/
  72          
  73          extern bit buffer_ready;
  74          extern bit prto_ready;
  75          extern unsigned char USE_LPR;
  76          
  77          /*----------------------------------------------------------------------------
  78          Definiciones de sequencias de verificador y expedidor
  79          ------------------------------------------------------------------------------*/
  80          
  81          #define SEQ_INICIO            0X00  
  82          #define SEQ_CARD_INSERCION    0X01
  83          #define SEQ_CHECK_STATUS      0X02
  84          #define SEQ_RTA_CARD_POS      0x03
  85          #define SEQ_RTA_CAPTURE       0X04
  86          #define SEQ_RTA_CAPTURE_RPTA  0x05
  87          #define SEQ_REQUEST           0x06
  88          #define SEQ_MF_LINTECH        0x07
  89          #define SEQ_RD_S1B1           0x08
  90          #define SEQ_RD_S1B1_RPTA      0x09
  91          #define SEQ_RD_S1B2           0x0a
  92          #define SEQ_RD_S1B2_RPTA      0x0b
  93          #define SEQ_RD_S1B0           0x0c
  94          #define SEQ_RD_S1B0_RPTA      0x0d
  95          #define SEQ_WR_S1B2           0x0e
  96          #define SEQ_WR_S1B2_RPTA      0x0f
  97          
  98          #define SEQ_WR_S2B0           0x10
  99          #define SEQ_WR_S2B0_RPTA      0X11
 100          #define SEQ_RD_S1B0_EJECT     0x12
 101          #define SEQ_RD_S1B0_EJECT_RPTA      0x13
 102          #define SEQ_ROTACION      0X14
 103          #define SEQ_MENSUAL       0X15
 104          
 105          
 106          #define SEQ_EXPULSAR_TARJ     0x20
 107          #define SEQ_EXPULSAR_CHECK    0x21
 108          #define SEQ_EXPULSAR          0x22
 109          #define SEQ_EXPULSAR_FROM     0x23
 110          
 111          
 112          /*----------------------------------------------------------------------------
 113           definiciones de lintech en la inicializacion de expedidor o verificador
 114          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 3   

 115          
 116          #define INICIA_LINTECH          0x30
 117          #define SEQ_CAPTURE_DATOS_INI   0x31
 118          #define GRABA_EEPROM            0x32
 119          #define SEQ_CAPTURA_OK_EEPROM   0X33
 120          #define FIN_OK                  0x00
 121          
 122          #define True                    0x01
 123          #define False                   0x00
 124          
 125          /*----------------------------------------------------------------------------
 126           definiciones de lintech en el comando Check_Status
 127          ------------------------------------------------------------------------------*/
 128          
 129          #define S_DETAIL        0x31
 130          #define S_NORMAL        0x30
 131          
 132          /*------------------------------------------------------------------------------
 133           definiciones de lintech en el comando Card_Insercion
 134          ------------------------------------------------------------------------------*/
 135          
 136          #define Habilita        0x30
 137          #define Inhabilita      0x31
 138          
 139          /*------------------------------------------------------------------------------
 140          Definicion de Lintech en el comando Inicializa
 141          ------------------------------------------------------------------------------*/
 142          
 143          #define TO_FRONT        '0'
 144          #define CAPTURE_BOX     '1'
 145          #define SIN_MOVIMIENTO  '3'
 146          
 147          /*------------------------------------------------------------------------------
 148          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 149          ------------------------------------------------------------------------------*/
 150          
 151          #define   MovPos_Front        '0'   
 152          #define   MovPos_IC           '1'
 153          #define   MovPos_RF           '2'
 154          #define   MovPos_Capture      '3'
 155          #define   MovPos_EjectFront   '9'
 156          
 157          /*------------------------------------------------------------------------------
 158          Definicion de la trama Lintech de las respuestas de los cmd
 159          ------------------------------------------------------------------------------*/
 160          
 161          #define Pos_TipoResp        4
 162          #define Pos_Length          3
 163          #define Pos_St0             7
 164          #define Pos_St1             8
 165          #define Pos_St2             9
 166          #define Pos_IniDatMF        0x0a
 167          #define Card_type_H         0x0a
 168          #define Card_type_L         0x0b
 169          
 170          /*----------------------------------------------------------------------------
 171          definicion de recepcion serial 
 172          ------------------------------------------------------------------------------*/
 173          
 174          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 175          
 176          /*----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 4   

 177          tiempo de delay entre funciones
 178          ------------------------------------------------------------------------------*/
 179          
 180          #define   TIME_CARD         50    //50
 181          
 182          
 183          /*----------------------------------------------------------------------------
 184          definicion de datos de trama lintech
 185          ------------------------------------------------------------------------------*/
 186          
 187          #define   ETX               03
 188          #define   STX_LINTECH       0xf2
 189          
 190          /*----------------------------------------------------------------------------
 191          msj de lcd tarjeta y lcd serie SALIDA
 192          ------------------------------------------------------------------------------*/
 193          
 194          #define INGRESE                 85    //    0xDF
 195          #define SIN_INGRESO             86    //      0XE6
 196          #define SIN_PAGO                87    //0XE7
 197          #define EXCEDE_GRACIA           88    //0XE8
 198          #define MENSUAL_NO_PARK         89
 199          #define DIRIJASE_CAJA           90
 200          #define GRACIAS                 91    //0XFF
 201          #define ACERQUESE_CAJA          0XEB
 202          
 203          /*MENSAJES INFORMATIVOS*/
 204          
 205          #define ERROR_COD_PARK          170     //0XE5
 206          #define ERROR_LOOP              171         //0XE0
 207          #define TARJETA_INVALIDA        172     //0XE1
 208          #define TARJETA_SIN_FORMATO     173     //0xDF
 209          
 210          /*MENSAJES PRINCIPAL ACTIVA RELES*/
 211          
 212          #define AUDIO_ENTRADA     0XA0
 213          #define AUDIO_CAJA        0XA1
 214          #define AUDIO_GRACIAS     0XA2
 215          /*----------------------------------------------------------------------------
 216          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 217          ------------------------------------------------------------------------------*/
 218          
 219          #define   ENVIADOS          0X0
 220          #define   RESPUESTA         0X01
 221          /*----------------------------------------------------------------------------
 222          definiciones para, funcion horario. 0 esta inhabilitado 1 habilitado
 223          ------------------------------------------------------------------------------*/
 224          
 225          #define   HABILITA_ADDR     15
 226          #define   Segundo_Tiempo    16
 227          /*
 228          definicion  de daos del reloj
 229                    */
 230          
 231          #define RDIA            0x87
 232          #define RMES            0x89
 233          #define RANO            0x8D
 234          #define RDIA_SEMANA     0x8B
 235          #define RHORA           0x85
 236          #define RMIN            0x83
 237          #define Sabado          7
 238          #define Domingo         1
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 5   

 239          
 240          enum Hora_Minutos_addr{
 241            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 242            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 243          };
 244          /*----------------------------------------------------------------------------
 245          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 246          (0) si el dato es cero esta inactiva
 247          (1) activa o ROTACION
 248          (2) mensualidad
 249          ------------------------------------------------------------------------------*/
 250          enum Tipos_MF_TIPO_TARJETA{
 251            INACTIVA,         
 252            ROTACION,           
 253            MENSUALIDAD,
 254            PREPAGO,
 255            CORTESIA,
 256            LOCATARIO,
 257            TARJETA_PERDIDA = 0X10,
 258            INHABILITADA = 0X11
 259          };
 260          /*----------------------------------------------------------------------------
 261          posicion de  MF  bloque 1 sector 1
 262          (0) tipo de tarjeta 
 263          (01) el id del cliente
 264          (03)codigo del parqueadero  
 265          ------------------------------------------------------------------------------*/
 266          #define   MF_TIPO_TARJETA   0X00
 267          #define   MF_ID_CLIENTE     0x01
 268          #define   MF_COD_PARK       0x03
 269          
 270          /*----------------------------------------------------------------------------
 271          posicion de  MF bloque 2 sector 1
 272          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 273          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 274          MF_LSB_SDCT=0 SIN DESCUENTO
 275          MF_LSB_FECHA_OUT=1 FIJA LA FECHA DE SALIDA EN LA TARJETA
 276          MF_LSB_POR_CNTJ=2   DESCUENTO POR PORCENTAJE
 277          MF_LSB_POR_DNR=3    DESCUENTO POR DINERO
 278          ------------------------------------------------------------------------------*/
 279          
 280          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 281          
 282          
 283          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 284                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o 
 285                                                                                                                                */
 286          #define   MF_LSB            0x06        /*codigo de descuento que programa el checpoint o el software */
 287          
 288          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 289          
 290          #define   MF_IN_PAGO        0x09            /*xx11xxxx los dos bits en (1) son la parte alta del tiempo de descuento*
             -/
 291          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 292          
 293          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 294          
 295          #define   MF_MENSUAL_ANO      0X05
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 6   

 296          #define   MF_MENSUAL_MES      0X06
 297          #define   MF_MENSUAL_DIA      0X07
 298          #define   MF_UID_0      0X04
 299          #define   MF_UID_1      0X05
 300          #define   MF_UID_2      0X06
 301          #define   MF_UID_3      0X07
 302          
 303          #define   MF_EXPIRA_ANO     0X08
 304          #define   MF_EXPIRA_MES     0X09
 305          #define   MF_EXPIRA_DIA     0X0A
 306          
 307          /*----------------------------------------------------------------------------
 308          define posiciones de memoria EEPROM
 309          ------------------------------------------------------------------------------*/
 310          #define EE_DCTO_PASA_CAJA     0X000F
 311          
 312          /*----------------------------------------------------------------------------
 313          Definicion de varaibles globales del objeto
 314          ------------------------------------------------------------------------------*/
 315          
 316          static unsigned char Estado=INICIA_LINTECH;
 317          
 318          
 319          
 320          /*------------------------------------------------------------------------------
 321          funcion que valida la trama del verificador o transporte lintech
 322          (0) significa que la trama es valida y sigue en el proceso
 323          (1) falla en la respuesta por pto serie o trama invalida
 324          (2) no ha recibido la trama del verificador o transporte
 325          (3) ERROR DE TRAMA CMD (N)
 326          ------------------------------------------------------------------------------*/
 327          
 328          char Trama_Validacion_P_N()
 329          {
 330   1        char Trama_Validacion_P_N=2;                                                    /*no ha llegado inf al pto serie*/
 331   1        
 332   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 333   1            {
 334   2              if (buffer_ready==1)
 335   2              {
 336   3                buffer_ready=0;
 337   3                  
 338   3              
 339   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 340   3                {
 341   4                          
 342   4                  Trama_Validacion_P_N=0;                                                 /*trama ok*/
 343   4                    
 344   4                }
 345   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 346   3                {
 347   4                  
 348   4                  Trama_Validacion_P_N=3;                                                 /*error de trama*/
 349   4                  
 350   4                }
 351   3                else
 352   3                {
 353   4                  //Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocid
             -a*/
 354   4                  Trama_Validacion_P_N=3;   
 355   4                  
 356   4                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 7   

 357   3              }
 358   2              else
 359   2              {
 360   3                          
 361   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 362   3                                                  
 363   3              }
 364   2      
 365   2            }
 366   1            
 367   1        return Trama_Validacion_P_N;
 368   1      }
 369          
 370          /*------------------------------------------------------------------------------
 371          funcion de error de envios pto serie
 372          
 373          variable en uart error_rx=cuenta los numeros de error pto serie y reset de transporte 
 374          se limpia cuando llega la respuesta del transporte
 375          
 376          cont_error_rx= cuenta el tiempo de ASK si completa 5 tiempos borra ek ask 
 377          
 378          error_rx_pto=0 nos da mas tiempo para esperar la trama
 379          
 380          error_rx_pto=1 reenvia la trama al transporte
 381          
 382          aSk= significa que llego al pto serie el 06 y el transporte esta ejecutando y no ha contestado necesita ti
             -empo
 383          
 384          ------------------------------------------------------------------------------*/
 385          unsigned char error_rx_pto(void)
 386          {
 387   1      static unsigned cont_error_rx=0;
 388   1      unsigned char error_rx_pto=0;
 389   1      
 390   1          
 391   1                
 392   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 393   1            Debug_chr_Tibbo (error_rx); 
 394   1            Debug_chr_Tibbo (cont_error_rx);
 395   1            Debug_chr_Tibbo (error_rx_pto);
 396   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 397   1                if (aSk==0)
 398   1            
 399   1            { 
 400   2                error_rx++;
 401   2              if(error_rx>=10)
 402   2              {                                                                                   /*no contesta debe reset el transporte*/
 403   3                Atascado=1;                                                                       /*off el rele de reset del verificador*/    
 404   3                Delay_10ms(110);
 405   3                error_rx=0;
 406   3                cont_error_rx=0;
 407   3                error_rx_pto=0;
 408   3                Atascado=0; 
 409   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 410   3                ValTimeOutCom=TIME_CARD;
 411   3              }
 412   2              else
 413   2              {
 414   3                error_rx_pto=1;                                                                 /*reenvia el cmd y espera la respuesta*/
 415   3                ValTimeOutCom=TIME_CARD;
 416   3              }
 417   2            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 8   

 418   1            else
 419   1            {
 420   2                cont_error_rx++;
 421   2              if(cont_error_rx>=3)
 422   2              {
 423   3                error_rx=0;                                     /*paso tiempo de espera y no contesta limpio los reg y reenvio la trama
             -*/
 424   3                cont_error_rx=0;
 425   3                error_rx_pto=1;
 426   3                aSk=0;
 427   3                ValTimeOutCom=TIME_CARD;
 428   3              }
 429   2              else
 430   2              {
 431   3                error_rx=0;                                   /*damos tiempo de espera de la trama del transporte*/
 432   3                error_rx_pto=0;
 433   3                ValTimeOutCom=TIME_CARD;
 434   3              }
 435   2            }
 436   1              return (error_rx_pto);
 437   1      }
 438          /*------------------------------------------------------------------------------
 439          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 440          
 441          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 442          ------------------------------------------------------------------------------*/
 443          
 444          unsigned char  Secuencia_inicio_expedidor(void)
 445          {
 446   1        char temp;
 447   1        
 448   1        
 449   1        switch (Estado)
 450   1        {
 451   2          case INICIA_LINTECH:
 452   2      
 453   2              Atascado=0; 
 454   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 455   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 456   2              
 457   2            
 458   2            return (Estado);
 459   2          break;
 460   2      
 461   2      
 462   2      /*------------------------------------------------------------------------------
 463   2      Envia la primera trama de inicializacion del transporte sin movimiento
 464   2            (0) LA RESPUESTA ES OK
 465   2            (1) NO RESPONDE EL PTO SERIE
 466   2            (2) NO RECIBIDO LA TRAMA 
 467   2            (3) ERROR DE TRAMA CMD (N)
 468   2      ------------------------------------------------------------------------------*/
 469   2            
 470   2          case SEQ_CAPTURE_DATOS_INI:
 471   2      
 472   2            if((temp=Trama_Validacion_P_N())!=0)
 473   2          {
 474   3            if(temp==2)
 475   3            {
 476   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 477   4            } 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 9   

 478   3            else if (temp==3)
 479   3            {
 480   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 481   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 482   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 483   4            }
 484   3            else
 485   3            {
 486   4              
 487   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 488   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 489   4            }
 490   3          }
 491   2          else
 492   2          {
 493   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 494   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 495   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 496   3          }     
 497   2          return (Estado);
 498   2          break;
 499   2            
 500   2      /*------------------------------------------------------------------------------
 501   2      Envia el cmd de grabar claves a la eeprom del transporte 
 502   2      ------------------------------------------------------------------------------*/
 503   2            
 504   2            case GRABA_EEPROM:
 505   2              
 506   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 507   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 508   2            
 509   2            
 510   2      
 511   2            return (Estado);
 512   2              break;
 513   2        
 514   2      /*------------------------------------------------------------------------------
 515   2      se analiza la respuesta 
 516   2            (0) LA RESPUESTA ES OK
 517   2            (1) NO RESPONDE EL PTO SERIE
 518   2            (2) NO RECIBIDO LA TRAMA 
 519   2            (3) ERROR DE TRAMA CMD (N)
 520   2      ------------------------------------------------------------------------------*/
 521   2            
 522   2          case SEQ_CAPTURA_OK_EEPROM:
 523   2          
 524   2          if((temp=Trama_Validacion_P_N())!=0)
 525   2          {
 526   3            if(temp==2)
 527   3            {
 528   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 529   4            }
 530   3            else if (temp==3)
 531   3            {
 532   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 533   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 534   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 535   4            }     
 536   3            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 10  

 537   3            {
 538   4              
 539   4              
 540   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 541   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 542   4            }       
 543   3          }
 544   2          else
 545   2          {
 546   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 547   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 548   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 549   3          }     
 550   2      
 551   2          return (Estado);
 552   2          break;
 553   2      
 554   2      /*------------------------------------------------------------------------------
 555   2      Fin de la secuencia de comandos con exito 
 556   2      ------------------------------------------------------------------------------*/    
 557   2            
 558   2              case FIN_OK:
 559   2      
 560   2              return (Estado);
 561   2          break;
 562   2            
 563   2                
 564   2              default:
 565   2              return Estado=INICIA_LINTECH; 
 566   2              break;
 567   2        }
 568   1      }
 569          
 570          /*------------------------------------------------------------------------------
 571          Prosedimiento  q hace paso a paso la secuencia de la MF
 572          contador= numero de ciclos q pasa para mostrar el mensaje de loop solo se muestra el msj cuando contador=0
 573          temp= atributo para uso general
 574          Tiempo= trae el dato de mf tiempo de descuento maximo 999
 575          Estado_Tiempo = arreglo del tiempo a ascii
 576          error_rx= no llega la respuesta en el tiempo solicitado y espera otro tiempo maximo 3
 577          cont_error_rx= envio la trama otra vez solo una vez
 578          ------------------------------------------------------------------------------*/
 579          unsigned char Horarios(unsigned char Horario)
 580          {
 581   1        unsigned char Estado_Horario;
 582   1        
 583   1        unsigned char Addr_horarios [11];
 584   1        unsigned char dia_semana,EE_dia_semana;
 585   1        unsigned int addr;
 586   1        if (Horario != False )
 587   1        {
 588   2          /*se Lee la direccion del horario*/
 589   2          strcpy (Addr_horarios,(Addr_Horarios()));
 590   2          
 591   2          addr= Addr_horarios[Horario -1] ;
 592   2          
 593   2           /*leemos si esta habilitado*/
 594   2          
 595   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
 596   2          {
 597   3            /*miramos si el dia de la semana esta habilitado*/
 598   3            dia_semana = lee_clk(RDIA_SEMANA);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 11  

 599   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
 600   3            Debug_chr_Tibbo(dia_semana);
 601   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 602   3            
 603   3          
 604   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
 605   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
 606   3            Debug_chr_Tibbo(EE_dia_semana);
 607   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 608   3          
 609   3            if ( EE_dia_semana == dia_semana)
 610   3            {
 611   4              /*miramos si esta en el rango del horario*/
 612   4              Estado_Horario = Bloque_Horario(addr);
 613   4            }
 614   3            else
 615   3            {
 616   4      
 617   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
 618   4              Estado_Horario= False;
 619   4            }
 620   3          }
 621   2          else 
 622   2          {
 623   3            
 624   3            Estado_Horario= False;
 625   3          //  PantallaLCD(HORARIO_NO_PROG);
 626   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
 627   3            
 628   3          }
 629   2          
 630   2        }
 631   1        else
 632   1        {
 633   2          Estado_Horario = True;
 634   2        
 635   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
 636   2        }
 637   1        return Estado_Horario;
 638   1      }
 639          unsigned int Hora_Maxima(unsigned int addr)
 640          {
 641   1        unsigned char Hora_High,  Minuto_High;
 642   1        unsigned char HoraIni , MinutoIni; 
 643   1        unsigned int  Hora_Prog;
 644   1        
 645   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
 646   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
 647   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
 648   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
 649   1         Debug_chr_Tibbo(HoraIni);
 650   1         Debug_chr_Tibbo(MinutoIni);
 651   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
 652   1        
 653   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
 654   1      }
 655          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
 656          {
 657   1        unsigned char Estado_Horario; 
 658   1        
 659   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
 660   1        {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 12  

 661   2          
 662   2          /*hasta la hora que puede ingresar el vehiculo */
 663   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
 664   2          Hora_Prog = Hora_Maxima(addr+4);
 665   2      
 666   2        
 667   2          if( HoraNow <= Hora_Prog)
 668   2          {
 669   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 670   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 671   3            Estado_Horario = True;
 672   3          }
 673   2          else
 674   2          {
 675   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 676   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
 677   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 678   3            Estado_Horario = False;
 679   3          }
 680   2          
 681   2        }
 682   1        else
 683   1        {
 684   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 685   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
 686   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
 687   2              Estado_Horario = False;
 688   2            
 689   2        }
 690   1        return Estado_Horario;
 691   1      }
 692          
 693          unsigned Bloque_Horario(unsigned int addr)
 694          {
 695   1        unsigned char Estado_Horario; 
 696   1        unsigned int HoraNow, Hora_Prog;
 697   1        
 698   1        /*la hora del momento de entrada del vehiculo*/
 699   1        
 700   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 701   1        Debug_chr_Tibbo(lee_clk(RHORA));
 702   1        Debug_chr_Tibbo(lee_clk(RMIN));
 703   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
 704   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 705   1        
 706   1        /* desde la hora en que puede ingresar vehiculo */
 707   1        
 708   1        
 709   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
 710   1        Hora_Prog = Hora_Maxima(addr);
 711   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
 712   1        if(Estado_Horario == False )
 713   1        {
 714   2          
 715   2            
 716   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
 717   2            {
 718   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
 719   3              Hora_Prog = Hora_Maxima(addr+10);
 720   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
 721   3            }
 722   2            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 13  

 723   2            {
 724   3      //        send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 725   3        //      PantallaLCD(MENSUAL_FUERA_HORARIO);
 726   3              Estado_Horario = False;
 727   3            }
 728   2        }
 729   1      
 730   1      return Estado_Horario;
 731   1      }
 732          
 733          void SecuenciaExpedidor(void)
 734          {
 735   1        unsigned char temp;
 736   1        unsigned int tiempo;
 737   1        unsigned char Estado_Tiempo[4];
 738   1      //  static unsigned char Atributos_Expedidor[15];
 739   1        static unsigned char buffer_S1_B0[17];
 740   1        static unsigned char buffer_S1_B1[17];
 741   1        static unsigned char buffer_S1_B2[17];
 742   1        unsigned char clock_temp[6];
 743   1        static unsigned char Horario;
 744   1        static unsigned char contador=0;
 745   1        unsigned char *atributos;
 746   1        switch (g_cEstadoComSeqMF)
 747   1        {
 748   2      //***********************************************************************************************
 749   2          
 750   2          case SEQ_INICIO:
 751   2      
 752   2            if (ValTimeOutCom==1)
 753   2            {
 754   3              
 755   3              Atascado=0;                                                                       /*activo el rele de reset del verificador*/   
 756   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
 757   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
 758   3              
 759   3            }
 760   2       
 761   2          break;
 762   2      
 763   2      /*------------------------------------------------------------------------------
 764   2      Analizo la trama de insercion por boca
 765   2            (0) LA RESPUESTA ES OK
 766   2            (1) NO RESPONDE EL PTO SERIE
 767   2            (2) NO RECIBIDO LA TRAMA 
 768   2            (3) ERROR DE TRAMA CMD (N)
 769   2      ------------------------------------------------------------------------------*/      
 770   2          
 771   2          case SEQ_CARD_INSERCION:  
 772   2            
 773   2          if((temp=Trama_Validacion_P_N())!=0)
 774   2          {
 775   3            if(temp==2)
 776   3            {
 777   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
 778   4            } 
 779   3            else if (temp==3)
 780   3            {
 781   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 14  

 782   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 783   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
 784   4            }     
 785   3            else
 786   3            {
 787   4              /*Dispensador No Responde PTO SERIE ...*/
 788   4          
 789   4              if(temp=error_rx_pto()==0)
 790   4              {
 791   5                g_cEstadoComSeqMF=SEQ_CARD_INSERCION;
 792   5              }
 793   4              else if(temp=error_rx_pto()==1)
 794   4              {
 795   5                g_cEstadoComSeqMF=SEQ_INICIO;
 796   5              }
 797   4                                  
 798   4            }       
 799   3          }
 800   2          else
 801   2          {
 802   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
 803   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 804   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
 805   3          }     
 806   2            
 807   2          break;
 808   2            
 809   2      /*------------------------------------------------------------------------------
 810   2      chequeo el estado de los sensores 
 811   2      ------------------------------------------------------------------------------*/      
 812   2          
 813   2          case SEQ_CHECK_STATUS:  
 814   2                if (ValTimeOutCom==1)
 815   2            {       
 816   3              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
 817   3              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
 818   3            }
 819   2            break;      
 820   2              
 821   2      /*------------------------------------------------------------------------------
 822   2      Valido la informacion de los sensores
 823   2            (0) LA RESPUESTA ES OK
 824   2            (1) NO RESPONDE EL PTO SERIE
 825   2            (2) NO RECIBIDO LA TRAMA 
 826   2            (3) ERROR DE TRAMA CMD (N)
 827   2      ------------------------------------------------------------------------------*/    
 828   2      
 829   2          case SEQ_RTA_CARD_POS:
 830   2            
 831   2          if((temp=Trama_Validacion_P_N())!=0)
 832   2          {
 833   3            if(temp==2)
 834   3            {
 835   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
 836   4            } 
 837   3            else if (temp==3)
 838   3            {
 839   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n\r\n");                     /* trama no valida*/
 840   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 15  

 841   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
 842   4            }     
 843   3            else
 844   3            {
 845   4              
 846   4              /*Dispensador No Responde PTO SERIE ...*/
 847   4          
 848   4              if(temp=error_rx_pto()==0)
 849   4              {
 850   5                g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;
 851   5              }
 852   4              else if(temp=error_rx_pto()==1)
 853   4              {
 854   5                g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
 855   5              }
 856   4            
 857   4            }
 858   3          }
 859   2          else
 860   2          {
 861   3            Debug_txt_Tibbo((unsigned char *) "CHECK SATUS OK\r\n\r\n");                                  /* trama valida Habilitado
             - */
 862   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
 863   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
             - el mecanismo*/
 864   3                  {
 865   4                    
 866   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n\r\n");       /* trama valida 
             -Habilitado insercion por boca*/
 867   4                    ValTimeOutCom=TIME_CARD;
 868   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
 869   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 870   4                    {
 871   5                      if(contador==0)                                                                   /*contador si es cero envia el msj a la pantala*/
 872   5                      { 
 873   6                        contador++;
 874   6                        Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un sen
             -sor activo*/
 875   6                        send_portERR(0xA0);                                                                 /*audio ingrese tarjeta con rele*/
 876   6                        PantallaLCD(INGRESE);                                                             /*msj por raspberry "ingrese su tarjeta"*/
 877   6                                          
 878   6                      } else
 879   5                      {
 880   6                        contador++;                                                                       /*espera 20 ciclos para poder enviar msj nueva men
             -te*/
 881   6                        if (contador>= 20)contador=0;
 882   6                      } 
 883   5                    }else contador=0;
 884   4                    
 885   4                    
 886   4                  }
 887   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
 888   3                  {
 889   4                    
 890   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n\r\n");                      /* trama valida Habilita
             -do insercion por boca*/
 891   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
 892   4                    //g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
 893   4                                           
 894   4                  }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 16  

 895   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
 896   3                  {
 897   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n\r\n");             /* trama valida H
             -abilitado insercion por boca*/
 898   4                                
 899   4                    
 900   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 901   4                    {
 902   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un senso
             -r activo*/
 903   5                    Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF50*
             -/
 904   5                                                                                                        /*tarjeta presente prioridad  */
 905   5                    g_cEstadoComSeqMF=SEQ_REQUEST;                                                      /*vamos al siguiente paso a con validar el
             - cmd*/    
 906   5                    }
 907   4                    else
 908   4                    {
 909   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en e
             -l loop*/
 910   5                      send_portERR(0XE0);                                                               /*envio msj al PRINCIPAL lcd tarjeta*/
 911   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
 912   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
 913   5                      
 914   5                    }
 915   4                                                                  
 916   4                  }
 917   3                                                                    
 918   3          }     
 919   2            
 920   2          break;
 921   2        
 922   2      
 923   2      /*------------------------------------------------------------------------------
 924   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
 925   2      (1 0)  es una tarjeta valida Mf50 
 926   2      las demas combinaciones son tomadas como no validas
 927   2            (0) LA RESPUESTA ES OK
 928   2            (1) NO RESPONDE EL PTO SERIE
 929   2            (2) NO RECIBIDO LA TRAMA 
 930   2            (3) ERROR DE TRAMA CMD (N)    
 931   2      ------------------------------------------------------------------------------*/  
 932   2      
 933   2        case SEQ_REQUEST:
 934   2          
 935   2        if((temp=Trama_Validacion_P_N())!=0)
 936   2          {
 937   3            if(temp==2)
 938   3            {
 939   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
 940   4            } 
 941   3              else if (temp==3)
 942   3            {
 943   4              
 944   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n\r\n");                       /* trama no valida*/
 945   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
 946   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
 947   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
 948   4            } 
 949   3            else
 950   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 17  

 951   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n\r\n");      /* pto serie no
             - responde*/
 952   4              send_portERR(0XE1);                                                                       /*la tarjeta no es valida no la puede identif
             -icar*/
 953   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 954   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
 955   4            
 956   4            }       
 957   3          }
 958   2          else
 959   2          {
 960   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
 961   3                    {
 962   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
 963   4                        {
 964   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
 965   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
 966   5                          LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tran
             -sporte
 967   5                          g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
 968   5                          
 969   5                       }else
 970   4                        {
 971   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
 972   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
 973   5                        send_portERR(0xA2);                                                             /*error audio*/ 
 974   5                        send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
 975   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 976   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
 977   5                         
 978   5                        }
 979   4                   }
 980   3                    else 
 981   3                    {
 982   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
 983   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
 984   4                    send_portERR(0xA2);                                                             /*error audio*/ 
 985   4                    send_portERR(0xe1);                                                     //la tarjeta no es valida 
 986   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
 987   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
 988   4                  
 989   4                    }
 990   3                                                                                                            /*respuesta ok inicia revisando sensores*/
 991   3          }     
 992   2                
 993   2            break;
 994   2      /*------------------------------------------------------------------------------
 995   2      Verifica la eeprom 
 996   2            (0) LA RESPUESTA ES OK
 997   2            (1) NO RESPONDE EL PTO SERIE
 998   2            (2) NO RECIBIDO LA TRAMA 
 999   2            (3) ERROR DE TRAMA CMD (N)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 18  

1000   2      ------------------------------------------------------------------------------*/  
1001   2        case SEQ_MF_LINTECH:
1002   2          
1003   2        if((temp=Trama_Validacion_P_N())!=0)
1004   2          {
1005   3            if(temp==2)
1006   3            {
1007   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1008   4            }
1009   3            else if (temp==3)
1010   3            {
1011   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1012   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1013   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1014   4            }       
1015   3            else
1016   3            { 
1017   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1018   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1019   4            }
1020   3          }
1021   2          else
1022   2          {
1023   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n\r\n");                       /* trama OK CARGA LA EEP
             -ROM Y LA VERIFICA*/
1024   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1025   3                                                                                                      /*leo MF */
1026   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1027   3          }     
1028   2      
1029   2        
1030   2        break;
1031   2      /*------------------------------------------------------------------------------
1032   2      Leo la Mf en el sector 1  bloque 1
1033   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1034   2      ------------------------------------------------------------------------------*/    
1035   2      
1036   2        case SEQ_RD_S1B1:
1037   2          
1038   2          RD_MF(1,1);                                                                                 /*leo MF */
1039   2          g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA; 
1040   2        
1041   2        break;
1042   2      /*------------------------------------------------------------------------------
1043   2      Analiso lo leido en Mf en el sector 1  bloque 1
1044   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1045   2      ------------------------------------------------------------------------------*/      
1046   2        
1047   2        case SEQ_RD_S1B1_RPTA:
1048   2          
1049   2          if((temp=Trama_Validacion_P_N())!=0)
1050   2          {
1051   3            if(temp==2)
1052   3            {
1053   4            g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;                                                           /*no ha respondido*/
1054   4            }
1055   3            else if (temp==3)
1056   3            {
1057   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 19  

             -ta incorrecta falla en la escritura de la clave*/
1058   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1059   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1060   4            }       
1061   3            else
1062   3            { 
1063   4              
1064   4                /*Dispensador No Responde PTO SERIE ...*/
1065   4          
1066   4              if(temp=error_rx_pto()==0)
1067   4              {
1068   5                g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;
1069   5              }
1070   4              else if(temp=error_rx_pto()==1)
1071   4              {
1072   5                g_cEstadoComSeqMF=SEQ_RD_S1B1;;
1073   5              }
1074   4                                                              /* respuesta incorrecta*/
1075   4            }
1076   3          }
1077   2          else
1078   2          {
1079   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA
             - VERIFICA*/
1080   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/  
1081   3            
1082   3            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1083   3            {
1084   4              
1085   4                for (temp=0; temp<16; temp++)
1086   4                {
1087   5                  buffer_S1_B1[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de 
             -MF en un arreglo*/
1088   5                }
1089   4                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);                               /*imprimo la trama recibida*/ 
1090   4                if (((buffer_S1_B1[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S1_B1[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE=
             -=0)&&(COD_PARK==0)))    
1091   4                {
1092   5                    
1093   5                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
1094   5                  Debug_HexDec(buffer_S1_B1[MF_ID_CLIENTE]);
1095   5                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1096   5                  
1097   5                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
1098   5                  Debug_HexDec(buffer_S1_B1[MF_COD_PARK]);
1099   5                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1100   5      
1101   5      
1102   5                  
1103   5                  //if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
1104   5                  //{
1105   5                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1106   5                    Debug_chr_Tibbo(buffer_S1_B1[MF_TIPO_TARJETA]);
1107   5                    Debug_txt_Tibbo((unsigned char *) "\r\n");
1108   5                    
1109   5                                                                                      
1110   5                    g_cEstadoComSeqMF=SEQ_RD_S1B2;
1111   5                    
1112   5                  //}
1113   5                  //else 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 20  

1114   5                  //{
1115   5                //    send_portERR(0xe1);
1116   5                  //  PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1117   5                  //  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* expulso la tarjeta */    
1118   5                  //}
1119   5                }
1120   4                else
1121   4                {
1122   5                  send_portERR(0XE5);
1123   5                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
1124   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* codigo de parqueo erro expulso la tar
             -jeta */    
1125   5                }
1126   4            }
1127   3            else
1128   3            {
1129   4              send_portERR(0XDF);
1130   4              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
1131   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1132   4            }
1133   3            
1134   3          }     
1135   2        break;
1136   2      /*------------------------------------------------------------------------------
1137   2      Leo la Mf en el  sector 1 bloque 2
1138   2        Se lee Fecha in, fecha out
1139   2      ------------------------------------------------------------------------------*/    
1140   2        case SEQ_RD_S1B2: 
1141   2        
1142   2        RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1143   2        g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1144   2        break;  
1145   2          
1146   2      /*------------------------------------------------------------------------------
1147   2      ANALIZO LO LEIDO  Mf en el  sector 1 bloque 2
1148   2        Se lee Fecha in, fecha out
1149   2      ------------------------------------------------------------------------------*/
1150   2        case SEQ_RD_S1B2_RPTA:
1151   2              
1152   2        if((temp=Trama_Validacion_P_N())!=0)
1153   2          {
1154   3            if(temp==2)
1155   3            {
1156   4            g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;                                                           /*no ha respondido*/
1157   4            }
1158   3            else if (temp==3)
1159   3            {
1160   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta falla en la escritura de la clave*/
1161   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1162   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1163   4            }       
1164   3            else
1165   3            { 
1166   4                /*Dispensador No Responde PTO SERIE ...*/
1167   4          
1168   4              if(temp=error_rx_pto()==0)
1169   4              {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 21  

1170   5                g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1171   5              }
1172   4              else if(temp=error_rx_pto()==1)
1173   4              {
1174   5                g_cEstadoComSeqMF=SEQ_RD_S1B2;
1175   5              }
1176   4                                                                  
1177   4            }
1178   3          }
1179   2          else
1180   2          {
1181   3           if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1182   3           {
1183   4              
1184   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA
             - VERIFICA*/
1185   4            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/  
1186   4            for (temp=0; temp<16; temp++)
1187   4            {
1188   5              buffer_S1_B2[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de M
             -F en un arreglo*/
1189   5            }
1190   4            DebugBufferMF(buffer_S1_B2,16,RESPUESTA); 
1191   4              /*------------------------------------------------------------------------------  
1192   4            APB
1193   4            ------------------------------------------------------------------------------*/
1194   4          
1195   4            if((buffer_S1_B2[MF_APB]==02)||(buffer_S1_B2[MF_APB]==0) )                              /*Pregunto por el antipasban s
             -i es 02 ya salio y no posee entrada*/
1196   4            {                                                                                                             /*00 inhabilitada la tarjeta*/
1197   5            Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n");
1198   5            send_portERR(0xA2);                                                             /*error audio*/ 
1199   5            send_portERR(0XE6);
1200   5            PantallaLCD(SIN_INGRESO);
1201   5            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1202   5              
1203   5            }
1204   4            else
1205   4            {
1206   5              
1207   5             /*------------------------------------------------------------------------------ 
1208   5              tipo de tarjeta
1209   5              ------------------------------------------------------------------------------*/
1210   5          
1211   5              if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
1212   5              {
1213   6                Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n");
1214   6                g_cEstadoComSeqMF=SEQ_ROTACION;
1215   6                
1216   6              }
1217   5              else if ((buffer_S1_B1[MF_TIPO_TARJETA]== MENSUALIDAD)) 
1218   5              {
1219   6                Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1220   6                g_cEstadoComSeqMF=SEQ_MENSUAL;
1221   6                
1222   6              }
1223   5              else
1224   5              {
1225   6                Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n");
1226   6                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1227   6                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 22  

1228   6              }
1229   5            }
1230   4            break;
1231   4           }
1232   3           else
1233   3          {
1234   4            g_cEstadoComSeqMF=SEQ_RD_S1B2;
1235   4            
1236   4          }
1237   3        }
1238   2          break;
1239   2        case SEQ_ROTACION:
1240   2          
1241   2            
1242   2            /*------------------------------------------------------------------------------  
1243   2            sinc0bro  por  programacion
1244   2          ------------------------------------------------------------------------------*/  
1245   2            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1246   2            {
1247   3              if (SIN_COBRO==1)
1248   3              {
1249   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1250   4                                                                                                    
1251   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
1252   4                break;
1253   4              }
1254   3              else if( SIN_COBRO ==2)
1255   3              {
1256   4                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1257   4                        
1258   4          
1259   4                if ((buffer_S1_B2[0]==clock_temp[0])&&(buffer_S1_B2[1]==clock_temp[1])&&(buffer_S1_B2[2]==clock_temp[
             -2]))    /*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1260   4                {
1261   5                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1262   5                                                                                                                            /* Leo el ticket */
1263   5                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1264   5                  break;
1265   5                }                                                                                         
1266   4                  else
1267   4                  {
1268   5                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n");                                             /*excede el timepo d
             -e gracia del dia */
1269   5                  send_portERR(0XE8);
1270   5                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1271   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1272   5                  break;              
1273   5                  }
1274   4                
1275   4                
1276   4              }
1277   3            }
1278   2      /*------------------------------------------------------------------------------
1279   2          validacion descuentos  se maneja en 2 posiciones de memoria del MF
1280   2            MF_LSB= tipo de descuento       
1281   2      ------------------------------------------------------------------------------*/      
1282   2            else if(buffer_S1_B2[MF_LSB]!=0)
1283   2            {
1284   3              
1285   3             if((rd_eeprom(0xa8,EE_DCTO_PASA_CAJA))!= 0)  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 23  

1286   3            {
1287   4              Debug_Dividir_texto();
1288   4              Debug_txt_Tibbo((unsigned char *) "CODIGO DE DCTO: ");                                                      /*codigo de descuento
             - es elnumero de descuento del cliente*/
1289   4              Debug_chr_Tibbo(buffer_S1_B2[MF_LSB]);
1290   4              Debug_txt_Tibbo((unsigned char *) "\r\n");  
1291   4              /*parte alta del tiempo libre*/
1292   4              temp=(buffer_S1_B2[MF_IN_PAGO]&0x70)>>4 ;                                                                   /*se lee la parte alta del 
             -tiempo libre y se rotsa 4 bits a la derecha*/
1293   4              tiempo=temp;                                                                                                /*se carga en un entero*/
1294   4              tiempo=(tiempo <<8) | buffer_S1_B2[MF_DCTO] ;                                                               /*MF_DCTO= tiene la parte
             - baja del tiempo libre, se une la parte alta con la baja */
1295   4                                                                                                                          /*creando un int del tiemo de dcto*/
1296   4              Debug_txt_Tibbo((unsigned char *) "TIEMPO DE DCTO: ");
1297   4              sprintf( Estado_Tiempo,"%u",tiempo);                                                                        /*se muestra el tiempo de desc
             -uento*/
1298   4              Debug_txt_Tibbo((unsigned char *)Estado_Tiempo);
1299   4              Debug_txt_Tibbo((unsigned char *) "\r\n");
1300   4              Debug_Dividir_texto();  
1301   4              
1302   4            /*tipo de descuento es el bit 8 de MF_IN_PAGO*/ 
1303   4            /*por fecha que es fijar fecha de salida*/
1304   4                if ((buffer_S1_B2[MF_IN_PAGO]&0x80)==0)                                                                   /*tipo de descuento por fech
             -a de salida*/
1305   4                {
1306   5                Debug_txt_Tibbo((unsigned char *) "DCTO FIJA FECHA DE OUT: ");                                            /**/
1307   5                analiza_tiempo(buffer_S1_B2,tiempo); 
1308   5              /*fijar fecha de salida*/
1309   5                }
1310   4                else
1311   4                {
1312   5                  if (tiempo== 0x64)                                                                                  /*tipo de dcto por porcentaje al 100 %*/
1313   5                  {
1314   6                    Debug_txt_Tibbo((unsigned char *) "DCTO PORCENTAJE 100% ");
1315   6                    Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1316   6                                                                                                                      /* Leo el ticket */
1317   6                    g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                    /**/                                              
1318   6                    break;              
1319   6                  }
1320   5                  else
1321   5                  {
1322   6                    Debug_txt_Tibbo((unsigned char *) "DCTO NO EL 100%: ");
1323   6                    send_portERR(ACERQUESE_CAJA); 
1324   6                    PantallaLCD(DIRIJASE_CAJA); 
1325   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                
1326   6                  }             
1327   5                }
1328   4            }
1329   3          }
1330   2        /*------------------------------------------------------------------------------  
1331   2            tiempo de gracia
1332   2          T_GRACIA=1 tiene tiempo de gracia 
1333   2          ------------------------------------------------------------------------------*/  
1334   2            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1335   2            {
1336   3              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1337   3              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1338   3              Debug_txt_Tibbo((unsigned char *) "\r\n");    
1339   3              analiza_tiempo(buffer_S1_B2,T_GRACIA);                                                // Simula Fecha Max de Salida.
1340   3            
1341   3            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 24  

1342   2          /*------------------------------------------------------------------------------  
1343   2          comun para todos
1344   2          ------------------------------------------------------------------------------*/    
1345   2            temp=check_fechaOut(buffer_S1_B2+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1346   2              if(temp==1)
1347   2              {
1348   3                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n");
1349   3                  send_portERR(0xA2);                                                             /*error audio*/ 
1350   3                  send_portERR(0XE7);
1351   3                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
1352   3                  //RD_MF(1, 0);                                                                      /**leo el ticket*/  
1353   3                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1354   3                              
1355   3              }
1356   2              else if (temp==2)
1357   2              {
1358   3                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1359   3                send_portERR(0xA2);                                                               /*error audio*/         
1360   3                send_portERR(0XE8);
1361   3                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1362   3                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1363   3              }
1364   2              else
1365   2              {
1366   3                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1367   3                                                                                                  /* Leo el ticket */
1368   3                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1369   3              }
1370   2            
1371   2          
1372   2        
1373   2            
1374   2            
1375   2            
1376   2        break;
1377   2        case SEQ_MENSUAL:
1378   2          /*cheque la fecha de expiracion del mensual*/
1379   2          Horario= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1380   2        if (Horarios(Horario) == True)
1381   2        {
1382   3          atributos = &buffer_S1_B1[MF_EXPIRA_ANO];
1383   3          
1384   3          if ( check_fechaOut_2(atributos) == True )
1385   3            {
1386   4              /*valida el vehiculo en el loop y en la card*/
1387   4              
1388   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1389   4              //  *(Atributos_Expedidor + Sector) = Sector_1;
1390   4              //  *(Atributos_Expedidor + Bloque) = Bloque_2;
1391   4              //  Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1392   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1393   4                //Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1394   4              
1395   4            }
1396   3              else 
1397   3            {
1398   4              //send_portERR(PRMR_TARJETA_VENCIDA); 
1399   4                  
1400   4      //        PantallaLCD(TARJETA_VENCIDA);
1401   4              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 25  

1402   4              g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1403   4              //Estado_expedidor = SEQ_EXPULSAR_CARD;
1404   4            }
1405   3        }
1406   2        else
1407   2        {
1408   3          
1409   3          g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1410   3        }
1411   2            break;
1412   2        case SEQ_RD_S1B0:
1413   2            
1414   2            RD_MF(1, 0);                                                                    /* Leo el ticket */
1415   2            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1416   2        break;
1417   2      /*------------------------------------------------------------------------------
1418   2      Leo la Mf en el  sector 1 bloque 0
1419   2          lee el ticket
1420   2      ------------------------------------------------------------------------------*/    
1421   2          
1422   2        case SEQ_RD_S1B0_RPTA:
1423   2        
1424   2        if((temp=Trama_Validacion_P_N())!=0)
1425   2          {
1426   3            if(temp==2)
1427   3            {
1428   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;                                                           /*no ha respondido*/
1429   4            }
1430   3            else if (temp==3)
1431   3            {
1432   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1433   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1434   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1435   4            }       
1436   3            else
1437   3            { 
1438   4              /*Dispensador No Responde PTO SERIE ...*/
1439   4          
1440   4              if(temp=error_rx_pto()==0)
1441   4              {
1442   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1443   5              }
1444   4              else if(temp=error_rx_pto()==1)
1445   4              {
1446   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1447   5              }                                                       /* respuesta incorrecta*/
1448   4            }
1449   3          }
1450   2          else
1451   2          {
1452   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n");                              /* trama OK CARGA numero de tick
             -et*/
1453   3          //  DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/    
1454   3            
1455   3        for (temp=0; temp<16; temp++)
1456   3            {
1457   4              
1458   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 26  

1459   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1460   4              {
1461   5                break;
1462   5              }
1463   4            }
1464   3            DebugBufferMF(buffer_S1_B0,16,RESPUESTA); 
1465   3            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
1466   3            Debug_txt_Tibbo(buffer_S1_B0);
1467   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1468   3            
1469   3            //lock=1;   
1470   3            
1471   3            Timer_wait=0;                                                                               /*activo la barrera*/
1472   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S1_B2,'s');                                      /*transmito pto paralelo*/
1473   3            if(USE_LPR)
1474   3            {
1475   4              Cmd_LPR_Salida(buffer_S1_B0,buffer_S1_B2);                                                /*envio datos a Monitor*/
1476   4            }
1477   3            
1478   3            
1479   3            
1480   3            g_cEstadoComSeqMF=SEQ_WR_S1B2;
1481   3          }
1482   2        break;
1483   2      
1484   2            
1485   2      /*------------------------------------------------------------------------------
1486   2      envio a escribir en  la Mf en el  sector 1 bloque 2
1487   2          
1488   2      ------------------------------------------------------------------------------*/    
1489   2        case SEQ_WR_S1B2:
1490   2        
1491   2              
1492   2              WR_MF(1, 2,buffer_S1_B2+MF_TIPO_VEHICULO);
1493   2              g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1494   2            
1495   2        break;
1496   2      /*------------------------------------------------------------------------------
1497   2      espero la respuesta de la escritura en  la Mf en el  sector 1 bloque 2
1498   2          
1499   2      ------------------------------------------------------------------------------*/  
1500   2        case SEQ_WR_S1B2_RPTA:
1501   2          if((temp=Trama_Validacion_P_N())!=0)
1502   2          {
1503   3            if(temp==2)
1504   3            {
1505   4            g_cEstadoComSeqMF= SEQ_WR_S1B2_RPTA;                                                            /*no ha respondido*/
1506   4            }
1507   3            else if (temp==3)
1508   3            {
1509   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1510   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1511   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1512   4            }       
1513   3            else
1514   3            { 
1515   4              
1516   4                /*Dispensador No Responde PTO SERIE ...*/
1517   4          
1518   4              if(temp=error_rx_pto()==0)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 27  

1519   4              {
1520   5                g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1521   5              }
1522   4              else if(temp=error_rx_pto()==1)
1523   4              {
1524   5                g_cEstadoComSeqMF=SEQ_WR_S1B2;
1525   5              }         
1526   4              
1527   4              
1528   4            
1529   4            }
1530   3          }
1531   2          else
1532   2          {
1533   3          
1534   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1535   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1536   3            g_cEstadoComSeqMF=SEQ_WR_S2B0;  
1537   3          }
1538   2          break;
1539   2        case SEQ_WR_S2B0:
1540   2          WR_MF(2, 0,buffer_S1_B2+MF_TIPO_VEHICULO);
1541   2        
1542   2          g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA; 
1543   2          break;
1544   2        
1545   2        
1546   2        case SEQ_WR_S2B0_RPTA:
1547   2      
1548   2        if((temp=Trama_Validacion_P_N())!=0)
1549   2          {
1550   3            if(temp==2)
1551   3            {
1552   4            g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;                                                           /*no ha respondido*/
1553   4            }
1554   3            else if (temp==3)
1555   3            {
1556   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n");                            /* trama no valida respuesta 
             -incorrecta el leer el bloque*/
1557   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1558   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1559   4            }       
1560   3            else
1561   3            { 
1562   4                  /*Dispensador No Responde PTO SERIE ...*/
1563   4          
1564   4              if(temp=error_rx_pto()==0)
1565   4              {
1566   5                g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;
1567   5              }
1568   4              else if(temp=error_rx_pto()==1)
1569   4              {
1570   5                g_cEstadoComSeqMF=SEQ_WR_S2B0;
1571   5              }         
1572   4          
1573   4                  
1574   4            }
1575   3          }
1576   2          else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 28  

1577   2          {
1578   3          
1579   3            /*capturo la tarjeta*/
1580   3            lock=1;   
1581   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n");                             /* trama OK CARGA numero de tic
             -ket*/
1582   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1583   3            send_portERR(0xA1);                                                                         /*audio gracias*/ 
1584   3            send_portERR(0XFF);
1585   3            PantallaLCD(GRACIAS); 
1586   3        
1587   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n");                              /* pto serie no responde*/
1588   3            
1589   3          
1590   3                  
1591   3            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1592   3          }
1593   2          break;
1594   2          
1595   2          case SEQ_RTA_CAPTURE:
1596   2            
1597   2            Mov_Card(MovPos_Capture); 
1598   2            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;
1599   2            prto_ready=1;                                                       /*le da prioridad a la respuesta de la captura de tarjeta*/
1600   2            break;
1601   2      /*------------------------------------------------------------------------------
1602   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1603   2            (0) LA RESPUESTA ES OK
1604   2            (1) NO RESPONDE EL PTO SERIE
1605   2            (2) NO RECIBIDO LA TRAMA 
1606   2            (3) ERROR DE TRAMA CMD (N)
1607   2      ------------------------------------------------------------------------------*/  
1608   2      
1609   2        case SEQ_RTA_CAPTURE_RPTA:
1610   2          
1611   2          if((temp=Trama_Validacion_P_N())!=0)
1612   2          {
1613   3            if(temp==2)
1614   3            {
1615   4              
1616   4                if (ValidaSensores_Out()==1)
1617   4              {
1618   5                lock=0;
1619   5                Debug_txt_Tibbo((unsigned char *) "rele off\r\n\r\n");                          /* trama ok la tarjeta fue ejectad
             -a*/
1620   5              
1621   5              }
1622   4            
1623   4                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;     
1624   4              
1625   4              
1626   4            } 
1627   3              else if (temp==3)
1628   3            {
1629   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n\r\n");                   /* Tama incorrecta no ejec
             -ta la tarjeta*/
1630   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1631   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1632   4            } 
1633   3            else
1634   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 29  

1635   4                    /*Dispensador No Responde PTO SERIE ...*/
1636   4            
1637   4            
1638   4          
1639   4              
1640   4                if(temp=error_rx_pto()==0)
1641   4                {
1642   5                  g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;   
1643   5                }
1644   4                else if(temp=error_rx_pto()==1)
1645   4                {
1646   5                  
1647   5                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1648   5                }         
1649   4          
1650   4              
1651   4            
1652   4            }       
1653   3          }
1654   2          else
1655   2          {
1656   3                    
1657   3            prto_ready=0;
1658   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1659   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1660   3            
1661   3            lock=0;
1662   3            ValTimeOutCom=3;    
1663   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                   //SEQ_INICIO;                                                     /*respuesta ok ini
             -cia revisando sensores*/
1664   3                                                          
1665   3          }     
1666   2            
1667   2      
1668   2          break;
1669   2          
1670   2      
1671   2      
1672   2      case SEQ_RD_S1B0_EJECT: 
1673   2          RD_MF(1, 0);                                                                      /**leo el ticket*/  
1674   2          g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA; 
1675   2        break;  
1676   2      /*------------------------------------------------------------------------------
1677   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1678   2      LA tarjeta no tiene pago    
1679   2        
1680   2      ------------------------------------------------------------------------------*/
1681   2        
1682   2        
1683   2        case SEQ_RD_S1B0_EJECT_RPTA:  
1684   2          
1685   2          if((temp=Trama_Validacion_P_N())!=0)
1686   2          {
1687   3            if(temp==2)
1688   3            {
1689   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;                                                           /*no ha respondido*/
1690   4            }
1691   3            else if (temp==3)
1692   3            {
1693   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 30  

1694   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1695   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1696   4            }       
1697   3            else
1698   3            { 
1699   4                  /*Dispensador No Responde PTO SERIE ...*/
1700   4          
1701   4              if(temp=error_rx_pto()==0)
1702   4              {
1703   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;
1704   5              }
1705   4              else if(temp=error_rx_pto()==1)
1706   4              {
1707   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;
1708   5              }         
1709   4                                                  /* respuesta incorrecta*/
1710   4            }
1711   3          }
1712   2          else
1713   2          {
1714   3            
1715   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n");                              /* trama OK CARGA numero d
             -e ticket*/
1716   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/    
1717   3            
1718   3        for (temp=0; temp<16; temp++)
1719   3            {
1720   4              
1721   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1722   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1723   4              {
1724   5                break;
1725   5              }
1726   4            }
1727   3            DebugBufferMF(buffer_S1_B0,16,RESPUESTA); 
1728   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S1_B2,'P');    
1729   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1730   3          } 
1731   2            break;
1732   2        
1733   2      /*------------------------------------------------------------------------------
1734   2      expulsa la tarjeta por que no pertenece a MF50
1735   2      ------------------------------------------------------------------------------*/    
1736   2        
1737   2        case SEQ_EXPULSAR_TARJ:
1738   2            Card_Insercion(Inhabilita); 
1739   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
1740   2        break;
1741   2        
1742   2        
1743   2        case SEQ_EXPULSAR_CHECK:
1744   2        if((temp=Trama_Validacion_P_N())!=0)
1745   2          {
1746   3            if(temp==2)
1747   3            {
1748   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
1749   4            } 
1750   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       08/31/2020 09:26:19 PAGE 31  

1751   3          }
1752   2          else
1753   2          {
1754   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
1755   3          }   
1756   2          
1757   2          break;
1758   2          
1759   2        case SEQ_EXPULSAR:
1760   2          Mov_Card(MovPos_EjectFront);
1761   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
1762   2        
1763   2        case SEQ_EXPULSAR_FROM:                       
1764   2          if((temp=Trama_Validacion_P_N())!=0)
1765   2          {
1766   3            if(temp==2)
1767   3            {
1768   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
1769   4            } 
1770   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1771   3          }
1772   2          else
1773   2          {
1774   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
1775   3          }   
1776   2          
1777   2        break;
1778   2        
1779   2      /*------------------------------------------------------------------------------
1780   2      expulsa la tarjeta por que no pertenece a MF50
1781   2      ------------------------------------------------------------------------------*/      
1782   2          
1783   2              default:
1784   2              g_cEstadoComSeqMF=SEQ_INICIO; 
1785   2              break;  
1786   2            
1787   2        } 
1788   1      }
1789          
1790          
1791            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4402    ----
   CONSTANT SIZE    =   1580    ----
   XDATA SIZE       =     56      52
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
