C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include "verificador.h"
   5          #include <reg51.h>
   6          #include <string.h>
   7          
   8          /*funciones prototipo externas */
   9          
  10          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  11          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_txt_Tibbo(unsigned char * str);
  14          extern unsigned char  ValidaSensoresPaso(void);
  15          extern void send_portERR(unsigned char cod_err);
  16          extern void Debug_chr_Tibbo(unsigned char Dat);
  17          extern void Debug_HexDec(unsigned char xfc);
  18          extern char check_fechaOut(char *buffer);
  19          extern unsigned char Dir_board();
  20          extern void PantallaLCD(unsigned char cod_msg);
  21          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B);
  23          
  24          
  25          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  26          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  27          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  28          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  29          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  30          
  31          extern void Inicializa(unsigned char TipoMovimiento);
  32          extern void Check_Status(unsigned char Detalle);
  33          extern void Aut_Card_check_Status(void);
  34          extern void Mov_Card(unsigned char Posicion);
  35          extern void SecuenciaExpedidor(void);
  36          extern void Card_Insercion(char Tipo);
  37          extern void Dwload_EEprom (void);
  38          extern void LoadVerify_EEprom(void);
  39          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  40          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);
  41          extern int sprintf  (char *, const char *, ...);
  42          extern void Debug_Dividir_texto();
  43          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  44          extern void Delay_1ms(unsigned int cnt);
  45          extern void Delay_10ms(unsigned int cnt);
  46          extern unsigned char  ValidaSensores_Out(void);
  47          extern char  *strcpy  (char *s1, const char *s2);
  48          extern char lee_clk (unsigned char dir_clk);
  49          extern char check_fechaOut_2(unsigned char *buffer); 
  50          extern void Unique_Identifier_UID(void);
  51          extern void Power_off(void);
  52          extern void  send_port(unsigned char *buffer_port, unsigned char length_char);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 2   

  53          extern unsigned char bcd_hex (unsigned char l_data);
  54          
  55          /*funcion prototipo programacion*/
  56          extern unsigned char *Addr_Horarios();
  57          
  58          sbit lock = P1^7;           //Relevo  
  59          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  60          sbit led_err_imp = P0^2;      //Error 
  61          sbit busy = P3^3;           /*bussy de Entrada Interrupcion del Procesador principal      */
  62          sbit ready = P3^2;          //Salida. solicitud envio Datos   
  63          /*variables externas*/
  64          extern bit aSk;
  65          extern unsigned char g_cEstadoComSoft;
  66          extern unsigned char ValTimeOutCom;
  67          extern unsigned char g_cEstadoComSeqMF;
  68          extern unsigned char g_cContByteRx;
  69          extern unsigned char xdata Buffer_Rta_Lintech[];
  70          extern idata unsigned char rbuf [];
  71          extern int ID_CLIENTE;
  72          extern int COD_PARK;
  73          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  74          extern unsigned char Timer_wait;
  75          extern unsigned int  SIN_COBRO;
  76          extern unsigned char error_rx;
  77          unsigned char buffer_S_B[17];
  78          extern idata unsigned char placa[];
  79          
  80          /*externo bit*/
  81          
  82          extern bit buffer_ready;
  83          extern bit prto_ready;
  84          extern unsigned char USE_LPR;
  85          
  86          /*----------------------------------------------------------------------------
  87          Definiciones de sequencias de verificador y expedidor
  88          ------------------------------------------------------------------------------*/
  89          
  90          #define SEQ_INICIO            0X00  
  91          #define SEQ_CARD_INSERCION    0X01
  92          #define SEQ_CHECK_STATUS      0X02
  93          #define SEQ_RTA_CARD_POS      0x03
  94          #define SEQ_RTA_CAPTURE       0X04
  95          #define SEQ_RTA_CAPTURE_RPTA  0x05
  96          #define SEQ_REQUEST           0x06
  97          #define SEQ_MF_LINTECH        0x07
  98          #define SEQ_RD_S1B1           0x08
  99          #define SEQ_RD_S1B1_RPTA      0x09
 100          #define SEQ_RD_S1B2           0x0a
 101          #define SEQ_RD_S1B2_RPTA      0x0b
 102          #define SEQ_RD_S1B0           0x0c
 103          #define SEQ_RD_S1B0_RPTA      0x0d
 104          #define SEQ_WR_S1B2           0x0e
 105          #define SEQ_WR_S1B2_RPTA      0x0f
 106          
 107          #define SEQ_WR_S2B0           0x10
 108          #define SEQ_WR_S2B0_RPTA      0X11
 109          #define SEQ_RD_S1B0_EJECT     0x12
 110          #define SEQ_RD_S1B0_EJECT_RPTA      0x13
 111          //#define SEQ_TIPO_TARJETAS 0X14
 112          #define SEQ_ROTACION      0X15
 113          #define SEQ_MENSUAL       0X16
 114          #define SEQ_LOAD_PASSWORD 0X17
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 3   

 115          #define SEQ_UID           0X18
 116          #define SEQ_UID_RPTA        0x19
 117          #define SEQ_POWER_OFF     0X1a
 118          #define SEQ_POWER_OFF_RPTA      0X1B
 119          #define SEQ_POWER_ON      0X1C
 120          #define SEQ_POWER_ON_RPTA   0X1D
 121          #define SEQ_TIPO_CARD     0X1E
 122          
 123          #define SEQ_EXPULSAR_TARJ     0x20
 124          #define SEQ_EXPULSAR_CHECK    0x21
 125          #define SEQ_EXPULSAR          0x22
 126          #define SEQ_EXPULSAR_FROM     0x23
 127          
 128          
 129          /*----------------------------------------------------------------------------
 130           definiciones de lintech en la inicializacion de expedidor o verificador
 131          ------------------------------------------------------------------------------*/
 132          
 133          #define INICIA_LINTECH          0x30
 134          #define SEQ_CAPTURE_DATOS_INI   0x31
 135          #define GRABA_EEPROM            0x32
 136          #define SEQ_CAPTURA_OK_EEPROM   0X33
 137          #define FIN_OK                  0x00
 138          
 139          #define True                    0x01
 140          #define False                   0x00
 141          
 142          /*----------------------------------------------------------------------------
 143           definiciones de lintech en el comando Check_Status
 144          ------------------------------------------------------------------------------*/
 145          
 146          #define S_DETAIL        0x31
 147          #define S_NORMAL        0x30
 148          
 149          /*------------------------------------------------------------------------------
 150           definiciones de lintech en el comando Card_Insercion
 151          ------------------------------------------------------------------------------*/
 152          
 153          #define Habilita        0x30
 154          #define Inhabilita      0x31
 155          
 156          /*------------------------------------------------------------------------------
 157          Definicion de Lintech en el comando Inicializa
 158          ------------------------------------------------------------------------------*/
 159          
 160          #define TO_FRONT        '0'
 161          #define CAPTURE_BOX     '1'
 162          #define SIN_MOVIMIENTO  '3'
 163          
 164          /*------------------------------------------------------------------------------
 165          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 166          ------------------------------------------------------------------------------*/
 167          
 168          #define   MovPos_Front        '0'   
 169          #define   MovPos_IC           '1'
 170          #define   MovPos_RF           '2'
 171          #define   MovPos_Capture      '3'
 172          #define   MovPos_EjectFront   '9'
 173          
 174          /*------------------------------------------------------------------------------
 175          Definicion de la trama Lintech de las respuestas de los cmd
 176          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 4   

 177          
 178          #define Pos_TipoResp        4
 179          #define Pos_Length          3
 180          #define Pos_St0             7
 181          #define Pos_St1             8
 182          #define Pos_St2             9
 183          #define Pos_IniDatMF        0x0a
 184          #define Card_type_H         0x0a
 185          #define Card_type_L         0x0b
 186          #define Rtype               0x0A
 187          /*----------------------------------------------------------------------------
 188          definicion de recepcion serial 
 189          ------------------------------------------------------------------------------*/
 190          
 191          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 192          
 193          /*----------------------------------------------------------------------------
 194          tiempo de delay entre funciones
 195          ------------------------------------------------------------------------------*/
 196          
 197          #define   TIME_CARD         50    //50
 198          
 199          
 200          /*----------------------------------------------------------------------------
 201          definicion de datos de trama lintech
 202          ------------------------------------------------------------------------------*/
 203          
 204          #define   ETX               03
 205          #define   STX_LINTECH       0xf2
 206          
 207          /*----------------------------------------------------------------------------
 208          msj de lcd tarjeta y lcd serie SALIDA
 209          ------------------------------------------------------------------------------*/
 210          
 211          #define INGRESE                 85    //    0xDF
 212          #define SIN_INGRESO             86    //      0XE6
 213          #define SIN_PAGO                87    //0XE7
 214          #define EXCEDE_GRACIA           88    //0XE8
 215          #define MENSUAL_NO_PARK         89
 216          #define DIRIJASE_CAJA           90
 217          #define GRACIAS                 91    //0XFF
 218          #define ACERQUESE_CAJA          0XEB
 219          #define PRMR_TARJETA_VENCIDA          0XEC
 220          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 221          #define PRMR_NO_ROTACION              0XFD
 222          
 223          /*MENSAJES INFORMATIVOS*/
 224          
 225          #define ERROR_COD_PARK          170     //0XE5
 226          #define ERROR_LOOP              171         //0XE0
 227          #define TARJETA_INVALIDA        172     //0XE1
 228          #define TARJETA_SIN_FORMATO     173     //0xDF
 229          #define TARJETA_VENCIDA         180
 230          #define MENSUAL_FUERA_HORARIO   181
 231          #define HORARIO_NO_PROG         182
 232          /*MENSAJES PRINCIPAL ACTIVA RELES*/
 233          
 234          #define AUDIO_ENTRADA     0XA0
 235          #define AUDIO_CAJA        0XA1
 236          #define AUDIO_GRACIAS     0XA2
 237          /*----------------------------------------------------------------------------
 238          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 5   

 239          ------------------------------------------------------------------------------*/
 240          
 241          #define   ENVIADOS          0X0
 242          #define   RESPUESTA         0X01
 243          /*----------------------------------------------------------------------------
 244          definiciones para, funcion horario. 0 esta inhabilitado 1 habilitado
 245          ------------------------------------------------------------------------------*/
 246          
 247          #define   HABILITA_ADDR     15
 248          #define   Segundo_Tiempo    16
 249          /*
 250          definicion  de daos del reloj
 251                    */
 252          
 253          #define RDIA            0x87
 254          #define RMES            0x89
 255          #define RANO            0x8D
 256          #define RDIA_SEMANA     0x8B
 257          #define RHORA           0x85
 258          #define RMIN            0x83
 259          #define Sabado          7
 260          #define Domingo         1
 261          
 262          /*----------------------------------------------------------------------------
 263          posicion de  MF  bloque 1 sector 1
 264          (0) tipo de tarjeta 
 265          (01) el id del cliente
 266          (03)codigo del parqueadero  
 267          ------------------------------------------------------------------------------*/
 268          #define   MF_TIPO_TARJETA   0X00
 269          #define   MF_ID_CLIENTE     0x01
 270          #define   MF_COD_PARK       0x03
 271          
 272          /*----------------------------------------------------------------------------
 273          posicion de  MF bloque 2 sector 1
 274          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 275          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 276          MF_LSB_SDCT=0 SIN DESCUENTO
 277          MF_LSB_FECHA_OUT=1 FIJA LA FECHA DE SALIDA EN LA TARJETA
 278          MF_LSB_POR_CNTJ=2   DESCUENTO POR PORCENTAJE
 279          MF_LSB_POR_DNR=3    DESCUENTO POR DINERO
 280          ------------------------------------------------------------------------------*/
 281          
 282          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 283          
 284          
 285          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 286                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o 
 287                                                                                                                                */
 288          #define   MF_LSB            0x06        /*codigo de descuento que programa el checpoint o el software */
 289          
 290          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 291          
 292          #define   MF_IN_PAGO        0x09            /*xx11xxxx los dos bits en (1) son la parte alta del tiempo de descuento*
             -/
 293          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 294          
 295          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 296          
 297          #define   MF_MENSUAL_ANO      0X05
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 6   

 298          #define   MF_MENSUAL_MES      0X06
 299          #define   MF_MENSUAL_DIA      0X07
 300          #define   MF_UID_0      0X04
 301          #define   MF_UID_1      0X05
 302          #define   MF_UID_2      0X06
 303          #define   MF_UID_3      0X07
 304          
 305          #define   MF_EXPIRA_ANO     0X08
 306          #define   MF_EXPIRA_MES     0X09
 307          #define   MF_EXPIRA_DIA     0X0A
 308          
 309          
 310          #define OPERATE_FAIL          0X6F
 311          /*----------------------------------------------------------------------------
 312          define posiciones de memoria EEPROM
 313          ------------------------------------------------------------------------------*/
 314          #define EE_DCTO_PASA_CAJA     0X000F
 315          #define EE_CPRCN_ACTIVA       0x000C
 316          #define EE_HABILITA_APB_MENSUAL 0X0015
 317          
 318          enum Hora_Minutos_addr{
 319            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 320            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 321          };
 322          /*----------------------------------------------------------------------------
 323          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 324          (0) si el dato es cero esta inactiva
 325          (1) activa o ROTACION
 326          (2) mensualidad
 327          ------------------------------------------------------------------------------*/
 328          enum Tipos_MF_TIPO_TARJETA{
 329            INACTIVA,         
 330            ROTACION,           
 331            MENSUALIDAD,
 332            PREPAGO,
 333            CORTESIA,
 334            LOCATARIO,
 335            TARJETA_PERDIDA = 0X10,
 336            INHABILITADA = 0X11
 337          };
 338          
 339          enum expedidor {
 340           fecha_Int_Ano,
 341           fecha_Int_Mes, 
 342           fecha_Int_Dia, 
 343           fecha_Int_Hora,
 344           fecha_Int_Min,   
 345           Tipo_Tarjeta,
 346           Apb,
 347           Horario,
 348           Pico_Placa,
 349           Type_Vehiculo,
 350           Uid_0,
 351           Uid_1,
 352           Uid_2,
 353           Uid_3,
 354           Expira_ano,
 355           Expira_mes,
 356           Expira_dia
 357           
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 7   

 358          };
 359          /*tipos de APB antipassback*/
 360          enum Tipos_MF_APB{
 361            
 362            APB_INICIADO,       
 363            APB_INT,              
 364            APB_OUT,              
 365            APB_NO              
 366          };
 367          enum EE_AntiPassBack{
 368            APB_INHABILITADO_SOFT,
 369            APB_HABILITADO_SOFT
 370          };
 371          /*comandos pto paralelo*/
 372          enum CMD_Trama_Pto_Paralelo{
 373            STX=02,
 374            CMD_PTO_PARALELO_EXPEDIDOR='a',
 375          //  ETX= 03,
 376            //NULL=0,
 377            CMD_MONITOR_EXPEDIDOR='E',
 378            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 379          };
 380          enum Tipos_Vehiculos{
 381              AUTOMOVIL,          
 382              MOTO,
 383              BICICLETA
 384          };
 385          /*----------------------------------------------------------------------------
 386          Definicion de varaibles globales del objeto
 387          ------------------------------------------------------------------------------*/
 388          
 389          static unsigned char Estado=INICIA_LINTECH;
 390          
 391          
 392          
 393          /*------------------------------------------------------------------------------
 394          funcion que valida la trama del verificador o transporte lintech
 395          (0) significa que la trama es valida y sigue en el proceso
 396          (1) falla en la respuesta por pto serie o trama invalida
 397          (2) no ha recibido la trama del verificador o transporte
 398          (3) ERROR DE TRAMA CMD (N)
 399          ------------------------------------------------------------------------------*/
 400          
 401          char Trama_Validacion_P_N()
 402          {
 403   1        char Trama_Validacion_P_N=2;                                                    /*no ha llegado inf al pto serie*/
 404   1        
 405   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 406   1            {
 407   2              if (buffer_ready==1)
 408   2              {
 409   3                buffer_ready=0;
 410   3                  
 411   3              
 412   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 413   3                {
 414   4                          
 415   4                  Trama_Validacion_P_N=0;                                                 /*trama ok*/
 416   4                    
 417   4                }
 418   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 419   3                {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 8   

 420   4                  
 421   4                  Trama_Validacion_P_N=3;                                                 /*error de trama*/
 422   4                  
 423   4                }
 424   3                else
 425   3                {
 426   4                  //Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocid
             -a*/
 427   4                  Trama_Validacion_P_N=3;   
 428   4                  
 429   4                }
 430   3              }
 431   2              else
 432   2              {
 433   3                          
 434   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 435   3                                                  
 436   3              }
 437   2      
 438   2            }
 439   1            
 440   1        return Trama_Validacion_P_N;
 441   1      }
 442          
 443          /*------------------------------------------------------------------------------
 444          funcion de error de envios pto serie
 445          
 446          variable en uart error_rx=cuenta los numeros de error pto serie y reset de transporte 
 447          se limpia cuando llega la respuesta del transporte
 448          
 449          cont_error_rx= cuenta el tiempo de ASK si completa 5 tiempos borra ek ask 
 450          
 451          error_rx_pto=0 nos da mas tiempo para esperar la trama
 452          
 453          error_rx_pto=1 reenvia la trama al transporte
 454          
 455          aSk= significa que llego al pto serie el 06 y el transporte esta ejecutando y no ha contestado necesita ti
             -empo
 456          
 457          ------------------------------------------------------------------------------*/
 458          unsigned char error_rx_pto(void)
 459          {
 460   1      static unsigned cont_error_rx=0;
 461   1      unsigned char error_rx_pto=0;
 462   1      
 463   1          
 464   1                
 465   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 466   1            Debug_chr_Tibbo (error_rx); 
 467   1            Debug_chr_Tibbo (cont_error_rx);
 468   1            Debug_chr_Tibbo (error_rx_pto);
 469   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 470   1                if (aSk==0)
 471   1            
 472   1            { 
 473   2                error_rx++;
 474   2              if(error_rx>=10)
 475   2              {                                                                                   /*no contesta debe reset el transporte*/
 476   3                Atascado=1;                                                                       /*off el rele de reset del verificador*/    
 477   3                Delay_10ms(110);
 478   3                error_rx=0;
 479   3                cont_error_rx=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 9   

 480   3                error_rx_pto=0;
 481   3                Atascado=0; 
 482   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 483   3                ValTimeOutCom=TIME_CARD;
 484   3              }
 485   2              else
 486   2              {
 487   3                error_rx_pto=1;                                                                 /*reenvia el cmd y espera la respuesta*/
 488   3                ValTimeOutCom=TIME_CARD;
 489   3              }
 490   2            }
 491   1            else
 492   1            {
 493   2                cont_error_rx++;
 494   2              if(cont_error_rx>=3)
 495   2              {
 496   3                error_rx=0;                                     /*paso tiempo de espera y no contesta limpio los reg y reenvio la trama
             -*/
 497   3                cont_error_rx=0;
 498   3                error_rx_pto=1;
 499   3                aSk=0;
 500   3                ValTimeOutCom=TIME_CARD;
 501   3              }
 502   2              else
 503   2              {
 504   3                error_rx=0;                                   /*damos tiempo de espera de la trama del transporte*/
 505   3                error_rx_pto=0;
 506   3                ValTimeOutCom=TIME_CARD;
 507   3              }
 508   2            }
 509   1              return (error_rx_pto);
 510   1      }
 511          /*------------------------------------------------------------------------------
 512          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 513          
 514          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 515          ------------------------------------------------------------------------------*/
 516          
 517          unsigned char  Secuencia_inicio_expedidor(void)
 518          {
 519   1        char temp;
 520   1        
 521   1        
 522   1        switch (Estado)
 523   1        {
 524   2          case INICIA_LINTECH:
 525   2      
 526   2              Atascado=0; 
 527   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 528   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 529   2              
 530   2            
 531   2            return (Estado);
 532   2          break;
 533   2      
 534   2      
 535   2      /*------------------------------------------------------------------------------
 536   2      Envia la primera trama de inicializacion del transporte sin movimiento
 537   2            (0) LA RESPUESTA ES OK
 538   2            (1) NO RESPONDE EL PTO SERIE
 539   2            (2) NO RECIBIDO LA TRAMA 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 10  

 540   2            (3) ERROR DE TRAMA CMD (N)
 541   2      ------------------------------------------------------------------------------*/
 542   2            
 543   2          case SEQ_CAPTURE_DATOS_INI:
 544   2      
 545   2            if((temp=Trama_Validacion_P_N())!=0)
 546   2          {
 547   3            if(temp==2)
 548   3            {
 549   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 550   4            } 
 551   3            else if (temp==3)
 552   3            {
 553   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 554   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 555   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 556   4            }
 557   3            else
 558   3            {
 559   4              
 560   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 561   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 562   4            }
 563   3          }
 564   2          else
 565   2          {
 566   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 567   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 568   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 569   3          }     
 570   2          return (Estado);
 571   2          break;
 572   2            
 573   2      /*------------------------------------------------------------------------------
 574   2      Envia el cmd de grabar claves a la eeprom del transporte 
 575   2      ------------------------------------------------------------------------------*/
 576   2            
 577   2            case GRABA_EEPROM:
 578   2              
 579   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 580   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 581   2            
 582   2            
 583   2      
 584   2            return (Estado);
 585   2              break;
 586   2        
 587   2      /*------------------------------------------------------------------------------
 588   2      se analiza la respuesta 
 589   2            (0) LA RESPUESTA ES OK
 590   2            (1) NO RESPONDE EL PTO SERIE
 591   2            (2) NO RECIBIDO LA TRAMA 
 592   2            (3) ERROR DE TRAMA CMD (N)
 593   2      ------------------------------------------------------------------------------*/
 594   2            
 595   2          case SEQ_CAPTURA_OK_EEPROM:
 596   2          
 597   2          if((temp=Trama_Validacion_P_N())!=0)
 598   2          {
 599   3            if(temp==2)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 11  

 600   3            {
 601   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 602   4            }
 603   3            else if (temp==3)
 604   3            {
 605   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 606   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 607   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 608   4            }     
 609   3            else
 610   3            {
 611   4              
 612   4              
 613   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 614   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 615   4            }       
 616   3          }
 617   2          else
 618   2          {
 619   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 620   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 621   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 622   3          }     
 623   2      
 624   2          return (Estado);
 625   2          break;
 626   2      
 627   2      /*------------------------------------------------------------------------------
 628   2      Fin de la secuencia de comandos con exito 
 629   2      ------------------------------------------------------------------------------*/    
 630   2            
 631   2              case FIN_OK:
 632   2      
 633   2              return (Estado);
 634   2          break;
 635   2            
 636   2                
 637   2              default:
 638   2              return Estado=INICIA_LINTECH; 
 639   2              break;
 640   2        }
 641   1      }
 642          
 643          /*------------------------------------------------------------------------------
 644          Prosedimiento  q hace paso a paso la secuencia de la MF
 645          contador= numero de ciclos q pasa para mostrar el mensaje de loop solo se muestra el msj cuando contador=0
 646          temp= atributo para uso general
 647          Tiempo= trae el dato de mf tiempo de descuento maximo 999
 648          Estado_Tiempo = arreglo del tiempo a ascii
 649          error_rx= no llega la respuesta en el tiempo solicitado y espera otro tiempo maximo 3
 650          cont_error_rx= envio la trama otra vez solo una vez
 651          ------------------------------------------------------------------------------*/
 652          unsigned char Horarios(unsigned char Horario)
 653          {
 654   1        unsigned char Estado_Horario;
 655   1        
 656   1        unsigned char Addr_horarios [11];
 657   1        unsigned char dia_semana,EE_dia_semana;
 658   1        unsigned int addr;
 659   1        if (Horario != False )
 660   1        {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 12  

 661   2          /*se Lee la direccion del horario*/
 662   2          strcpy (Addr_horarios,(Addr_Horarios()));
 663   2          
 664   2          addr= Addr_horarios[Horario -1] ;
 665   2          
 666   2           /*leemos si esta habilitado*/
 667   2          
 668   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
 669   2          {
 670   3            /*miramos si el dia de la semana esta habilitado*/
 671   3            dia_semana = lee_clk(RDIA_SEMANA);
 672   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
 673   3            Debug_chr_Tibbo(dia_semana);
 674   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 675   3            
 676   3          
 677   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
 678   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
 679   3            Debug_chr_Tibbo(EE_dia_semana);
 680   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 681   3          
 682   3            if ( EE_dia_semana == dia_semana)
 683   3            {
 684   4              /*miramos si esta en el rango del horario*/
 685   4              Estado_Horario = Bloque_Horario(addr);
 686   4            }
 687   3            else
 688   3            {
 689   4      
 690   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
 691   4              Estado_Horario= False;
 692   4            }
 693   3          }
 694   2          else 
 695   2          {
 696   3            
 697   3            Estado_Horario= False;
 698   3            PantallaLCD(HORARIO_NO_PROG);
 699   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
 700   3            
 701   3          }
 702   2          
 703   2        }
 704   1        else
 705   1        {
 706   2          
 707   2          /*es mensual sin horarios*/
 708   2          Estado_Horario = False;       //True;
 709   2        
 710   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
 711   2        }
 712   1        return Estado_Horario;
 713   1      }
 714          unsigned int Hora_Maxima(unsigned int addr)
 715          {
 716   1        unsigned char Hora_High,  Minuto_High;
 717   1        unsigned char HoraIni , MinutoIni; 
 718   1        unsigned int  Hora_Prog;
 719   1        
 720   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
 721   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
 722   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 13  

 723   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
 724   1         Debug_chr_Tibbo(HoraIni);
 725   1         Debug_chr_Tibbo(MinutoIni);
 726   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
 727   1        
 728   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
 729   1      }
 730          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
 731          {
 732   1        unsigned char Estado_Horario; 
 733   1        
 734   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
 735   1        {
 736   2          
 737   2          /*hasta la hora que puede ingresar el vehiculo */
 738   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
 739   2          Hora_Prog = Hora_Maxima(addr+4);
 740   2      
 741   2        
 742   2          if( HoraNow <= Hora_Prog)
 743   2          {
 744   3            send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 745   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 746   3            Estado_Horario = True;
 747   3          }
 748   2          else
 749   2          {
 750   3            send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 751   3            PantallaLCD(MENSUAL_FUERA_HORARIO);
 752   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 753   3            Estado_Horario = False;
 754   3          }
 755   2          
 756   2        }
 757   1        else
 758   1        {
 759   2              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 760   2              PantallaLCD(MENSUAL_FUERA_HORARIO);
 761   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
 762   2              Estado_Horario = False;
 763   2            
 764   2        }
 765   1        return Estado_Horario;
 766   1      }
 767          
 768          unsigned Bloque_Horario(unsigned int addr)
 769          {
 770   1        unsigned char Estado_Horario; 
 771   1        unsigned int HoraNow, Hora_Prog;
 772   1        
 773   1        /*la hora del momento de entrada del vehiculo*/
 774   1        
 775   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 776   1        Debug_chr_Tibbo(lee_clk(RHORA));
 777   1        Debug_chr_Tibbo(lee_clk(RMIN));
 778   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
 779   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 780   1        
 781   1        /* desde la hora en que puede ingresar vehiculo */
 782   1        
 783   1        
 784   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 14  

 785   1        Hora_Prog = Hora_Maxima(addr);
 786   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
 787   1        if(Estado_Horario == False )
 788   1        {
 789   2          
 790   2            
 791   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
 792   2            {
 793   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
 794   3              Hora_Prog = Hora_Maxima(addr+10);
 795   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
 796   3            }
 797   2            else
 798   2            {
 799   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 800   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
 801   3              Estado_Horario = False;
 802   3            }
 803   2        }
 804   1      
 805   1      return Estado_Horario;
 806   1      }
 807          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
 808          {
 809   1        unsigned char temp;
 810   1        unsigned char Estado_expedidor;
 811   1        static unsigned char falla=0;
 812   1        
 813   1        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA V
             -ERIFICA*/
 814   1                                      
 815   1            
 816   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 817   1            {
 818   2              
 819   2                for (temp=0; temp<16; temp++)
 820   2                {
 821   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
 822   3                }
 823   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);                               /*imprimo la trama recibida*/ 
 824   2                if (((buffer_S_B[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S_B[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE==0)&
             -&(COD_PARK==0)))    
 825   2                {
 826   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
 827   3                  Debug_HexDec(buffer_S_B[MF_ID_CLIENTE]);
 828   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 829   3                  
 830   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
 831   3                  Debug_HexDec(buffer_S_B[MF_COD_PARK]);
 832   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 833   3                  
 834   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
 835   3                  Debug_chr_Tibbo(buffer_S_B [MF_TIPO_TARJETA]);
 836   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 837   3                  
 838   3                  
 839   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S_B [MF_TIPO_TARJETA];
 840   3                
 841   3                  /*fecha de vencimiento de mensual o prepago*/
 842   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S_B [MF_EXPIRA_ANO];
 843   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S_B [MF_EXPIRA_MES];
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 15  

 844   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S_B [MF_EXPIRA_DIA];
 845   3                  falla=0;                                                                  
 846   3                    Estado_expedidor=SEQ_RD_S1B2;
 847   3                
 848   3                }
 849   2                else
 850   2                {
 851   3                  falla=0;
 852   3                  send_portERR(0XE5);
 853   3                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
 854   3                  Estado_expedidor=SEQ_EXPULSAR_TARJ;                                               /* codigo de parqueo erro expulso la tarj
             -eta */    
 855   3                }
 856   2            }
 857   1            else
 858   1            {
 859   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
 860   2              {
 861   3                falla++;
 862   3              }
 863   2               if (falla <= 2)
 864   2                
 865   2              {
 866   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
 867   3                Estado_expedidor = SEQ_POWER_ON;
 868   3                                    
 869   3              }
 870   2              else
 871   2              {
 872   3                falla=0;
 873   3                send_portERR(0XDF);
 874   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
 875   3                Estado_expedidor=SEQ_EXPULSAR_TARJ;
 876   3              }
 877   2            }
 878   1            return Estado_expedidor;
 879   1      }     
 880          
 881          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
 882          {
 883   1        unsigned char temp;
 884   1        unsigned char Estado_expedidor;
 885   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 886   1           {
 887   2            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA
             - VERIFICA*/
 888   2                            
 889   2            for (temp=0; temp<16; temp++)
 890   2            {
 891   3              buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de MF 
             -en un arreglo*/
 892   3            }
 893   2            DebugBufferMF(buffer_S_B,16,RESPUESTA); 
 894   2            /*fecha entrada*/
 895   2      
 896   2            *(Atributos_Expedidor + fecha_Int_Ano) =    buffer_S_B [MF_FECHA_INT] ;
 897   2            *(Atributos_Expedidor + fecha_Int_Mes) =    buffer_S_B [MF_FECHA_INT+1] ;
 898   2            *(Atributos_Expedidor + fecha_Int_Dia) =    buffer_S_B [MF_FECHA_INT+2] ;
 899   2            *(Atributos_Expedidor + fecha_Int_Hora)=    buffer_S_B [MF_FECHA_INT+3] ;
 900   2            *(Atributos_Expedidor + fecha_Int_Min) =    buffer_S_B [MF_FECHA_INT+4] ;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 16  

 901   2            /*horario*/
 902   2            Debug_txt_Tibbo((unsigned char *) "HORARIO:");
 903   2            Debug_chr_Tibbo((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
 904   2            *(Atributos_Expedidor + Horario)= ((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
 905   2              Debug_txt_Tibbo((unsigned char *) "\r\n");
 906   2            /*pico y placa*/
 907   2            *(Atributos_Expedidor + Pico_Placa)= ((buffer_S_B [MF_IN_PAGO] & 0XF0) >> 4);     
 908   2            /*APB*/
 909   2            *(Atributos_Expedidor + Apb)=   buffer_S_B [MF_APB] ;
 910   2            /*tipo de tarjeta*/
 911   2            *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S_B [MF_TIPO_VEHICULO]& 0x0f;
 912   2                  
 913   2             /*------------------------------------------------------------------------------ 
 914   2              tipo de tarjeta
 915   2              ------------------------------------------------------------------------------*/
 916   2      
 917   2              if  (*(Atributos_Expedidor + Tipo_Tarjeta) ==ROTACION)          
 918   2              {
 919   3                  if((*(Atributos_Expedidor + Apb) == 02)||(*(Atributos_Expedidor + Apb) == 0) )                              /*Pregu
             -nto por el antipasban si es 02 ya salio y no posee entrada*/
 920   3                  {
 921   4                    Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n");
 922   4                    send_portERR(0xA2);                                                             /*error audio*/ 
 923   4                    send_portERR(0XE6);
 924   4                    PantallaLCD(SIN_INGRESO);
 925   4                    Estado_expedidor=SEQ_EXPULSAR_TARJ;
 926   4                  }
 927   3                  else
 928   3                  {
 929   4                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n");
 930   4                    Estado_expedidor=SEQ_ROTACION;
 931   4                  
 932   4                  }
 933   3        
 934   3              }
 935   2              else if (*(Atributos_Expedidor + Tipo_Tarjeta)== MENSUALIDAD) 
 936   2              {
 937   3                if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
 938   3                {
 939   4                  Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK SOFTWARE HABILITADO MENSUAL \r\n");
 940   4                  if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) ) 
 941   4                  {
 942   5                    Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO MENSUAL\r\n");
 943   5                    //send_portERR(0xA2);                                                             /*error audio*/ 
 944   5                    send_portERR(0XE6);
 945   5                    PantallaLCD(SIN_INGRESO);
 946   5                    Estado_expedidor=SEQ_EXPULSAR_TARJ;
 947   5                  
 948   5                  }
 949   4                  else
 950   4                  {
 951   5                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
 952   5                    Estado_expedidor=SEQ_MENSUAL;
 953   5                  }
 954   4                }
 955   3                else
 956   3                {
 957   4                  Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK SOFTWARE INHABILITADO MENSUAL \r\n");
 958   4                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
 959   4                  Estado_expedidor = SEQ_MENSUAL;
 960   4                }
 961   3              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 17  

 962   2              else
 963   2              {
 964   3                Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n");
 965   3                send_portERR(PRMR_NO_ROTACION);
 966   3                Estado_expedidor=SEQ_EXPULSAR_TARJ;
 967   3                
 968   3              }
 969   2             
 970   2          }
 971   1        else
 972   1           {
 973   2             g_cEstadoComSeqMF=SEQ_RD_S1B2;
 974   2           }
 975   1           
 976   1           return Estado_expedidor;
 977   1        
 978   1      }
 979          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Atributos_Expedidor)
 980          {
 981   1        unsigned char temp;
 982   1        unsigned char Estado_expedidor;
 983   1        static unsigned char buffer_S1_B0[17];
 984   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 985   1           {
 986   2        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n");                              /* trama OK CARGA numero de ticket
             -*/
 987   2                                          
 988   2            
 989   2        for (temp=0; temp<16; temp++)
 990   2            {
 991   3              
 992   3              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
 993   3              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
 994   3              {
 995   4                break;
 996   4              }
 997   3            }
 998   2            
 999   2            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
1000   2            Debug_txt_Tibbo(buffer_S1_B0);
1001   2            Debug_txt_Tibbo((unsigned char *) "\r\n");
1002   2            
1003   2          
1004   2            /*transmito pto paralelo*/  
1005   2            if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
1006   2            {
1007   3            Timer_wait=0;                                                                               /*activo la barrera*/
1008   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S_B,'s');
1009   3            }
1010   2            else
1011   2            {
1012   3            
1013   3            Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor);
1014   3            }
1015   2            if(USE_LPR)
1016   2            {
1017   3              
1018   3              /*envio datos a Monitor*/
1019   3              if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
1020   3              {
1021   4              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 18  

1022   4              Cmd_LPR_Salida(Atributos_Expedidor,buffer_S1_B0); 
1023   4              }
1024   3              else
1025   3              {
1026   4              Cmd_LPR_Salida(Atributos_Expedidor,buffer_S1_B0); 
1027   4              }
1028   3            }
1029   2            
1030   2            
1031   2            
1032   2            Estado_expedidor=SEQ_WR_S1B2;
1033   2            
1034   2          }else
1035   1           {
1036   2            Estado_expedidor= SEQ_RD_S1B0;
1037   2           }
1038   1           return Estado_expedidor;
1039   1      }
1040          
1041          void Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor)
1042          {
1043   1        static unsigned char buffer[28];
1044   1        //unsigned char j;
1045   1        /*la trama esta compuesta de
1046   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1047   1      
1048   1        buffer[0]=STX;
1049   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1050   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1051   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1052   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1053   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1054   1        
1055   1        //leo la fecha de entrada
1056   1        //Block_read_Clock_Hex(buffer+6);         
1057   1        
1058   1        buffer[6]=*(Atributos_Expedidor + fecha_Int_Ano)+0x030;             /*año de entrada*/
1059   1        buffer[7]=*(Atributos_Expedidor + fecha_Int_Mes)+0x030;         /*mes de entrada*/
1060   1        buffer[8]=*(Atributos_Expedidor + fecha_Int_Dia)+0x030;         /*dia de entrada*/
1061   1        buffer[9]=*(Atributos_Expedidor + fecha_Int_Hora)+0x030;          /*hora de entrada*/
1062   1        buffer[10]=*(Atributos_Expedidor + fecha_Int_Min)+0x030;          /*minutos de entrada*/
1063   1      
1064   1        /*placa*/
1065   1        if (rd_eeprom(0xa8,EE_CPRCN_ACTIVA)!=0)
1066   1        {   
1067   2          
1068   2            buffer[11]= placa[0];
1069   2            buffer[12]= placa[1];
1070   2            buffer[13]= placa[2];
1071   2            buffer[14]= placa[3];
1072   2            buffer[15]= placa[4];
1073   2            buffer[16]= placa[5];
1074   2      
1075   2        }
1076   1      
1077   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1078   1        {
1079   2          buffer[17]= 'C';
1080   2        }
1081   1        else
1082   1        {
1083   2          buffer[17]= 'M';
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 19  

1084   2        }
1085   1        
1086   1        buffer[18]= ETX;
1087   1        buffer[19]= 0;
1088   1        ready=0;
1089   1            while(busy==0);
1090   1          send_port(buffer,19);                         /*trama transmitida pto paralelo*/
1091   1          
1092   1            Debug_Dividir_texto();                                              /*division del texto */
1093   1            Debug_txt_Tibbo((unsigned char *) "Datos enviados pto paral=");       
1094   1            DebugBufferMF(buffer,19,0);   
1095   1            Debug_Dividir_texto();
1096   1      }
1097          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
1098          {
1099   1        unsigned char Estado_expedidor;
1100   1        unsigned char temp;
1101   1            if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
1102   1            {
1103   2              
1104   2                for (temp=0; temp<16; ++temp)
1105   2                {
1106   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
1107   3                 
1108   3                }
1109   2                
1110   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
1111   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);
1112   2                
1113   2        
1114   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
1115   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_0]));  
1116   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_1]));  
1117   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_2]));  
1118   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_3]));
1119   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1120   2                
1121   2              *(Atributos_Expedidor + Uid_0) = buffer_S_B [MF_UID_0];   
1122   2              *(Atributos_Expedidor + Uid_1) = buffer_S_B [MF_UID_1];     
1123   2              *(Atributos_Expedidor + Uid_2) = buffer_S_B [MF_UID_2];     
1124   2              *(Atributos_Expedidor + Uid_3) = buffer_S_B [MF_UID_3]; 
1125   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
1126   2            }   
1127   1            else
1128   1            {
1129   2              Estado_expedidor=SEQ_POWER_OFF;
1130   2            } 
1131   1            return Estado_expedidor;
1132   1      }
1133          
1134          unsigned char Validar_Pago()
1135          {
1136   1        unsigned char Estado_expedidor;
1137   1        unsigned char temp;
1138   1          temp=check_fechaOut(buffer_S_B+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1139   1              if(temp==1)
1140   1              {
1141   2                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n");
1142   2                  send_portERR(0xA2);                                                             /*error audio*/ 
1143   2                  send_portERR(0XE7);
1144   2                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 20  

             -y*/
1145   2                                                                                    /**leo el ticket*/  
1146   2                  Estado_expedidor=SEQ_RD_S1B0_EJECT;         
1147   2                              
1148   2              }
1149   1              else if (temp==2)
1150   1              {
1151   2                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1152   2                send_portERR(0xA2);                                                               /*error audio*/         
1153   2                send_portERR(0XE8);
1154   2                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1155   2                Estado_expedidor=SEQ_EXPULSAR_TARJ; 
1156   2              }
1157   1              else
1158   1              {
1159   2                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1160   2                                                                                                  /* Leo el ticket */
1161   2                Estado_expedidor=SEQ_RD_S1B0; 
1162   2              }
1163   1          return  Estado_expedidor;
1164   1      } 
1165          unsigned char Valida_Mismo_Dia(unsigned char *Atributos_Expedidor)
1166          {
1167   1        unsigned char day;
1168   1        unsigned char month;
1169   1        unsigned char year;
1170   1        unsigned char Valida_Mismo_Dia;
1171   1        /*miramos si sale el mismo dia*/
1172   1        Valida_Mismo_Dia = False;
1173   1        year  = bcd_hex(lee_clk(RANO));
1174   1        month = bcd_hex( lee_clk(RMES));
1175   1        day = bcd_hex(lee_clk(RDIA));
1176   1        
1177   1          if (((year == *(Atributos_Expedidor + fecha_Int_Ano)) && (month == *(Atributos_Expedidor + fecha_Int_Mes
             -)) && (day == *(Atributos_Expedidor + fecha_Int_Dia))))
1178   1          {
1179   2            Valida_Mismo_Dia = True;
1180   2          }
1181   1        
1182   1            return Valida_Mismo_Dia ;
1183   1      }
1184          void SecuenciaExpedidor(void)
1185          {
1186   1        unsigned char temp;
1187   1        unsigned int tiempo;
1188   1        unsigned char Estado_Tiempo[4];
1189   1        static unsigned char Atributos_Expedidor[18];
1190   1        static unsigned char buffer_S1_B0[17];
1191   1        unsigned char clock_temp[6];
1192   1        static unsigned char contador=0;
1193   1        unsigned char *atributos;
1194   1        switch (g_cEstadoComSeqMF)
1195   1        {
1196   2      //***********************************************************************************************
1197   2          
1198   2          case SEQ_INICIO:
1199   2      
1200   2            if (ValTimeOutCom==1)
1201   2            {
1202   3              
1203   3              Atascado=0;                                                                       /*activo el rele de reset del verificador*/   
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 21  

1204   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
1205   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
1206   3              
1207   3            }
1208   2       
1209   2          break;
1210   2      
1211   2      /*------------------------------------------------------------------------------
1212   2      Analizo la trama de insercion por boca
1213   2            (0) LA RESPUESTA ES OK
1214   2            (1) NO RESPONDE EL PTO SERIE
1215   2            (2) NO RECIBIDO LA TRAMA 
1216   2            (3) ERROR DE TRAMA CMD (N)
1217   2      ------------------------------------------------------------------------------*/      
1218   2          
1219   2          case SEQ_CARD_INSERCION:  
1220   2            
1221   2          if((temp=Trama_Validacion_P_N())!=0)
1222   2          {
1223   3            if(temp==2)
1224   3            {
1225   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
1226   4            } 
1227   3            else if (temp==3)
1228   3            {
1229   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
1230   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1231   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1232   4            }     
1233   3            else
1234   3            {
1235   4              /*Dispensador No Responde PTO SERIE ...*/
1236   4          
1237   4              if(temp=error_rx_pto()==0)
1238   4              {
1239   5                g_cEstadoComSeqMF=SEQ_CARD_INSERCION;
1240   5              }
1241   4              else if(temp=error_rx_pto()==1)
1242   4              {
1243   5                g_cEstadoComSeqMF=SEQ_INICIO;
1244   5              }
1245   4                                  
1246   4            }       
1247   3          }
1248   2          else
1249   2          {
1250   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
1251   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1252   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
1253   3          }     
1254   2            
1255   2          break;
1256   2            
1257   2      /*------------------------------------------------------------------------------
1258   2      chequeo el estado de los sensores 
1259   2      ------------------------------------------------------------------------------*/      
1260   2          
1261   2          case SEQ_CHECK_STATUS:  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 22  

1262   2                if (ValTimeOutCom==1)
1263   2            {       
1264   3              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
1265   3              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
1266   3            }
1267   2            break;      
1268   2              
1269   2      /*------------------------------------------------------------------------------
1270   2      Valido la informacion de los sensores
1271   2            (0) LA RESPUESTA ES OK
1272   2            (1) NO RESPONDE EL PTO SERIE
1273   2            (2) NO RECIBIDO LA TRAMA 
1274   2            (3) ERROR DE TRAMA CMD (N)
1275   2      ------------------------------------------------------------------------------*/    
1276   2      
1277   2          case SEQ_RTA_CARD_POS:
1278   2            
1279   2          if((temp=Trama_Validacion_P_N())!=0)
1280   2          {
1281   3            if(temp==2)
1282   3            {
1283   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
1284   4            } 
1285   3            else if (temp==3)
1286   3            {
1287   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n");                     /* trama no valida*/
1288   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
1289   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
1290   4            }     
1291   3            else
1292   3            {
1293   4              
1294   4              /*Dispensador No Responde PTO SERIE ...*/
1295   4          
1296   4              if(temp=error_rx_pto()==0)
1297   4              {
1298   5                g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;
1299   5              }
1300   4              else if(temp=error_rx_pto()==1)
1301   4              {
1302   5                g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
1303   5              }
1304   4            
1305   4            }
1306   3          }
1307   2          else
1308   2          {
1309   3            Debug_txt_Tibbo((unsigned char *) "CHECK STATUS OK\r\n");                                 /* trama valida Habilitado */
1310   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
1311   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
             - el mecanismo*/
1312   3                  {
1313   4                    
1314   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n");       /* trama valida Habi
             -litado insercion por boca*/
1315   4                    ValTimeOutCom=TIME_CARD;
1316   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
1317   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1318   4                    {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 23  

1319   5                      if(contador==0)                                                                   /*contador si es cero envia el msj a la pantala*/
1320   5                      { 
1321   6                        contador++;
1322   6                        Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor 
             -activo*/
1323   6                        send_portERR(0xA0);                                                                 /*audio ingrese tarjeta con rele*/
1324   6                        PantallaLCD(INGRESE);                                                             /*msj por raspberry "ingrese su tarjeta"*/
1325   6                                          
1326   6                      } else
1327   5                      {
1328   6                        contador++;                                                                       /*espera 20 ciclos para poder enviar msj nueva men
             -te*/
1329   6                        if (contador>= 20)contador=0;
1330   6                      } 
1331   5                    }else contador=0;
1332   4                    
1333   4                    
1334   4                  }
1335   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
1336   3                  {
1337   4                    
1338   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                      /* trama valida Habilitado i
             -nsercion por boca*/
1339   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1340   4                    //g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
1341   4                                           
1342   4                  }
1343   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
1344   3                  {
1345   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n");             /* trama valida Habil
             -itado insercion por boca*/
1346   4                                
1347   4                    
1348   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1349   4                    {
1350   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor ac
             -tivo*/
1351   5                    //Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF5
             -0*/
1352   5                                                                                                        /*tarjeta presente prioridad  */
1353   5                    g_cEstadoComSeqMF=SEQ_TIPO_CARD;//SEQ_REQUEST;                                                      /*vamos al siguiente paso 
             -a con validar el cmd*/    
1354   5                    }
1355   4                    else
1356   4                    {
1357   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n");              /* no hay vehiculo en el lo
             -op*/
1358   5                      send_portERR(0XE0);                                                               /*envio msj al PRINCIPAL lcd tarjeta*/
1359   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
1360   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
1361   5                      
1362   5                    }
1363   4                                                                  
1364   4                  }
1365   3                                                                    
1366   3          }     
1367   2            
1368   2          break;
1369   2        
1370   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 24  

1371   2      /*------------------------------------------------------------------------------
1372   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
1373   2      (1 0)  es una tarjeta valida Mf50 
1374   2      las demas combinaciones son tomadas como no validas
1375   2            (0) LA RESPUESTA ES OK
1376   2            (1) NO RESPONDE EL PTO SERIE
1377   2            (2) NO RECIBIDO LA TRAMA 
1378   2            (3) ERROR DE TRAMA CMD (N)    
1379   2      ------------------------------------------------------------------------------*/  
1380   2      
1381   2        case SEQ_REQUEST:
1382   2          
1383   2        if((temp=Trama_Validacion_P_N())!=0)
1384   2          {
1385   3            if(temp==2)
1386   3            {
1387   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
1388   4            } 
1389   3              else if (temp==3)
1390   3            {
1391   4              
1392   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n");                       /* trama no valida*/
1393   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
1394   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
1395   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
1396   4            } 
1397   3            else
1398   3            {
1399   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n");      /* pto serie no res
             -ponde*/
1400   4              send_portERR(0XE1);                                                                       /*la tarjeta no es valida no la puede identif
             -icar*/
1401   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1402   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
1403   4            
1404   4            }       
1405   3          }
1406   2          else
1407   2          {
1408   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
1409   3                    {
1410   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
1411   4                        {
1412   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
1413   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
1414   5                          //LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tr
             -ansporte
1415   5                          g_cEstadoComSeqMF=SEQ_UID;  //SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
1416   5                          
1417   5                       }else
1418   4                        {
1419   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
1420   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
1421   5                        send_portERR(0xA2);                                                             /*error audio*/ 
1422   5                        send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
1423   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 25  

1424   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
1425   5                         
1426   5                        }
1427   4                   }
1428   3                    else 
1429   3                    {
1430   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
1431   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
1432   4                    send_portERR(0xA2);                                                             /*error audio*/ 
1433   4                    send_portERR(0xe1);                                                     //la tarjeta no es valida 
1434   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1435   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
1436   4                  
1437   4                    }
1438   3                                                                                                            /*respuesta ok inicia revisando sensores*/
1439   3          }     
1440   2                
1441   2            break;
1442   2      /*------------------------------------------------------------------------------
1443   2      Verifica la eeprom 
1444   2            (0) LA RESPUESTA ES OK
1445   2            (1) NO RESPONDE EL PTO SERIE
1446   2            (2) NO RECIBIDO LA TRAMA 
1447   2            (3) ERROR DE TRAMA CMD (N)
1448   2      ------------------------------------------------------------------------------*/  
1449   2        case SEQ_MF_LINTECH:
1450   2          
1451   2        if((temp=Trama_Validacion_P_N())!=0)
1452   2          {
1453   3            if(temp==2)
1454   3            {
1455   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1456   4            }
1457   3            else if (temp==3)
1458   3            {
1459   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1460   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1461   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1462   4            }       
1463   3            else
1464   3            { 
1465   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1466   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1467   4            }
1468   3          }
1469   2          else
1470   2          {
1471   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n");                       /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1472   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1473   3                                                                                                      /*leo MF */
1474   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1475   3          }     
1476   2      
1477   2        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 26  

1478   2        break;
1479   2      /*------------------------------------------------------------------------------
1480   2      Leo la Mf en el sector 1  bloque 1
1481   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1482   2      ------------------------------------------------------------------------------*/    
1483   2      
1484   2        case SEQ_RD_S1B1:
1485   2          
1486   2          RD_MF(1,1);                                                                                 /*leo MF */
1487   2          g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA; 
1488   2        
1489   2        break;
1490   2      /*------------------------------------------------------------------------------
1491   2      Analiso lo leido en Mf en el sector 1  bloque 1
1492   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1493   2      ------------------------------------------------------------------------------*/      
1494   2        
1495   2        case SEQ_RD_S1B1_RPTA:
1496   2          
1497   2          if((temp=Trama_Validacion_P_N())!=0)
1498   2          {
1499   3            if(temp==2)
1500   3            {
1501   4            g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;                                                           /*no ha respondido*/
1502   4            }
1503   3            else if (temp==3)
1504   3            {
1505   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1506   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1507   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1508   4            }       
1509   3            else
1510   3            { 
1511   4              
1512   4                /*Dispensador No Responde PTO SERIE ...*/
1513   4          
1514   4              if(temp=error_rx_pto()==0)
1515   4              {
1516   5                g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;
1517   5              }
1518   4              else if(temp=error_rx_pto()==1)
1519   4              {
1520   5                g_cEstadoComSeqMF=SEQ_RD_S1B1;;
1521   5              }
1522   4                                                              /* respuesta incorrecta*/
1523   4            }
1524   3          }
1525   2          else
1526   2          {
1527   3            g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque1(Atributos_Expedidor);
1528   3          }     
1529   2        break;
1530   2      /*------------------------------------------------------------------------------
1531   2      Leo la Mf en el  sector 1 bloque 2
1532   2        Se lee Fecha in, fecha out
1533   2      ------------------------------------------------------------------------------*/    
1534   2        case SEQ_RD_S1B2: 
1535   2        
1536   2        RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1537   2        g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 27  

1538   2        break;  
1539   2          
1540   2      /*------------------------------------------------------------------------------
1541   2      ANALIZO LO LEIDO  Mf en el  sector 1 bloque 2
1542   2        Se lee Fecha in, fecha out
1543   2      ------------------------------------------------------------------------------*/
1544   2        case SEQ_RD_S1B2_RPTA:
1545   2              
1546   2        if((temp=Trama_Validacion_P_N())!=0)
1547   2          {
1548   3            if(temp==2)
1549   3            {
1550   4            g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;                                                           /*no ha respondido*/
1551   4            }
1552   3            else if (temp==3)
1553   3            {
1554   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta falla en la escritura de la clave*/
1555   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1556   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1557   4            }       
1558   3            else
1559   3            { 
1560   4                /*Dispensador No Responde PTO SERIE ...*/
1561   4          
1562   4              if(temp=error_rx_pto()==0)
1563   4              {
1564   5                g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1565   5              }
1566   4              else if(temp=error_rx_pto()==1)
1567   4              {
1568   5                g_cEstadoComSeqMF=SEQ_RD_S1B2;
1569   5              }
1570   4                                                                  
1571   4            }
1572   3          }
1573   2          else
1574   2          {
1575   3           g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor);
1576   3        
1577   3          }
1578   2          break;
1579   2        case SEQ_ROTACION:
1580   2          
1581   2            
1582   2            /*------------------------------------------------------------------------------  
1583   2            sinc0bro  por  programacion
1584   2          ------------------------------------------------------------------------------*/  
1585   2            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1586   2            {
1587   3              if (SIN_COBRO==1)
1588   3              {
1589   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1590   4                                                                                                    
1591   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
1592   4                break;
1593   4              }
1594   3              else if( SIN_COBRO ==2)
1595   3              {
1596   4                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 28  

1597   4                        
1598   4          
1599   4                if ((buffer_S_B[0]==clock_temp[0])&&(buffer_S_B[1]==clock_temp[1])&&(buffer_S_B[2]==clock_temp[2]))   
             -/*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1600   4                {
1601   5                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1602   5                                                                                                                            /* Leo el ticket */
1603   5                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1604   5                  break;
1605   5                }                                                                                         
1606   4                  else
1607   4                  {
1608   5                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n");                                             /*excede el timepo d
             -e gracia del dia */
1609   5                  send_portERR(0XE8);
1610   5                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1611   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1612   5                  break;              
1613   5                  }
1614   4                
1615   4                
1616   4              }
1617   3            }
1618   2      /*------------------------------------------------------------------------------
1619   2          validacion descuentos  se maneja en 2 posiciones de memoria del MF
1620   2            MF_LSB= tipo de descuento       
1621   2      ------------------------------------------------------------------------------*/      
1622   2            else if(buffer_S_B[MF_LSB]!=0)
1623   2            {
1624   3              
1625   3             if((rd_eeprom(0xa8,EE_DCTO_PASA_CAJA))!= 0)  
1626   3            {
1627   4              Debug_Dividir_texto();
1628   4              Debug_txt_Tibbo((unsigned char *) "CODIGO DE DCTO: ");                                                      /*codigo de descuento
             - es elnumero de descuento del cliente*/
1629   4              Debug_chr_Tibbo(buffer_S_B[MF_LSB]);
1630   4              Debug_txt_Tibbo((unsigned char *) "\r\n");  
1631   4              /*parte alta del tiempo libre*/
1632   4              temp=(buffer_S_B[MF_IN_PAGO]&0x70)>>4 ;                                                                   /*se lee la parte alta del ti
             -empo libre y se rotsa 4 bits a la derecha*/
1633   4              tiempo=temp;                                                                                                /*se carga en un entero*/
1634   4              tiempo=(tiempo <<8) | buffer_S_B[MF_DCTO] ;                                                               /*MF_DCTO= tiene la parte b
             -aja del tiempo libre, se une la parte alta con la baja */
1635   4                                                                                                                          /*creando un int del tiemo de dcto*/
1636   4              Debug_txt_Tibbo((unsigned char *) "TIEMPO DE DCTO: ");
1637   4              sprintf( Estado_Tiempo,"%u",tiempo);                                                                        /*se muestra el tiempo de desc
             -uento*/
1638   4              Debug_txt_Tibbo((unsigned char *)Estado_Tiempo);
1639   4              Debug_txt_Tibbo((unsigned char *) "\r\n");
1640   4              Debug_Dividir_texto();  
1641   4              
1642   4            /*tipo de descuento es el bit 8 de MF_IN_PAGO*/ 
1643   4            /*por fecha que es fijar fecha de salida*/
1644   4                if ((buffer_S_B[MF_IN_PAGO]&0x80)==0)                                                                   /*tipo de descuento por fecha 
             -de salida*/
1645   4                {
1646   5                Debug_txt_Tibbo((unsigned char *) "DCTO FIJA FECHA DE OUT: ");                                            /**/
1647   5                analiza_tiempo(buffer_S_B,tiempo); 
1648   5              /*fijar fecha de salida*/
1649   5                }
1650   4                else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 29  

1651   4                {
1652   5                  if (tiempo== 0x64)                                                                                  /*tipo de dcto por porcentaje al 100 %*/
1653   5                  {
1654   6                    Debug_txt_Tibbo((unsigned char *) "DCTO PORCENTAJE 100% ");
1655   6                    Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1656   6                                                                                                                      /* Leo el ticket */
1657   6                    g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                    /**/                                              
1658   6                    break;              
1659   6                  }
1660   5                  else
1661   5                  {
1662   6                    Debug_txt_Tibbo((unsigned char *) "DCTO NO EL 100%: ");
1663   6                    send_portERR(ACERQUESE_CAJA); 
1664   6                    PantallaLCD(DIRIJASE_CAJA); 
1665   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                
1666   6                  }             
1667   5                }
1668   4            }
1669   3          }
1670   2        /*------------------------------------------------------------------------------  
1671   2            tiempo de gracia
1672   2          T_GRACIA=1 tiene tiempo de gracia 
1673   2          ------------------------------------------------------------------------------*/  
1674   2            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1675   2            {
1676   3              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1677   3              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1678   3              Debug_txt_Tibbo((unsigned char *) "\r\n");    
1679   3              analiza_tiempo(buffer_S_B,T_GRACIA);                                                // Simula Fecha Max de Salida.
1680   3            
1681   3            }
1682   2          /*------------------------------------------------------------------------------  
1683   2          comun para todos
1684   2          ------------------------------------------------------------------------------*/    
1685   2            g_cEstadoComSeqMF=Validar_Pago();
1686   2            
1687   2            
1688   2        break;
1689   2        case SEQ_MENSUAL:
1690   2          
1691   2        /*valida si esta programdo el horario y si esta en el rango*/
1692   2        if (Horarios(Atributos_Expedidor [Horario]) == True)
1693   2        {
1694   3          /*cheque la fecha de expiracion del mensual*/
1695   3          atributos = &Atributos_Expedidor [Expira_ano];//;buffer_S1_B1[MF_EXPIRA_ANO];
1696   3          
1697   3          if ( check_fechaOut_2(atributos) == True )
1698   3            {
1699   4                /*valida que la salida sea el mismo dia*/
1700   4              if( Valida_Mismo_Dia(Atributos_Expedidor) == True)
1701   4              {
1702   5                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1703   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1704   5              }
1705   4              else
1706   4              {
1707   5              Debug_txt_Tibbo((unsigned char *) "SALIDA NO ES EL MISMO DIA \r\n");  
1708   5              g_cEstadoComSeqMF = Validar_Pago();
1709   5              } 
1710   4              
1711   4            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 30  

1712   3              else 
1713   3              {
1714   4              send_portERR(PRMR_TARJETA_VENCIDA); 
1715   4                  
1716   4              PantallaLCD(TARJETA_VENCIDA);
1717   4              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1718   4              g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1719   4              
1720   4              }
1721   3        }
1722   2        else
1723   2          {
1724   3            if(Horarios(Atributos_Expedidor [Horario])==0)
1725   3            {
1726   4              /*cheque la fecha de expiracion del mensual*/
1727   4              atributos = &Atributos_Expedidor [Expira_ano];//;buffer_S1_B1[MF_EXPIRA_ANO];
1728   4              if ( check_fechaOut_2(atributos) == True )
1729   4              {
1730   5              Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA HORARIO 0\r\n");  
1731   5              g_cEstadoComSeqMF=SEQ_RD_S1B0;
1732   5              }
1733   4              else
1734   4              {
1735   5              send_portERR(PRMR_TARJETA_VENCIDA); 
1736   5              PantallaLCD(TARJETA_VENCIDA);
1737   5              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1738   5              g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1739   5              }
1740   4          }
1741   3          else
1742   3            {
1743   4            g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1744   4            }
1745   3          }
1746   2            break;
1747   2        case SEQ_RD_S1B0:
1748   2            
1749   2            RD_MF(1, 0);                                                                    /* Leo el ticket */
1750   2            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1751   2        break;
1752   2      /*------------------------------------------------------------------------------
1753   2      Leo la Mf en el  sector 1 bloque 0
1754   2          lee el ticket
1755   2      ------------------------------------------------------------------------------*/    
1756   2          
1757   2        case SEQ_RD_S1B0_RPTA:
1758   2        
1759   2        if((temp=Trama_Validacion_P_N())!=0)
1760   2          {
1761   3            if(temp==2)
1762   3            {
1763   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;                                                           /*no ha respondido*/
1764   4            }
1765   3            else if (temp==3)
1766   3            {
1767   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1768   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1769   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1770   4            }       
1771   3            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 31  

1772   3            { 
1773   4              /*Dispensador No Responde PTO SERIE ...*/
1774   4          
1775   4              if(temp=error_rx_pto()==0)
1776   4              {
1777   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1778   5              }
1779   4              else if(temp=error_rx_pto()==1)
1780   4              {
1781   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1782   5              }                                                       /* respuesta incorrecta*/
1783   4            }
1784   3          }
1785   2          else
1786   2          {
1787   3            g_cEstadoComSeqMF=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Atributos_Expedidor);
1788   3        
1789   3          }
1790   2        break;
1791   2      
1792   2            
1793   2      /*------------------------------------------------------------------------------
1794   2      envio a escribir en  la Mf en el  sector 1 bloque 2
1795   2          
1796   2      ------------------------------------------------------------------------------*/    
1797   2        case SEQ_WR_S1B2:
1798   2        
1799   2              
1800   2              WR_MF(1, 2,Atributos_Expedidor);//buffer_S_B+MF_TIPO_VEHICULO
1801   2              g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1802   2            
1803   2        break;
1804   2      /*------------------------------------------------------------------------------
1805   2      espero la respuesta de la escritura en  la Mf en el  sector 1 bloque 2
1806   2          
1807   2      ------------------------------------------------------------------------------*/  
1808   2        case SEQ_WR_S1B2_RPTA:
1809   2          if((temp=Trama_Validacion_P_N())!=0)
1810   2          {
1811   3            if(temp==2)
1812   3            {
1813   4            g_cEstadoComSeqMF= SEQ_WR_S1B2_RPTA;                                                            /*no ha respondido*/
1814   4            }
1815   3            else if (temp==3)
1816   3            {
1817   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1818   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1819   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1820   4            }       
1821   3            else
1822   3            { 
1823   4              
1824   4                /*Dispensador No Responde PTO SERIE ...*/
1825   4          
1826   4              if(temp=error_rx_pto()==0)
1827   4              {
1828   5                g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1829   5              }
1830   4              else if(temp=error_rx_pto()==1)
1831   4              {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 32  

1832   5                g_cEstadoComSeqMF=SEQ_WR_S1B2;
1833   5              }         
1834   4              
1835   4              
1836   4            
1837   4            }
1838   3          }
1839   2          else
1840   2          {
1841   3          
1842   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1843   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1844   3            g_cEstadoComSeqMF=SEQ_WR_S2B0;  
1845   3          }
1846   2          break;
1847   2        case SEQ_WR_S2B0:
1848   2          WR_MF(2, 0,buffer_S_B+MF_TIPO_VEHICULO);//s1b2
1849   2        
1850   2          g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA; 
1851   2          break;
1852   2        
1853   2        
1854   2        case SEQ_WR_S2B0_RPTA:
1855   2      
1856   2        if((temp=Trama_Validacion_P_N())!=0)
1857   2          {
1858   3            if(temp==2)
1859   3            {
1860   4            g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;                                                           /*no ha respondido*/
1861   4            }
1862   3            else if (temp==3)
1863   3            {
1864   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n");                            /* trama no valida respuesta 
             -incorrecta el leer el bloque*/
1865   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1866   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1867   4            }       
1868   3            else
1869   3            { 
1870   4                  /*Dispensador No Responde PTO SERIE ...*/
1871   4          
1872   4              if(temp=error_rx_pto()==0)
1873   4              {
1874   5                g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;
1875   5              }
1876   4              else if(temp=error_rx_pto()==1)
1877   4              {
1878   5                g_cEstadoComSeqMF=SEQ_WR_S2B0;
1879   5              }         
1880   4          
1881   4                  
1882   4            }
1883   3          }
1884   2          else
1885   2          {
1886   3          
1887   3            /*capturo la tarjeta*/
1888   3            lock=1;   
1889   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n");                             /* trama OK CARGA numero de tic
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 33  

             -ket*/
1890   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1891   3            send_portERR(0xA1);                                                                         /*audio gracias*/ 
1892   3            send_portERR(0XFF);
1893   3            PantallaLCD(GRACIAS); 
1894   3        
1895   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n");                              /* pto serie no responde*/
1896   3            
1897   3          if (Atributos_Expedidor [ Tipo_Tarjeta]!= MENSUALIDAD)  
1898   3            {
1899   4                  
1900   4            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1901   4            }
1902   3            else
1903   3            {
1904   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1905   4            }
1906   3          }
1907   2          break;
1908   2          
1909   2          case SEQ_RTA_CAPTURE:
1910   2            
1911   2            Mov_Card(MovPos_Capture); 
1912   2            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;
1913   2            prto_ready=1;                                                       /*le da prioridad a la respuesta de la captura de tarjeta*/
1914   2            break;
1915   2      /*------------------------------------------------------------------------------
1916   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1917   2            (0) LA RESPUESTA ES OK
1918   2            (1) NO RESPONDE EL PTO SERIE
1919   2            (2) NO RECIBIDO LA TRAMA 
1920   2            (3) ERROR DE TRAMA CMD (N)
1921   2      ------------------------------------------------------------------------------*/  
1922   2      
1923   2        case SEQ_RTA_CAPTURE_RPTA:
1924   2          
1925   2          if((temp=Trama_Validacion_P_N())!=0)
1926   2          {
1927   3            if(temp==2)
1928   3            {
1929   4              
1930   4                if (ValidaSensores_Out()==1)
1931   4              {
1932   5                lock=0;
1933   5                Debug_txt_Tibbo((unsigned char *) "rele off\r\n");                          /* trama ok la tarjeta fue ejectada*/
1934   5              
1935   5              }
1936   4            
1937   4                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;     
1938   4              
1939   4              
1940   4            } 
1941   3              else if (temp==3)
1942   3            {
1943   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n");                   /* Tama incorrecta no ejecta l
             -a tarjeta*/
1944   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1945   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1946   4            } 
1947   3            else
1948   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 34  

1949   4                    /*Dispensador No Responde PTO SERIE ...*/
1950   4            
1951   4            
1952   4          
1953   4              
1954   4                if(temp=error_rx_pto()==0)
1955   4                {
1956   5                  g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;   
1957   5                }
1958   4                else if(temp=error_rx_pto()==1)
1959   4                {
1960   5                  
1961   5                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1962   5                }         
1963   4          
1964   4              
1965   4            
1966   4            }       
1967   3          }
1968   2          else
1969   2          {
1970   3                    
1971   3            prto_ready=0;
1972   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1973   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1974   3            
1975   3            lock=0;
1976   3            ValTimeOutCom=3;    
1977   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                   //SEQ_INICIO;                                                     /*respuesta ok ini
             -cia revisando sensores*/
1978   3                                                          
1979   3          }     
1980   2            
1981   2      
1982   2          break;
1983   2          
1984   2      
1985   2      
1986   2      case SEQ_RD_S1B0_EJECT: 
1987   2          RD_MF(1, 0);                                                                      /**leo el ticket*/  
1988   2          g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA; 
1989   2        break;  
1990   2      /*------------------------------------------------------------------------------
1991   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1992   2      LA tarjeta no tiene pago    
1993   2        
1994   2      ------------------------------------------------------------------------------*/
1995   2        
1996   2        
1997   2        case SEQ_RD_S1B0_EJECT_RPTA:  
1998   2          
1999   2          if((temp=Trama_Validacion_P_N())!=0)
2000   2          {
2001   3            if(temp==2)
2002   3            {
2003   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;                                                           /*no ha respondido*/
2004   4            }
2005   3            else if (temp==3)
2006   3            {
2007   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 35  

2008   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
2009   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
2010   4            }       
2011   3            else
2012   3            { 
2013   4                  /*Dispensador No Responde PTO SERIE ...*/
2014   4          
2015   4              if(temp=error_rx_pto()==0)
2016   4              {
2017   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;
2018   5              }
2019   4              else if(temp=error_rx_pto()==1)
2020   4              {
2021   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;
2022   5              }         
2023   4                                                  /* respuesta incorrecta*/
2024   4            }
2025   3          }
2026   2          else
2027   2          {
2028   3            
2029   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n");                              /* trama OK CARGA numero d
             -e ticket*/
2030   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/    
2031   3            
2032   3        for (temp=0; temp<16; temp++)
2033   3            {
2034   4              
2035   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
2036   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
2037   4              {
2038   5                break;
2039   5              }
2040   4            }
2041   3            DebugBufferMF(buffer_S1_B0,16,RESPUESTA); 
2042   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S_B,'P');    
2043   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
2044   3          } 
2045   2            break;
2046   2        case SEQ_UID:
2047   2          Unique_Identifier_UID();
2048   2        g_cEstadoComSeqMF = SEQ_UID_RPTA;
2049   2        break;
2050   2        case SEQ_UID_RPTA:
2051   2            if((temp=Trama_Validacion_P_N())!=0)
2052   2          {
2053   3            if(temp==2)
2054   3            {
2055   4            g_cEstadoComSeqMF=SEQ_UID_RPTA;                                                       /*no ha respondido*/
2056   4            } 
2057   3            else if (temp==3)
2058   3            {
2059   4            Debug_txt_Tibbo((unsigned char *) "SEQ_UID_RPTA FALLO\r\n");                      /* trama no valida*/
2060   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2061   4            g_cEstadoComSeqMF=SEQ_UID;                                                          /* (3) Trama invalida cmd (N)*/ 
2062   4            }     
2063   3            else
2064   3            {
2065   4              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 36  

2066   4              /*Dispensador No Responde PTO SERIE ...*/
2067   4          
2068   4              if(temp=error_rx_pto()==0)
2069   4              {
2070   5                g_cEstadoComSeqMF=SEQ_UID_RPTA;
2071   5              }
2072   4              else if(temp=error_rx_pto()==1)
2073   4              {
2074   5                g_cEstadoComSeqMF=SEQ_UID;
2075   5              }
2076   4            
2077   4            }
2078   3          }
2079   2          else
2080   2          {
2081   3            g_cEstadoComSeqMF = Analiza_Uid_Card(Atributos_Expedidor );
2082   3          }
2083   2          break;
2084   2        case SEQ_LOAD_PASSWORD:
2085   2          LoadVerify_EEprom();
2086   2          g_cEstadoComSeqMF=SEQ_MF_LINTECH;   
2087   2          break;
2088   2        case SEQ_POWER_OFF:
2089   2          Power_off();
2090   2          g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;
2091   2          break;
2092   2        case SEQ_POWER_OFF_RPTA:
2093   2          if((temp=Trama_Validacion_P_N())!=0)
2094   2          {
2095   3            if(temp==2)
2096   3            {
2097   4            g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;                                                       /*no ha respondido*/
2098   4            } 
2099   3            else if (temp==3)
2100   3            {
2101   4            Debug_txt_Tibbo((unsigned char *) "SEQ_POWER_OFF_RPTA  FALLO\r\n");                     /* trama no valida*/
2102   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2103   4            g_cEstadoComSeqMF=SEQ_POWER_OFF;                                                          /* (3) Trama invalida cmd (N)*/ 
2104   4            }     
2105   3            else
2106   3            {
2107   4              
2108   4              /*Dispensador No Responde PTO SERIE ...*/
2109   4          
2110   4              if(temp=error_rx_pto()==0)
2111   4              {
2112   5                g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;
2113   5              }
2114   4              else if(temp=error_rx_pto()==1)
2115   4              {
2116   5                g_cEstadoComSeqMF=SEQ_POWER_OFF;
2117   5              }
2118   4            
2119   4            }
2120   3          }
2121   2          else
2122   2          {
2123   3            g_cEstadoComSeqMF=SEQ_UID;
2124   3          }
2125   2          break;
2126   2        case SEQ_POWER_ON:
2127   2          Power_off();
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 37  

2128   2        g_cEstadoComSeqMF = SEQ_POWER_ON_RPTA;
2129   2          break;
2130   2        case SEQ_POWER_ON_RPTA:
2131   2            if((temp=Trama_Validacion_P_N())!=0)
2132   2          {
2133   3            if(temp==2)
2134   3            {
2135   4            g_cEstadoComSeqMF=SEQ_POWER_ON_RPTA;                                                        /*no ha respondido*/
2136   4            } 
2137   3            else if (temp==3)
2138   3            {
2139   4            Debug_txt_Tibbo((unsigned char *) "SEQ_POWER_ON_RPTA  FALLO\r\n");                      /* trama no valida*/
2140   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2141   4            g_cEstadoComSeqMF=SEQ_POWER_ON;                                                         /* (3) Trama invalida cmd (N)*/ 
2142   4            }     
2143   3            else
2144   3            {
2145   4              
2146   4              /*Dispensador No Responde PTO SERIE ...*/
2147   4          
2148   4              if(temp=error_rx_pto()==0)
2149   4              {
2150   5                g_cEstadoComSeqMF=SEQ_POWER_ON_RPTA;
2151   5              }
2152   4              else if(temp=error_rx_pto()==1)
2153   4              {
2154   5                g_cEstadoComSeqMF=SEQ_POWER_ON;
2155   5              }
2156   4            
2157   4            }
2158   3          }
2159   2          else
2160   2          {
2161   3            g_cEstadoComSeqMF=SEQ_LOAD_PASSWORD;
2162   3          }
2163   2          break;
2164   2        case SEQ_TIPO_CARD:
2165   2          Aut_Card_check_Status();
2166   2          g_cEstadoComSeqMF=SEQ_REQUEST;            
2167   2          break;
2168   2      /*------------------------------------------------------------------------------
2169   2      expulsa la tarjeta por que no pertenece a MF50
2170   2      ------------------------------------------------------------------------------*/    
2171   2        
2172   2        case SEQ_EXPULSAR_TARJ:
2173   2            Card_Insercion(Inhabilita); 
2174   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
2175   2        break;
2176   2        
2177   2        
2178   2        case SEQ_EXPULSAR_CHECK:
2179   2        if((temp=Trama_Validacion_P_N())!=0)
2180   2          {
2181   3            if(temp==2)
2182   3            {
2183   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
2184   4            }
2185   3            else if (temp==3)
2186   3            {
2187   4              
2188   4                g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
2189   4            }       
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 38  

2190   3            else
2191   3            { 
2192   4                  /*Dispensador No Responde PTO SERIE ...*/
2193   4          
2194   4              if(temp=error_rx_pto()==0)
2195   4              {
2196   5                g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
2197   5              }
2198   4              else if(temp=error_rx_pto()==1)
2199   4              {
2200   5                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
2201   5              }         
2202   4                                                
2203   4            }
2204   3                                                                                
2205   3          }
2206   2          else
2207   2          {
2208   3            lock=0;
2209   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
2210   3          }   
2211   2          
2212   2          break;
2213   2          
2214   2        case SEQ_EXPULSAR:
2215   2          Mov_Card(MovPos_EjectFront);
2216   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
2217   2        
2218   2        case SEQ_EXPULSAR_FROM:                       
2219   2          if((temp=Trama_Validacion_P_N())!=0)
2220   2          {
2221   3            if(temp==2)
2222   3            {
2223   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
2224   4            } 
2225   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
2226   3          }
2227   2          else
2228   2          {
2229   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
2230   3          }   
2231   2          
2232   2        break;
2233   2        
2234   2      /*------------------------------------------------------------------------------
2235   2      expulsa la tarjeta por que no pertenece a MF50
2236   2      ------------------------------------------------------------------------------*/      
2237   2          
2238   2              default:
2239   2              g_cEstadoComSeqMF=SEQ_INICIO; 
2240   2              break;  
2241   2            
2242   2        } 
2243   1      }
2244          
2245          
2246            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6212    ----
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/02/2020 15:54:40 PAGE 39  

   CONSTANT SIZE    =   1888    ----
   XDATA SIZE       =    102      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
