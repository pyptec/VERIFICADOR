C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include "verificador.h"
   5          #include <reg51.h>
   6          #include <string.h>
   7          
   8          /*funciones prototipo externas */
   9          
  10          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  11          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  12          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  13          extern void Debug_txt_Tibbo(unsigned char * str);
  14          extern unsigned char  ValidaSensoresPaso(void);
  15          extern void send_portERR(unsigned char cod_err);
  16          extern void Debug_chr_Tibbo(unsigned char Dat);
  17          extern void Debug_HexDec(unsigned char xfc);
  18          extern char check_fechaOut(char *buffer);
  19          extern unsigned char Dir_board();
  20          extern void PantallaLCD(unsigned char cod_msg);
  21          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B);
  23          
  24          
  25          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  26          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  27          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  28          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  29          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  30          
  31          extern void Inicializa(unsigned char TipoMovimiento);
  32          extern void Check_Status(unsigned char Detalle);
  33          extern void Aut_Card_check_Status(void);
  34          extern void Mov_Card(unsigned char Posicion);
  35          extern void SecuenciaExpedidor(void);
  36          extern void Card_Insercion(char Tipo);
  37          extern void Dwload_EEprom (void);
  38          extern void LoadVerify_EEprom(void);
  39          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  40          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);
  41          extern int sprintf  (char *, const char *, ...);
  42          extern void Debug_Dividir_texto();
  43          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  44          extern void Delay_1ms(unsigned int cnt);
  45          extern void Delay_10ms(unsigned int cnt);
  46          extern unsigned char  ValidaSensores_Out(void);
  47          extern char  *strcpy  (char *s1, const char *s2);
  48          extern char lee_clk (unsigned char dir_clk);
  49          extern char check_fechaOut_2(unsigned char *buffer); 
  50          extern void Unique_Identifier_UID(void);
  51          extern void Power_off(void);
  52          extern void  send_port(unsigned char *buffer_port, unsigned char length_char);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 2   

  53          
  54          /*funcion prototipo programacion*/
  55          extern unsigned char *Addr_Horarios();
  56          
  57          sbit lock = P1^7;           //Relevo  
  58          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  59          sbit led_err_imp = P0^2;      //Error 
  60          sbit busy = P3^3;           /*bussy de Entrada Interrupcion del Procesador principal      */
  61          sbit ready = P3^2;          //Salida. solicitud envio Datos   
  62          /*variables externas*/
  63          extern bit aSk;
  64          extern unsigned char g_cEstadoComSoft;
  65          extern unsigned char ValTimeOutCom;
  66          extern unsigned char g_cEstadoComSeqMF;
  67          extern unsigned char g_cContByteRx;
  68          extern unsigned char xdata Buffer_Rta_Lintech[];
  69          extern idata unsigned char rbuf [];
  70          extern int ID_CLIENTE;
  71          extern int COD_PARK;
  72          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  73          extern unsigned char Timer_wait;
  74          extern unsigned int  SIN_COBRO;
  75          extern unsigned char error_rx;
  76          unsigned char buffer_S_B[17];
  77          extern idata unsigned char placa[];
  78          
  79          /*externo bit*/
  80          
  81          extern bit buffer_ready;
  82          extern bit prto_ready;
  83          extern unsigned char USE_LPR;
  84          
  85          /*----------------------------------------------------------------------------
  86          Definiciones de sequencias de verificador y expedidor
  87          ------------------------------------------------------------------------------*/
  88          
  89          #define SEQ_INICIO            0X00  
  90          #define SEQ_CARD_INSERCION    0X01
  91          #define SEQ_CHECK_STATUS      0X02
  92          #define SEQ_RTA_CARD_POS      0x03
  93          #define SEQ_RTA_CAPTURE       0X04
  94          #define SEQ_RTA_CAPTURE_RPTA  0x05
  95          #define SEQ_REQUEST           0x06
  96          #define SEQ_MF_LINTECH        0x07
  97          #define SEQ_RD_S1B1           0x08
  98          #define SEQ_RD_S1B1_RPTA      0x09
  99          #define SEQ_RD_S1B2           0x0a
 100          #define SEQ_RD_S1B2_RPTA      0x0b
 101          #define SEQ_RD_S1B0           0x0c
 102          #define SEQ_RD_S1B0_RPTA      0x0d
 103          #define SEQ_WR_S1B2           0x0e
 104          #define SEQ_WR_S1B2_RPTA      0x0f
 105          
 106          #define SEQ_WR_S2B0           0x10
 107          #define SEQ_WR_S2B0_RPTA      0X11
 108          #define SEQ_RD_S1B0_EJECT     0x12
 109          #define SEQ_RD_S1B0_EJECT_RPTA      0x13
 110          //#define SEQ_TIPO_TARJETAS 0X14
 111          #define SEQ_ROTACION      0X15
 112          #define SEQ_MENSUAL       0X16
 113          #define SEQ_LOAD_PASSWORD 0X17
 114          #define SEQ_UID           0X18
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 3   

 115          #define SEQ_UID_RPTA        0x19
 116          #define SEQ_POWER_OFF     0X1a
 117          #define SEQ_POWER_OFF_RPTA      0X1B
 118          #define SEQ_POWER_ON      0X1C
 119          #define SEQ_POWER_ON_RPTA   0X1D
 120          #define SEQ_TIPO_CARD     0X1E
 121          
 122          #define SEQ_EXPULSAR_TARJ     0x20
 123          #define SEQ_EXPULSAR_CHECK    0x21
 124          #define SEQ_EXPULSAR          0x22
 125          #define SEQ_EXPULSAR_FROM     0x23
 126          
 127          
 128          /*----------------------------------------------------------------------------
 129           definiciones de lintech en la inicializacion de expedidor o verificador
 130          ------------------------------------------------------------------------------*/
 131          
 132          #define INICIA_LINTECH          0x30
 133          #define SEQ_CAPTURE_DATOS_INI   0x31
 134          #define GRABA_EEPROM            0x32
 135          #define SEQ_CAPTURA_OK_EEPROM   0X33
 136          #define FIN_OK                  0x00
 137          
 138          #define True                    0x01
 139          #define False                   0x00
 140          
 141          /*----------------------------------------------------------------------------
 142           definiciones de lintech en el comando Check_Status
 143          ------------------------------------------------------------------------------*/
 144          
 145          #define S_DETAIL        0x31
 146          #define S_NORMAL        0x30
 147          
 148          /*------------------------------------------------------------------------------
 149           definiciones de lintech en el comando Card_Insercion
 150          ------------------------------------------------------------------------------*/
 151          
 152          #define Habilita        0x30
 153          #define Inhabilita      0x31
 154          
 155          /*------------------------------------------------------------------------------
 156          Definicion de Lintech en el comando Inicializa
 157          ------------------------------------------------------------------------------*/
 158          
 159          #define TO_FRONT        '0'
 160          #define CAPTURE_BOX     '1'
 161          #define SIN_MOVIMIENTO  '3'
 162          
 163          /*------------------------------------------------------------------------------
 164          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 165          ------------------------------------------------------------------------------*/
 166          
 167          #define   MovPos_Front        '0'   
 168          #define   MovPos_IC           '1'
 169          #define   MovPos_RF           '2'
 170          #define   MovPos_Capture      '3'
 171          #define   MovPos_EjectFront   '9'
 172          
 173          /*------------------------------------------------------------------------------
 174          Definicion de la trama Lintech de las respuestas de los cmd
 175          ------------------------------------------------------------------------------*/
 176          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 4   

 177          #define Pos_TipoResp        4
 178          #define Pos_Length          3
 179          #define Pos_St0             7
 180          #define Pos_St1             8
 181          #define Pos_St2             9
 182          #define Pos_IniDatMF        0x0a
 183          #define Card_type_H         0x0a
 184          #define Card_type_L         0x0b
 185          #define Rtype               0x0A
 186          /*----------------------------------------------------------------------------
 187          definicion de recepcion serial 
 188          ------------------------------------------------------------------------------*/
 189          
 190          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 191          
 192          /*----------------------------------------------------------------------------
 193          tiempo de delay entre funciones
 194          ------------------------------------------------------------------------------*/
 195          
 196          #define   TIME_CARD         50    //50
 197          
 198          
 199          /*----------------------------------------------------------------------------
 200          definicion de datos de trama lintech
 201          ------------------------------------------------------------------------------*/
 202          
 203          #define   ETX               03
 204          #define   STX_LINTECH       0xf2
 205          
 206          /*----------------------------------------------------------------------------
 207          msj de lcd tarjeta y lcd serie SALIDA
 208          ------------------------------------------------------------------------------*/
 209          
 210          #define INGRESE                 85    //    0xDF
 211          #define SIN_INGRESO             86    //      0XE6
 212          #define SIN_PAGO                87    //0XE7
 213          #define EXCEDE_GRACIA           88    //0XE8
 214          #define MENSUAL_NO_PARK         89
 215          #define DIRIJASE_CAJA           90
 216          #define GRACIAS                 91    //0XFF
 217          #define ACERQUESE_CAJA          0XEB
 218          #define PRMR_TARJETA_VENCIDA          0XEC
 219          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 220          #define PRMR_NO_ROTACION              0XFD
 221          
 222          /*MENSAJES INFORMATIVOS*/
 223          
 224          #define ERROR_COD_PARK          170     //0XE5
 225          #define ERROR_LOOP              171         //0XE0
 226          #define TARJETA_INVALIDA        172     //0XE1
 227          #define TARJETA_SIN_FORMATO     173     //0xDF
 228          #define TARJETA_VENCIDA         180
 229          #define MENSUAL_FUERA_HORARIO   181
 230          #define HORARIO_NO_PROG         182
 231          /*MENSAJES PRINCIPAL ACTIVA RELES*/
 232          
 233          #define AUDIO_ENTRADA     0XA0
 234          #define AUDIO_CAJA        0XA1
 235          #define AUDIO_GRACIAS     0XA2
 236          /*----------------------------------------------------------------------------
 237          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 238          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 5   

 239          
 240          #define   ENVIADOS          0X0
 241          #define   RESPUESTA         0X01
 242          /*----------------------------------------------------------------------------
 243          definiciones para, funcion horario. 0 esta inhabilitado 1 habilitado
 244          ------------------------------------------------------------------------------*/
 245          
 246          #define   HABILITA_ADDR     15
 247          #define   Segundo_Tiempo    16
 248          /*
 249          definicion  de daos del reloj
 250                    */
 251          
 252          #define RDIA            0x87
 253          #define RMES            0x89
 254          #define RANO            0x8D
 255          #define RDIA_SEMANA     0x8B
 256          #define RHORA           0x85
 257          #define RMIN            0x83
 258          #define Sabado          7
 259          #define Domingo         1
 260          
 261          /*----------------------------------------------------------------------------
 262          posicion de  MF  bloque 1 sector 1
 263          (0) tipo de tarjeta 
 264          (01) el id del cliente
 265          (03)codigo del parqueadero  
 266          ------------------------------------------------------------------------------*/
 267          #define   MF_TIPO_TARJETA   0X00
 268          #define   MF_ID_CLIENTE     0x01
 269          #define   MF_COD_PARK       0x03
 270          
 271          /*----------------------------------------------------------------------------
 272          posicion de  MF bloque 2 sector 1
 273          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 274          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 275          MF_LSB_SDCT=0 SIN DESCUENTO
 276          MF_LSB_FECHA_OUT=1 FIJA LA FECHA DE SALIDA EN LA TARJETA
 277          MF_LSB_POR_CNTJ=2   DESCUENTO POR PORCENTAJE
 278          MF_LSB_POR_DNR=3    DESCUENTO POR DINERO
 279          ------------------------------------------------------------------------------*/
 280          
 281          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 282          
 283          
 284          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 285                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o 
 286                                                                                                                                */
 287          #define   MF_LSB            0x06        /*codigo de descuento que programa el checpoint o el software */
 288          
 289          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 290          
 291          #define   MF_IN_PAGO        0x09            /*xx11xxxx los dos bits en (1) son la parte alta del tiempo de descuento*
             -/
 292          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 293          
 294          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 295          
 296          #define   MF_MENSUAL_ANO      0X05
 297          #define   MF_MENSUAL_MES      0X06
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 6   

 298          #define   MF_MENSUAL_DIA      0X07
 299          #define   MF_UID_0      0X04
 300          #define   MF_UID_1      0X05
 301          #define   MF_UID_2      0X06
 302          #define   MF_UID_3      0X07
 303          
 304          #define   MF_EXPIRA_ANO     0X08
 305          #define   MF_EXPIRA_MES     0X09
 306          #define   MF_EXPIRA_DIA     0X0A
 307          
 308          
 309          #define OPERATE_FAIL          0X6F
 310          /*----------------------------------------------------------------------------
 311          define posiciones de memoria EEPROM
 312          ------------------------------------------------------------------------------*/
 313          #define EE_DCTO_PASA_CAJA     0X000F
 314          #define EE_CPRCN_ACTIVA       0x000C
 315          #define EE_HABILITA_APB_MENSUAL 0X0015
 316          
 317          enum Hora_Minutos_addr{
 318            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 319            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 320          };
 321          /*----------------------------------------------------------------------------
 322          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 323          (0) si el dato es cero esta inactiva
 324          (1) activa o ROTACION
 325          (2) mensualidad
 326          ------------------------------------------------------------------------------*/
 327          enum Tipos_MF_TIPO_TARJETA{
 328            INACTIVA,         
 329            ROTACION,           
 330            MENSUALIDAD,
 331            PREPAGO,
 332            CORTESIA,
 333            LOCATARIO,
 334            TARJETA_PERDIDA = 0X10,
 335            INHABILITADA = 0X11
 336          };
 337          
 338          enum expedidor {
 339           fecha_Int_Ano,
 340           fecha_Int_Mes, 
 341           fecha_Int_Dia, 
 342           fecha_Int_Hora,
 343           fecha_Int_Min,   
 344           Tipo_Tarjeta,
 345           Apb,
 346           Horario,
 347           Pico_Placa,
 348           Type_Vehiculo,
 349           Uid_0,
 350           Uid_1,
 351           Uid_2,
 352           Uid_3,
 353           Expira_ano,
 354           Expira_mes,
 355           Expira_dia
 356           
 357          };
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 7   

 358          /*tipos de APB antipassback*/
 359          enum Tipos_MF_APB{
 360            
 361            APB_INICIADO,       
 362            APB_INT,              
 363            APB_OUT,              
 364            APB_NO              
 365          };
 366          enum EE_AntiPassBack{
 367            APB_INHABILITADO_SOFT,
 368            APB_HABILITADO_SOFT
 369          };
 370          /*comandos pto paralelo*/
 371          enum CMD_Trama_Pto_Paralelo{
 372            STX=02,
 373            CMD_PTO_PARALELO_EXPEDIDOR='a',
 374          //  ETX= 03,
 375            //NULL=0,
 376            CMD_MONITOR_EXPEDIDOR='E',
 377            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 378          };
 379          enum Tipos_Vehiculos{
 380              AUTOMOVIL,          
 381              MOTO,
 382              BICICLETA
 383          };
 384          /*----------------------------------------------------------------------------
 385          Definicion de varaibles globales del objeto
 386          ------------------------------------------------------------------------------*/
 387          
 388          static unsigned char Estado=INICIA_LINTECH;
 389          
 390          
 391          
 392          /*------------------------------------------------------------------------------
 393          funcion que valida la trama del verificador o transporte lintech
 394          (0) significa que la trama es valida y sigue en el proceso
 395          (1) falla en la respuesta por pto serie o trama invalida
 396          (2) no ha recibido la trama del verificador o transporte
 397          (3) ERROR DE TRAMA CMD (N)
 398          ------------------------------------------------------------------------------*/
 399          
 400          char Trama_Validacion_P_N()
 401          {
 402   1        char Trama_Validacion_P_N=2;                                                    /*no ha llegado inf al pto serie*/
 403   1        
 404   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 405   1            {
 406   2              if (buffer_ready==1)
 407   2              {
 408   3                buffer_ready=0;
 409   3                  
 410   3              
 411   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 412   3                {
 413   4                          
 414   4                  Trama_Validacion_P_N=0;                                                 /*trama ok*/
 415   4                    
 416   4                }
 417   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 418   3                {
 419   4                  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 8   

 420   4                  Trama_Validacion_P_N=3;                                                 /*error de trama*/
 421   4                  
 422   4                }
 423   3                else
 424   3                {
 425   4                  //Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocid
             -a*/
 426   4                  Trama_Validacion_P_N=3;   
 427   4                  
 428   4                }
 429   3              }
 430   2              else
 431   2              {
 432   3                          
 433   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 434   3                                                  
 435   3              }
 436   2      
 437   2            }
 438   1            
 439   1        return Trama_Validacion_P_N;
 440   1      }
 441          
 442          /*------------------------------------------------------------------------------
 443          funcion de error de envios pto serie
 444          
 445          variable en uart error_rx=cuenta los numeros de error pto serie y reset de transporte 
 446          se limpia cuando llega la respuesta del transporte
 447          
 448          cont_error_rx= cuenta el tiempo de ASK si completa 5 tiempos borra ek ask 
 449          
 450          error_rx_pto=0 nos da mas tiempo para esperar la trama
 451          
 452          error_rx_pto=1 reenvia la trama al transporte
 453          
 454          aSk= significa que llego al pto serie el 06 y el transporte esta ejecutando y no ha contestado necesita ti
             -empo
 455          
 456          ------------------------------------------------------------------------------*/
 457          unsigned char error_rx_pto(void)
 458          {
 459   1      static unsigned cont_error_rx=0;
 460   1      unsigned char error_rx_pto=0;
 461   1      
 462   1          
 463   1                
 464   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 465   1            Debug_chr_Tibbo (error_rx); 
 466   1            Debug_chr_Tibbo (cont_error_rx);
 467   1            Debug_chr_Tibbo (error_rx_pto);
 468   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 469   1                if (aSk==0)
 470   1            
 471   1            { 
 472   2                error_rx++;
 473   2              if(error_rx>=10)
 474   2              {                                                                                   /*no contesta debe reset el transporte*/
 475   3                Atascado=1;                                                                       /*off el rele de reset del verificador*/    
 476   3                Delay_10ms(110);
 477   3                error_rx=0;
 478   3                cont_error_rx=0;
 479   3                error_rx_pto=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 9   

 480   3                Atascado=0; 
 481   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 482   3                ValTimeOutCom=TIME_CARD;
 483   3              }
 484   2              else
 485   2              {
 486   3                error_rx_pto=1;                                                                 /*reenvia el cmd y espera la respuesta*/
 487   3                ValTimeOutCom=TIME_CARD;
 488   3              }
 489   2            }
 490   1            else
 491   1            {
 492   2                cont_error_rx++;
 493   2              if(cont_error_rx>=3)
 494   2              {
 495   3                error_rx=0;                                     /*paso tiempo de espera y no contesta limpio los reg y reenvio la trama
             -*/
 496   3                cont_error_rx=0;
 497   3                error_rx_pto=1;
 498   3                aSk=0;
 499   3                ValTimeOutCom=TIME_CARD;
 500   3              }
 501   2              else
 502   2              {
 503   3                error_rx=0;                                   /*damos tiempo de espera de la trama del transporte*/
 504   3                error_rx_pto=0;
 505   3                ValTimeOutCom=TIME_CARD;
 506   3              }
 507   2            }
 508   1              return (error_rx_pto);
 509   1      }
 510          /*------------------------------------------------------------------------------
 511          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 512          
 513          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 514          ------------------------------------------------------------------------------*/
 515          
 516          unsigned char  Secuencia_inicio_expedidor(void)
 517          {
 518   1        char temp;
 519   1        
 520   1        
 521   1        switch (Estado)
 522   1        {
 523   2          case INICIA_LINTECH:
 524   2      
 525   2              Atascado=0; 
 526   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 527   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 528   2              
 529   2            
 530   2            return (Estado);
 531   2          break;
 532   2      
 533   2      
 534   2      /*------------------------------------------------------------------------------
 535   2      Envia la primera trama de inicializacion del transporte sin movimiento
 536   2            (0) LA RESPUESTA ES OK
 537   2            (1) NO RESPONDE EL PTO SERIE
 538   2            (2) NO RECIBIDO LA TRAMA 
 539   2            (3) ERROR DE TRAMA CMD (N)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 10  

 540   2      ------------------------------------------------------------------------------*/
 541   2            
 542   2          case SEQ_CAPTURE_DATOS_INI:
 543   2      
 544   2            if((temp=Trama_Validacion_P_N())!=0)
 545   2          {
 546   3            if(temp==2)
 547   3            {
 548   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 549   4            } 
 550   3            else if (temp==3)
 551   3            {
 552   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 553   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 554   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 555   4            }
 556   3            else
 557   3            {
 558   4              
 559   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 560   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 561   4            }
 562   3          }
 563   2          else
 564   2          {
 565   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 566   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 567   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 568   3          }     
 569   2          return (Estado);
 570   2          break;
 571   2            
 572   2      /*------------------------------------------------------------------------------
 573   2      Envia el cmd de grabar claves a la eeprom del transporte 
 574   2      ------------------------------------------------------------------------------*/
 575   2            
 576   2            case GRABA_EEPROM:
 577   2              
 578   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 579   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 580   2            
 581   2            
 582   2      
 583   2            return (Estado);
 584   2              break;
 585   2        
 586   2      /*------------------------------------------------------------------------------
 587   2      se analiza la respuesta 
 588   2            (0) LA RESPUESTA ES OK
 589   2            (1) NO RESPONDE EL PTO SERIE
 590   2            (2) NO RECIBIDO LA TRAMA 
 591   2            (3) ERROR DE TRAMA CMD (N)
 592   2      ------------------------------------------------------------------------------*/
 593   2            
 594   2          case SEQ_CAPTURA_OK_EEPROM:
 595   2          
 596   2          if((temp=Trama_Validacion_P_N())!=0)
 597   2          {
 598   3            if(temp==2)
 599   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 11  

 600   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 601   4            }
 602   3            else if (temp==3)
 603   3            {
 604   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 605   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 606   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 607   4            }     
 608   3            else
 609   3            {
 610   4              
 611   4              
 612   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 613   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 614   4            }       
 615   3          }
 616   2          else
 617   2          {
 618   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 619   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 620   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 621   3          }     
 622   2      
 623   2          return (Estado);
 624   2          break;
 625   2      
 626   2      /*------------------------------------------------------------------------------
 627   2      Fin de la secuencia de comandos con exito 
 628   2      ------------------------------------------------------------------------------*/    
 629   2            
 630   2              case FIN_OK:
 631   2      
 632   2              return (Estado);
 633   2          break;
 634   2            
 635   2                
 636   2              default:
 637   2              return Estado=INICIA_LINTECH; 
 638   2              break;
 639   2        }
 640   1      }
 641          
 642          /*------------------------------------------------------------------------------
 643          Prosedimiento  q hace paso a paso la secuencia de la MF
 644          contador= numero de ciclos q pasa para mostrar el mensaje de loop solo se muestra el msj cuando contador=0
 645          temp= atributo para uso general
 646          Tiempo= trae el dato de mf tiempo de descuento maximo 999
 647          Estado_Tiempo = arreglo del tiempo a ascii
 648          error_rx= no llega la respuesta en el tiempo solicitado y espera otro tiempo maximo 3
 649          cont_error_rx= envio la trama otra vez solo una vez
 650          ------------------------------------------------------------------------------*/
 651          unsigned char Horarios(unsigned char Horario)
 652          {
 653   1        unsigned char Estado_Horario;
 654   1        
 655   1        unsigned char Addr_horarios [11];
 656   1        unsigned char dia_semana,EE_dia_semana;
 657   1        unsigned int addr;
 658   1        if (Horario != False )
 659   1        {
 660   2          /*se Lee la direccion del horario*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 12  

 661   2          strcpy (Addr_horarios,(Addr_Horarios()));
 662   2          
 663   2          addr= Addr_horarios[Horario -1] ;
 664   2          
 665   2           /*leemos si esta habilitado*/
 666   2          
 667   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
 668   2          {
 669   3            /*miramos si el dia de la semana esta habilitado*/
 670   3            dia_semana = lee_clk(RDIA_SEMANA);
 671   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
 672   3            Debug_chr_Tibbo(dia_semana);
 673   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 674   3            
 675   3          
 676   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
 677   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
 678   3            Debug_chr_Tibbo(EE_dia_semana);
 679   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
 680   3          
 681   3            if ( EE_dia_semana == dia_semana)
 682   3            {
 683   4              /*miramos si esta en el rango del horario*/
 684   4              Estado_Horario = Bloque_Horario(addr);
 685   4            }
 686   3            else
 687   3            {
 688   4      
 689   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
 690   4              Estado_Horario= False;
 691   4            }
 692   3          }
 693   2          else 
 694   2          {
 695   3            
 696   3            Estado_Horario= False;
 697   3            PantallaLCD(HORARIO_NO_PROG);
 698   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
 699   3            
 700   3          }
 701   2          
 702   2        }
 703   1        else
 704   1        {
 705   2          Estado_Horario = True;
 706   2        
 707   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
 708   2        }
 709   1        return Estado_Horario;
 710   1      }
 711          unsigned int Hora_Maxima(unsigned int addr)
 712          {
 713   1        unsigned char Hora_High,  Minuto_High;
 714   1        unsigned char HoraIni , MinutoIni; 
 715   1        unsigned int  Hora_Prog;
 716   1        
 717   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
 718   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
 719   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
 720   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
 721   1         Debug_chr_Tibbo(HoraIni);
 722   1         Debug_chr_Tibbo(MinutoIni);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 13  

 723   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
 724   1        
 725   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
 726   1      }
 727          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
 728          {
 729   1        unsigned char Estado_Horario; 
 730   1        
 731   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
 732   1        {
 733   2          
 734   2          /*hasta la hora que puede ingresar el vehiculo */
 735   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
 736   2          Hora_Prog = Hora_Maxima(addr+4);
 737   2      
 738   2        
 739   2          if( HoraNow <= Hora_Prog)
 740   2          {
 741   3            send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 742   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
 743   3            Estado_Horario = True;
 744   3          }
 745   2          else
 746   2          {
 747   3            send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 748   3            PantallaLCD(MENSUAL_FUERA_HORARIO);
 749   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
 750   3            Estado_Horario = False;
 751   3          }
 752   2          
 753   2        }
 754   1        else
 755   1        {
 756   2              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 757   2              PantallaLCD(MENSUAL_FUERA_HORARIO);
 758   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
 759   2              Estado_Horario = False;
 760   2            
 761   2        }
 762   1        return Estado_Horario;
 763   1      }
 764          
 765          unsigned Bloque_Horario(unsigned int addr)
 766          {
 767   1        unsigned char Estado_Horario; 
 768   1        unsigned int HoraNow, Hora_Prog;
 769   1        
 770   1        /*la hora del momento de entrada del vehiculo*/
 771   1        
 772   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
 773   1        Debug_chr_Tibbo(lee_clk(RHORA));
 774   1        Debug_chr_Tibbo(lee_clk(RMIN));
 775   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
 776   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
 777   1        
 778   1        /* desde la hora en que puede ingresar vehiculo */
 779   1        
 780   1        
 781   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
 782   1        Hora_Prog = Hora_Maxima(addr);
 783   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
 784   1        if(Estado_Horario == False )
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 14  

 785   1        {
 786   2          
 787   2            
 788   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
 789   2            {
 790   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
 791   3              Hora_Prog = Hora_Maxima(addr+10);
 792   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
 793   3            }
 794   2            else
 795   2            {
 796   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
 797   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
 798   3              Estado_Horario = False;
 799   3            }
 800   2        }
 801   1      
 802   1      return Estado_Horario;
 803   1      }
 804          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
 805          {
 806   1        unsigned char temp;
 807   1        unsigned char Estado_expedidor;
 808   1        static unsigned char falla=0;
 809   1        
 810   1        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA V
             -ERIFICA*/
 811   1                                      
 812   1            
 813   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 814   1            {
 815   2              
 816   2                for (temp=0; temp<16; temp++)
 817   2                {
 818   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
 819   3                }
 820   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);                               /*imprimo la trama recibida*/ 
 821   2                if (((buffer_S_B[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S_B[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE==0)&
             -&(COD_PARK==0)))    
 822   2                {
 823   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
 824   3                  Debug_HexDec(buffer_S_B[MF_ID_CLIENTE]);
 825   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 826   3                  
 827   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
 828   3                  Debug_HexDec(buffer_S_B[MF_COD_PARK]);
 829   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 830   3                  
 831   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
 832   3                  Debug_chr_Tibbo(buffer_S_B [MF_TIPO_TARJETA]);
 833   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 834   3                  
 835   3                  
 836   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S_B [MF_TIPO_TARJETA];
 837   3                
 838   3                  /*fecha de vencimiento de mensual o prepago*/
 839   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S_B [MF_EXPIRA_ANO];
 840   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S_B [MF_EXPIRA_MES];
 841   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S_B [MF_EXPIRA_DIA];
 842   3                  falla=0;                                                                  
 843   3                    Estado_expedidor=SEQ_RD_S1B2;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 15  

 844   3                
 845   3                }
 846   2                else
 847   2                {
 848   3                  falla=0;
 849   3                  send_portERR(0XE5);
 850   3                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
 851   3                  Estado_expedidor=SEQ_EXPULSAR_TARJ;                                               /* codigo de parqueo erro expulso la tarj
             -eta */    
 852   3                }
 853   2            }
 854   1            else
 855   1            {
 856   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
 857   2              {
 858   3                falla++;
 859   3              }
 860   2               if (falla <= 2)
 861   2                
 862   2              {
 863   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
 864   3                Estado_expedidor = SEQ_POWER_ON;
 865   3                                    
 866   3              }
 867   2              else
 868   2              {
 869   3                falla=0;
 870   3                send_portERR(0XDF);
 871   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
 872   3                Estado_expedidor=SEQ_EXPULSAR_TARJ;
 873   3              }
 874   2            }
 875   1            return Estado_expedidor;
 876   1      }     
 877          
 878          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
 879          {
 880   1        unsigned char temp;
 881   1        unsigned char Estado_expedidor;
 882   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 883   1           {
 884   2            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n");                              /* trama OK CARGA LA EEPROM Y LA
             - VERIFICA*/
 885   2                            
 886   2            for (temp=0; temp<16; temp++)
 887   2            {
 888   3              buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de MF 
             -en un arreglo*/
 889   3            }
 890   2            DebugBufferMF(buffer_S_B,16,RESPUESTA); 
 891   2            /*fecha entrada*/
 892   2      
 893   2            *(Atributos_Expedidor + fecha_Int_Ano) =    buffer_S_B [MF_FECHA_INT] ;
 894   2            *(Atributos_Expedidor + fecha_Int_Mes) =    buffer_S_B [MF_FECHA_INT+1] ;
 895   2            *(Atributos_Expedidor + fecha_Int_Dia) =    buffer_S_B [MF_FECHA_INT+2] ;
 896   2            *(Atributos_Expedidor + fecha_Int_Hora)=    buffer_S_B [MF_FECHA_INT+3] ;
 897   2            *(Atributos_Expedidor + fecha_Int_Min) =    buffer_S_B [MF_FECHA_INT+4] ;
 898   2            /*horario*/
 899   2            Debug_txt_Tibbo((unsigned char *) "HORARIO:");
 900   2            Debug_chr_Tibbo((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 16  

 901   2            *(Atributos_Expedidor + Horario)= ((buffer_S_B [MF_TIPO_VEHICULO] & 0XF0) >> 4);
 902   2              Debug_txt_Tibbo((unsigned char *) "\r\n");
 903   2            /*pico y placa*/
 904   2            *(Atributos_Expedidor + Pico_Placa)= ((buffer_S_B [MF_IN_PAGO] & 0XF0) >> 4);     
 905   2            /*APB*/
 906   2            *(Atributos_Expedidor + Apb)=   buffer_S_B [MF_APB] ;
 907   2            /*tipo de tarjeta*/
 908   2            *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S_B [MF_TIPO_VEHICULO]& 0x0f;
 909   2                  
 910   2             /*------------------------------------------------------------------------------ 
 911   2              tipo de tarjeta
 912   2              ------------------------------------------------------------------------------*/
 913   2      
 914   2              if  (*(Atributos_Expedidor + Tipo_Tarjeta) ==ROTACION)          
 915   2              {
 916   3                  if((*(Atributos_Expedidor + Apb) == 02)||(*(Atributos_Expedidor + Apb) == 0) )                              /*Pregu
             -nto por el antipasban si es 02 ya salio y no posee entrada*/
 917   3                  {
 918   4                    Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n");
 919   4                    send_portERR(0xA2);                                                             /*error audio*/ 
 920   4                    send_portERR(0XE6);
 921   4                    PantallaLCD(SIN_INGRESO);
 922   4                    Estado_expedidor=SEQ_EXPULSAR_TARJ;
 923   4                  }
 924   3                  else
 925   3                  {
 926   4                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n");
 927   4                    Estado_expedidor=SEQ_ROTACION;
 928   4                  
 929   4                  }
 930   3        
 931   3              }
 932   2              else if (*(Atributos_Expedidor + Tipo_Tarjeta)== MENSUALIDAD) 
 933   2              {
 934   3                if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
 935   3                {
 936   4                  Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK HABILITADO MENSUAL \r\n");
 937   4                  if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) ) 
 938   4                  {
 939   5                    Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO MENSUAL\r\n");
 940   5                    send_portERR(0xA2);                                                             /*error audio*/ 
 941   5                    send_portERR(0XE6);
 942   5                    PantallaLCD(SIN_INGRESO);
 943   5                    Estado_expedidor=SEQ_EXPULSAR_TARJ;
 944   5                  
 945   5                  }
 946   4                  else
 947   4                  {
 948   5                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
 949   5                    Estado_expedidor=SEQ_MENSUAL;
 950   5                  }
 951   4                }
 952   3                else
 953   3                {
 954   4                  Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
 955   4                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
 956   4                  Estado_expedidor = SEQ_MENSUAL;
 957   4                }
 958   3              }
 959   2              else
 960   2              {
 961   3                Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 17  

 962   3                send_portERR(PRMR_NO_ROTACION);
 963   3                Estado_expedidor=SEQ_EXPULSAR_TARJ;
 964   3                
 965   3              }
 966   2             
 967   2          }
 968   1        else
 969   1           {
 970   2             g_cEstadoComSeqMF=SEQ_RD_S1B2;
 971   2           }
 972   1           
 973   1           return Estado_expedidor;
 974   1        
 975   1      }
 976          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Atributos_Expedidor)
 977          {
 978   1        unsigned char temp;
 979   1        unsigned char Estado_expedidor;
 980   1        static unsigned char buffer_S1_B0[17];
 981   1        if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 982   1           {
 983   2        Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n");                              /* trama OK CARGA numero de ticket
             -*/
 984   2                                          
 985   2            
 986   2        for (temp=0; temp<16; temp++)
 987   2            {
 988   3              
 989   3              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
 990   3              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
 991   3              {
 992   4                break;
 993   4              }
 994   3            }
 995   2            
 996   2            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
 997   2            Debug_txt_Tibbo(buffer_S1_B0);
 998   2            Debug_txt_Tibbo((unsigned char *) "\r\n");
 999   2            
1000   2          
1001   2            /*transmito pto paralelo*/  
1002   2            if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
1003   2            {
1004   3            Timer_wait=0;                                                                               /*activo la barrera*/
1005   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S_B,'s');
1006   3            }
1007   2            else
1008   2            {
1009   3            
1010   3            Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor);
1011   3            }
1012   2            if(USE_LPR)
1013   2            {
1014   3              
1015   3              /*envio datos a Monitor*/
1016   3              if (*(Atributos_Expedidor + Tipo_Tarjeta)!= MENSUALIDAD)  
1017   3              {
1018   4              
1019   4              Cmd_LPR_Salida(Atributos_Expedidor,buffer_S1_B0); 
1020   4              }
1021   3              else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 18  

1022   3              {
1023   4              Cmd_LPR_Salida(Atributos_Expedidor,buffer_S1_B0); 
1024   4              }
1025   3            }
1026   2            
1027   2            
1028   2            
1029   2            Estado_expedidor=SEQ_WR_S1B2;
1030   2            
1031   2          }else
1032   1           {
1033   2            Estado_expedidor= SEQ_RD_S1B0;
1034   2           }
1035   1           return Estado_expedidor;
1036   1      }
1037          
1038          void Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor)
1039          {
1040   1        static unsigned char buffer[28];
1041   1        //unsigned char j;
1042   1        /*la trama esta compuesta de
1043   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1044   1      
1045   1        buffer[0]=STX;
1046   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1047   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1048   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1049   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1050   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1051   1        
1052   1        //leo la fecha de entrada
1053   1        //Block_read_Clock_Hex(buffer+6);         
1054   1        
1055   1        buffer[6]=*(Atributos_Expedidor + fecha_Int_Ano)+0x030;             /*año de entrada*/
1056   1        buffer[7]=*(Atributos_Expedidor + fecha_Int_Mes)+0x030;         /*mes de entrada*/
1057   1        buffer[8]=*(Atributos_Expedidor + fecha_Int_Dia)+0x030;         /*dia de entrada*/
1058   1        buffer[9]=*(Atributos_Expedidor + fecha_Int_Hora)+0x030;          /*hora de entrada*/
1059   1        buffer[10]=*(Atributos_Expedidor + fecha_Int_Min)+0x030;          /*minutos de entrada*/
1060   1      
1061   1        /*placa*/
1062   1        if (rd_eeprom(0xa8,EE_CPRCN_ACTIVA)!=0)
1063   1        {   
1064   2          
1065   2            buffer[11]= placa[0];
1066   2            buffer[12]= placa[1];
1067   2            buffer[13]= placa[2];
1068   2            buffer[14]= placa[3];
1069   2            buffer[15]= placa[4];
1070   2            buffer[16]= placa[5];
1071   2      
1072   2        }
1073   1      
1074   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1075   1        {
1076   2          buffer[17]= 'C';
1077   2        }
1078   1        else
1079   1        {
1080   2          buffer[17]= 'M';
1081   2        }
1082   1        
1083   1        buffer[18]= ETX;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 19  

1084   1        buffer[19]= 0;
1085   1        ready=0;
1086   1            while(busy==0);
1087   1          send_port(buffer,19);                         /*trama transmitida pto paralelo*/
1088   1          
1089   1            Debug_Dividir_texto();                                              /*division del texto */
1090   1            Debug_txt_Tibbo((unsigned char *) "Datos enviados pto paral=");       
1091   1            DebugBufferMF(buffer,19,0);   
1092   1            Debug_Dividir_texto();
1093   1      }
1094          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
1095          {
1096   1        unsigned char Estado_expedidor;
1097   1        unsigned char temp;
1098   1            if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
1099   1            {
1100   2              
1101   2                for (temp=0; temp<16; ++temp)
1102   2                {
1103   3                  buffer_S_B[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de MF
             - en un arreglo*/
1104   3                 
1105   3                }
1106   2                
1107   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
1108   2                DebugBufferMF(buffer_S_B,16,RESPUESTA);
1109   2                
1110   2        
1111   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
1112   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_0]));  
1113   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_1]));  
1114   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_2]));  
1115   2                Debug_chr_Tibbo((buffer_S_B [ MF_UID_3]));
1116   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1117   2                
1118   2              *(Atributos_Expedidor + Uid_0) = buffer_S_B [MF_UID_0];   
1119   2              *(Atributos_Expedidor + Uid_1) = buffer_S_B [MF_UID_1];     
1120   2              *(Atributos_Expedidor + Uid_2) = buffer_S_B [MF_UID_2];     
1121   2              *(Atributos_Expedidor + Uid_3) = buffer_S_B [MF_UID_3]; 
1122   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
1123   2            }   
1124   1            else
1125   1            {
1126   2              Estado_expedidor=SEQ_POWER_OFF;
1127   2            } 
1128   1            return Estado_expedidor;
1129   1      }
1130          void SecuenciaExpedidor(void)
1131          {
1132   1        unsigned char temp;
1133   1        unsigned int tiempo;
1134   1        unsigned char Estado_Tiempo[4];
1135   1        static unsigned char Atributos_Expedidor[18];
1136   1        static unsigned char buffer_S1_B0[17];
1137   1        unsigned char clock_temp[6];
1138   1        static unsigned char contador=0;
1139   1        unsigned char *atributos;
1140   1        switch (g_cEstadoComSeqMF)
1141   1        {
1142   2      //***********************************************************************************************
1143   2          
1144   2          case SEQ_INICIO:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 20  

1145   2      
1146   2            if (ValTimeOutCom==1)
1147   2            {
1148   3              
1149   3              Atascado=0;                                                                       /*activo el rele de reset del verificador*/   
1150   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
1151   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
1152   3              
1153   3            }
1154   2       
1155   2          break;
1156   2      
1157   2      /*------------------------------------------------------------------------------
1158   2      Analizo la trama de insercion por boca
1159   2            (0) LA RESPUESTA ES OK
1160   2            (1) NO RESPONDE EL PTO SERIE
1161   2            (2) NO RECIBIDO LA TRAMA 
1162   2            (3) ERROR DE TRAMA CMD (N)
1163   2      ------------------------------------------------------------------------------*/      
1164   2          
1165   2          case SEQ_CARD_INSERCION:  
1166   2            
1167   2          if((temp=Trama_Validacion_P_N())!=0)
1168   2          {
1169   3            if(temp==2)
1170   3            {
1171   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
1172   4            } 
1173   3            else if (temp==3)
1174   3            {
1175   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
1176   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1177   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1178   4            }     
1179   3            else
1180   3            {
1181   4              /*Dispensador No Responde PTO SERIE ...*/
1182   4          
1183   4              if(temp=error_rx_pto()==0)
1184   4              {
1185   5                g_cEstadoComSeqMF=SEQ_CARD_INSERCION;
1186   5              }
1187   4              else if(temp=error_rx_pto()==1)
1188   4              {
1189   5                g_cEstadoComSeqMF=SEQ_INICIO;
1190   5              }
1191   4                                  
1192   4            }       
1193   3          }
1194   2          else
1195   2          {
1196   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
1197   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1198   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
1199   3          }     
1200   2            
1201   2          break;
1202   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 21  

1203   2      /*------------------------------------------------------------------------------
1204   2      chequeo el estado de los sensores 
1205   2      ------------------------------------------------------------------------------*/      
1206   2          
1207   2          case SEQ_CHECK_STATUS:  
1208   2                if (ValTimeOutCom==1)
1209   2            {       
1210   3              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
1211   3              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
1212   3            }
1213   2            break;      
1214   2              
1215   2      /*------------------------------------------------------------------------------
1216   2      Valido la informacion de los sensores
1217   2            (0) LA RESPUESTA ES OK
1218   2            (1) NO RESPONDE EL PTO SERIE
1219   2            (2) NO RECIBIDO LA TRAMA 
1220   2            (3) ERROR DE TRAMA CMD (N)
1221   2      ------------------------------------------------------------------------------*/    
1222   2      
1223   2          case SEQ_RTA_CARD_POS:
1224   2            
1225   2          if((temp=Trama_Validacion_P_N())!=0)
1226   2          {
1227   3            if(temp==2)
1228   3            {
1229   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
1230   4            } 
1231   3            else if (temp==3)
1232   3            {
1233   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n");                     /* trama no valida*/
1234   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
1235   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
1236   4            }     
1237   3            else
1238   3            {
1239   4              
1240   4              /*Dispensador No Responde PTO SERIE ...*/
1241   4          
1242   4              if(temp=error_rx_pto()==0)
1243   4              {
1244   5                g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;
1245   5              }
1246   4              else if(temp=error_rx_pto()==1)
1247   4              {
1248   5                g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
1249   5              }
1250   4            
1251   4            }
1252   3          }
1253   2          else
1254   2          {
1255   3            Debug_txt_Tibbo((unsigned char *) "CHECK STATUS OK\r\n");                                 /* trama valida Habilitado */
1256   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
1257   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
             - el mecanismo*/
1258   3                  {
1259   4                    
1260   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n");       /* trama valida Habi
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 22  

             -litado insercion por boca*/
1261   4                    ValTimeOutCom=TIME_CARD;
1262   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
1263   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1264   4                    {
1265   5                      if(contador==0)                                                                   /*contador si es cero envia el msj a la pantala*/
1266   5                      { 
1267   6                        contador++;
1268   6                        Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor 
             -activo*/
1269   6                        send_portERR(0xA0);                                                                 /*audio ingrese tarjeta con rele*/
1270   6                        PantallaLCD(INGRESE);                                                             /*msj por raspberry "ingrese su tarjeta"*/
1271   6                                          
1272   6                      } else
1273   5                      {
1274   6                        contador++;                                                                       /*espera 20 ciclos para poder enviar msj nueva men
             -te*/
1275   6                        if (contador>= 20)contador=0;
1276   6                      } 
1277   5                    }else contador=0;
1278   4                    
1279   4                    
1280   4                  }
1281   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
1282   3                  {
1283   4                    
1284   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                      /* trama valida Habilitado i
             -nsercion por boca*/
1285   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1286   4                    //g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
1287   4                                           
1288   4                  }
1289   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
1290   3                  {
1291   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n");             /* trama valida Habil
             -itado insercion por boca*/
1292   4                                
1293   4                    
1294   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
1295   4                    {
1296   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n");                   /* se encuentra un sensor ac
             -tivo*/
1297   5                    //Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF5
             -0*/
1298   5                                                                                                        /*tarjeta presente prioridad  */
1299   5                    g_cEstadoComSeqMF=SEQ_TIPO_CARD;//SEQ_REQUEST;                                                      /*vamos al siguiente paso 
             -a con validar el cmd*/    
1300   5                    }
1301   4                    else
1302   4                    {
1303   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n");              /* no hay vehiculo en el lo
             -op*/
1304   5                      send_portERR(0XE0);                                                               /*envio msj al PRINCIPAL lcd tarjeta*/
1305   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
1306   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
1307   5                      
1308   5                    }
1309   4                                                                  
1310   4                  }
1311   3                                                                    
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 23  

1312   3          }     
1313   2            
1314   2          break;
1315   2        
1316   2      
1317   2      /*------------------------------------------------------------------------------
1318   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
1319   2      (1 0)  es una tarjeta valida Mf50 
1320   2      las demas combinaciones son tomadas como no validas
1321   2            (0) LA RESPUESTA ES OK
1322   2            (1) NO RESPONDE EL PTO SERIE
1323   2            (2) NO RECIBIDO LA TRAMA 
1324   2            (3) ERROR DE TRAMA CMD (N)    
1325   2      ------------------------------------------------------------------------------*/  
1326   2      
1327   2        case SEQ_REQUEST:
1328   2          
1329   2        if((temp=Trama_Validacion_P_N())!=0)
1330   2          {
1331   3            if(temp==2)
1332   3            {
1333   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
1334   4            } 
1335   3              else if (temp==3)
1336   3            {
1337   4              
1338   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n");                       /* trama no valida*/
1339   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
1340   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
1341   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
1342   4            } 
1343   3            else
1344   3            {
1345   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n");      /* pto serie no res
             -ponde*/
1346   4              send_portERR(0XE1);                                                                       /*la tarjeta no es valida no la puede identif
             -icar*/
1347   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1348   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
1349   4            
1350   4            }       
1351   3          }
1352   2          else
1353   2          {
1354   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
1355   3                    {
1356   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
1357   4                        {
1358   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
1359   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
1360   5                          //LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tr
             -ansporte
1361   5                          g_cEstadoComSeqMF=SEQ_UID;  //SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
1362   5                          
1363   5                       }else
1364   4                        {
1365   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 24  

1366   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
1367   5                        send_portERR(0xA2);                                                             /*error audio*/ 
1368   5                        send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
1369   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1370   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
1371   5                         
1372   5                        }
1373   4                   }
1374   3                    else 
1375   3                    {
1376   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
1377   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
1378   4                    send_portERR(0xA2);                                                             /*error audio*/ 
1379   4                    send_portERR(0xe1);                                                     //la tarjeta no es valida 
1380   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1381   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
1382   4                  
1383   4                    }
1384   3                                                                                                            /*respuesta ok inicia revisando sensores*/
1385   3          }     
1386   2                
1387   2            break;
1388   2      /*------------------------------------------------------------------------------
1389   2      Verifica la eeprom 
1390   2            (0) LA RESPUESTA ES OK
1391   2            (1) NO RESPONDE EL PTO SERIE
1392   2            (2) NO RECIBIDO LA TRAMA 
1393   2            (3) ERROR DE TRAMA CMD (N)
1394   2      ------------------------------------------------------------------------------*/  
1395   2        case SEQ_MF_LINTECH:
1396   2          
1397   2        if((temp=Trama_Validacion_P_N())!=0)
1398   2          {
1399   3            if(temp==2)
1400   3            {
1401   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1402   4            }
1403   3            else if (temp==3)
1404   3            {
1405   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1406   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1407   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1408   4            }       
1409   3            else
1410   3            { 
1411   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1412   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1413   4            }
1414   3          }
1415   2          else
1416   2          {
1417   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n");                       /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1418   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 25  

1419   3                                                                                                      /*leo MF */
1420   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1421   3          }     
1422   2      
1423   2        
1424   2        break;
1425   2      /*------------------------------------------------------------------------------
1426   2      Leo la Mf en el sector 1  bloque 1
1427   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1428   2      ------------------------------------------------------------------------------*/    
1429   2      
1430   2        case SEQ_RD_S1B1:
1431   2          
1432   2          RD_MF(1,1);                                                                                 /*leo MF */
1433   2          g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA; 
1434   2        
1435   2        break;
1436   2      /*------------------------------------------------------------------------------
1437   2      Analiso lo leido en Mf en el sector 1  bloque 1
1438   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1439   2      ------------------------------------------------------------------------------*/      
1440   2        
1441   2        case SEQ_RD_S1B1_RPTA:
1442   2          
1443   2          if((temp=Trama_Validacion_P_N())!=0)
1444   2          {
1445   3            if(temp==2)
1446   3            {
1447   4            g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;                                                           /*no ha respondido*/
1448   4            }
1449   3            else if (temp==3)
1450   3            {
1451   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1452   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1453   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1454   4            }       
1455   3            else
1456   3            { 
1457   4              
1458   4                /*Dispensador No Responde PTO SERIE ...*/
1459   4          
1460   4              if(temp=error_rx_pto()==0)
1461   4              {
1462   5                g_cEstadoComSeqMF=SEQ_RD_S1B1_RPTA;
1463   5              }
1464   4              else if(temp=error_rx_pto()==1)
1465   4              {
1466   5                g_cEstadoComSeqMF=SEQ_RD_S1B1;;
1467   5              }
1468   4                                                              /* respuesta incorrecta*/
1469   4            }
1470   3          }
1471   2          else
1472   2          {
1473   3            g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque1(Atributos_Expedidor);
1474   3          }     
1475   2        break;
1476   2      /*------------------------------------------------------------------------------
1477   2      Leo la Mf en el  sector 1 bloque 2
1478   2        Se lee Fecha in, fecha out
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 26  

1479   2      ------------------------------------------------------------------------------*/    
1480   2        case SEQ_RD_S1B2: 
1481   2        
1482   2        RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1483   2        g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1484   2        break;  
1485   2          
1486   2      /*------------------------------------------------------------------------------
1487   2      ANALIZO LO LEIDO  Mf en el  sector 1 bloque 2
1488   2        Se lee Fecha in, fecha out
1489   2      ------------------------------------------------------------------------------*/
1490   2        case SEQ_RD_S1B2_RPTA:
1491   2              
1492   2        if((temp=Trama_Validacion_P_N())!=0)
1493   2          {
1494   3            if(temp==2)
1495   3            {
1496   4            g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;                                                           /*no ha respondido*/
1497   4            }
1498   3            else if (temp==3)
1499   3            {
1500   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta falla en la escritura de la clave*/
1501   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1502   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1503   4            }       
1504   3            else
1505   3            { 
1506   4                /*Dispensador No Responde PTO SERIE ...*/
1507   4          
1508   4              if(temp=error_rx_pto()==0)
1509   4              {
1510   5                g_cEstadoComSeqMF=SEQ_RD_S1B2_RPTA;
1511   5              }
1512   4              else if(temp=error_rx_pto()==1)
1513   4              {
1514   5                g_cEstadoComSeqMF=SEQ_RD_S1B2;
1515   5              }
1516   4                                                                  
1517   4            }
1518   3          }
1519   2          else
1520   2          {
1521   3           g_cEstadoComSeqMF = Responde_Lectura_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor);
1522   3        
1523   3          }
1524   2          break;
1525   2        case SEQ_ROTACION:
1526   2          
1527   2            
1528   2            /*------------------------------------------------------------------------------  
1529   2            sinc0bro  por  programacion
1530   2          ------------------------------------------------------------------------------*/  
1531   2            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1532   2            {
1533   3              if (SIN_COBRO==1)
1534   3              {
1535   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1536   4                                                                                                    
1537   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 27  

1538   4                break;
1539   4              }
1540   3              else if( SIN_COBRO ==2)
1541   3              {
1542   4                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1543   4                        
1544   4          
1545   4                if ((buffer_S_B[0]==clock_temp[0])&&(buffer_S_B[1]==clock_temp[1])&&(buffer_S_B[2]==clock_temp[2]))   
             -/*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1546   4                {
1547   5                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1548   5                                                                                                                            /* Leo el ticket */
1549   5                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1550   5                  break;
1551   5                }                                                                                         
1552   4                  else
1553   4                  {
1554   5                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n");                                             /*excede el timepo d
             -e gracia del dia */
1555   5                  send_portERR(0XE8);
1556   5                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1557   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1558   5                  break;              
1559   5                  }
1560   4                
1561   4                
1562   4              }
1563   3            }
1564   2      /*------------------------------------------------------------------------------
1565   2          validacion descuentos  se maneja en 2 posiciones de memoria del MF
1566   2            MF_LSB= tipo de descuento       
1567   2      ------------------------------------------------------------------------------*/      
1568   2            else if(buffer_S_B[MF_LSB]!=0)
1569   2            {
1570   3              
1571   3             if((rd_eeprom(0xa8,EE_DCTO_PASA_CAJA))!= 0)  
1572   3            {
1573   4              Debug_Dividir_texto();
1574   4              Debug_txt_Tibbo((unsigned char *) "CODIGO DE DCTO: ");                                                      /*codigo de descuento
             - es elnumero de descuento del cliente*/
1575   4              Debug_chr_Tibbo(buffer_S_B[MF_LSB]);
1576   4              Debug_txt_Tibbo((unsigned char *) "\r\n");  
1577   4              /*parte alta del tiempo libre*/
1578   4              temp=(buffer_S_B[MF_IN_PAGO]&0x70)>>4 ;                                                                   /*se lee la parte alta del ti
             -empo libre y se rotsa 4 bits a la derecha*/
1579   4              tiempo=temp;                                                                                                /*se carga en un entero*/
1580   4              tiempo=(tiempo <<8) | buffer_S_B[MF_DCTO] ;                                                               /*MF_DCTO= tiene la parte b
             -aja del tiempo libre, se une la parte alta con la baja */
1581   4                                                                                                                          /*creando un int del tiemo de dcto*/
1582   4              Debug_txt_Tibbo((unsigned char *) "TIEMPO DE DCTO: ");
1583   4              sprintf( Estado_Tiempo,"%u",tiempo);                                                                        /*se muestra el tiempo de desc
             -uento*/
1584   4              Debug_txt_Tibbo((unsigned char *)Estado_Tiempo);
1585   4              Debug_txt_Tibbo((unsigned char *) "\r\n");
1586   4              Debug_Dividir_texto();  
1587   4              
1588   4            /*tipo de descuento es el bit 8 de MF_IN_PAGO*/ 
1589   4            /*por fecha que es fijar fecha de salida*/
1590   4                if ((buffer_S_B[MF_IN_PAGO]&0x80)==0)                                                                   /*tipo de descuento por fecha 
             -de salida*/
1591   4                {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 28  

1592   5                Debug_txt_Tibbo((unsigned char *) "DCTO FIJA FECHA DE OUT: ");                                            /**/
1593   5                analiza_tiempo(buffer_S_B,tiempo); 
1594   5              /*fijar fecha de salida*/
1595   5                }
1596   4                else
1597   4                {
1598   5                  if (tiempo== 0x64)                                                                                  /*tipo de dcto por porcentaje al 100 %*/
1599   5                  {
1600   6                    Debug_txt_Tibbo((unsigned char *) "DCTO PORCENTAJE 100% ");
1601   6                    Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1602   6                                                                                                                      /* Leo el ticket */
1603   6                    g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                    /**/                                              
1604   6                    break;              
1605   6                  }
1606   5                  else
1607   5                  {
1608   6                    Debug_txt_Tibbo((unsigned char *) "DCTO NO EL 100%: ");
1609   6                    send_portERR(ACERQUESE_CAJA); 
1610   6                    PantallaLCD(DIRIJASE_CAJA); 
1611   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                
1612   6                  }             
1613   5                }
1614   4            }
1615   3          }
1616   2        /*------------------------------------------------------------------------------  
1617   2            tiempo de gracia
1618   2          T_GRACIA=1 tiene tiempo de gracia 
1619   2          ------------------------------------------------------------------------------*/  
1620   2            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1621   2            {
1622   3              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1623   3              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1624   3              Debug_txt_Tibbo((unsigned char *) "\r\n");    
1625   3              analiza_tiempo(buffer_S_B,T_GRACIA);                                                // Simula Fecha Max de Salida.
1626   3            
1627   3            }
1628   2          /*------------------------------------------------------------------------------  
1629   2          comun para todos
1630   2          ------------------------------------------------------------------------------*/    
1631   2            temp=check_fechaOut(buffer_S_B+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1632   2              if(temp==1)
1633   2              {
1634   3                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n");
1635   3                  send_portERR(0xA2);                                                             /*error audio*/ 
1636   3                  send_portERR(0XE7);
1637   3                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
1638   3                                                                                    /**leo el ticket*/  
1639   3                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1640   3                              
1641   3              }
1642   2              else if (temp==2)
1643   2              {
1644   3                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1645   3                send_portERR(0xA2);                                                               /*error audio*/         
1646   3                send_portERR(0XE8);
1647   3                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1648   3                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1649   3              }
1650   2              else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 29  

1651   2              {
1652   3                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n");
1653   3                                                                                                  /* Leo el ticket */
1654   3                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1655   3              }
1656   2            
1657   2          
1658   2        
1659   2            
1660   2            
1661   2            
1662   2        break;
1663   2        case SEQ_MENSUAL:
1664   2          /*cheque la fecha de expiracion del mensual*/
1665   2        
1666   2        if (Horarios(Atributos_Expedidor [Horario]) == True)
1667   2        {
1668   3          atributos = &Atributos_Expedidor [Expira_ano];//;buffer_S1_B1[MF_EXPIRA_ANO];
1669   3          
1670   3          if ( check_fechaOut_2(atributos) == True )
1671   3            {
1672   4              /*valida el vehiculo en el loop y en la card*/
1673   4              
1674   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1675   4              
1676   4              
1677   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1678   4              
1679   4            }
1680   3              else 
1681   3            {
1682   4              send_portERR(PRMR_TARJETA_VENCIDA); 
1683   4                  
1684   4              PantallaLCD(TARJETA_VENCIDA);
1685   4              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1686   4              g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1687   4              
1688   4            }
1689   3        }
1690   2        else
1691   2        {
1692   3          
1693   3          g_cEstadoComSeqMF = SEQ_EXPULSAR_TARJ;
1694   3        }
1695   2            break;
1696   2        case SEQ_RD_S1B0:
1697   2            
1698   2            RD_MF(1, 0);                                                                    /* Leo el ticket */
1699   2            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1700   2        break;
1701   2      /*------------------------------------------------------------------------------
1702   2      Leo la Mf en el  sector 1 bloque 0
1703   2          lee el ticket
1704   2      ------------------------------------------------------------------------------*/    
1705   2          
1706   2        case SEQ_RD_S1B0_RPTA:
1707   2        
1708   2        if((temp=Trama_Validacion_P_N())!=0)
1709   2          {
1710   3            if(temp==2)
1711   3            {
1712   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;                                                           /*no ha respondido*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 30  

1713   4            }
1714   3            else if (temp==3)
1715   3            {
1716   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1717   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1718   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1719   4            }       
1720   3            else
1721   3            { 
1722   4              /*Dispensador No Responde PTO SERIE ...*/
1723   4          
1724   4              if(temp=error_rx_pto()==0)
1725   4              {
1726   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_RPTA;
1727   5              }
1728   4              else if(temp=error_rx_pto()==1)
1729   4              {
1730   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;
1731   5              }                                                       /* respuesta incorrecta*/
1732   4            }
1733   3          }
1734   2          else
1735   2          {
1736   3            g_cEstadoComSeqMF=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Atributos_Expedidor);
1737   3        
1738   3          }
1739   2        break;
1740   2      
1741   2            
1742   2      /*------------------------------------------------------------------------------
1743   2      envio a escribir en  la Mf en el  sector 1 bloque 2
1744   2          
1745   2      ------------------------------------------------------------------------------*/    
1746   2        case SEQ_WR_S1B2:
1747   2        
1748   2              
1749   2              WR_MF(1, 2,Atributos_Expedidor);//buffer_S_B+MF_TIPO_VEHICULO
1750   2              g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1751   2            
1752   2        break;
1753   2      /*------------------------------------------------------------------------------
1754   2      espero la respuesta de la escritura en  la Mf en el  sector 1 bloque 2
1755   2          
1756   2      ------------------------------------------------------------------------------*/  
1757   2        case SEQ_WR_S1B2_RPTA:
1758   2          if((temp=Trama_Validacion_P_N())!=0)
1759   2          {
1760   3            if(temp==2)
1761   3            {
1762   4            g_cEstadoComSeqMF= SEQ_WR_S1B2_RPTA;                                                            /*no ha respondido*/
1763   4            }
1764   3            else if (temp==3)
1765   3            {
1766   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1767   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1768   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1769   4            }       
1770   3            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 31  

1771   3            { 
1772   4              
1773   4                /*Dispensador No Responde PTO SERIE ...*/
1774   4          
1775   4              if(temp=error_rx_pto()==0)
1776   4              {
1777   5                g_cEstadoComSeqMF=SEQ_WR_S1B2_RPTA;
1778   5              }
1779   4              else if(temp=error_rx_pto()==1)
1780   4              {
1781   5                g_cEstadoComSeqMF=SEQ_WR_S1B2;
1782   5              }         
1783   4              
1784   4              
1785   4            
1786   4            }
1787   3          }
1788   2          else
1789   2          {
1790   3          
1791   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1792   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1793   3            g_cEstadoComSeqMF=SEQ_WR_S2B0;  
1794   3          }
1795   2          break;
1796   2        case SEQ_WR_S2B0:
1797   2          WR_MF(2, 0,buffer_S_B+MF_TIPO_VEHICULO);//s1b2
1798   2        
1799   2          g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA; 
1800   2          break;
1801   2        
1802   2        
1803   2        case SEQ_WR_S2B0_RPTA:
1804   2      
1805   2        if((temp=Trama_Validacion_P_N())!=0)
1806   2          {
1807   3            if(temp==2)
1808   3            {
1809   4            g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;                                                           /*no ha respondido*/
1810   4            }
1811   3            else if (temp==3)
1812   3            {
1813   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n");                            /* trama no valida respuesta 
             -incorrecta el leer el bloque*/
1814   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1815   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1816   4            }       
1817   3            else
1818   3            { 
1819   4                  /*Dispensador No Responde PTO SERIE ...*/
1820   4          
1821   4              if(temp=error_rx_pto()==0)
1822   4              {
1823   5                g_cEstadoComSeqMF=SEQ_WR_S2B0_RPTA;
1824   5              }
1825   4              else if(temp=error_rx_pto()==1)
1826   4              {
1827   5                g_cEstadoComSeqMF=SEQ_WR_S2B0;
1828   5              }         
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 32  

1829   4          
1830   4                  
1831   4            }
1832   3          }
1833   2          else
1834   2          {
1835   3          
1836   3            /*capturo la tarjeta*/
1837   3            lock=1;   
1838   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n");                             /* trama OK CARGA numero de tic
             -ket*/
1839   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1840   3            send_portERR(0xA1);                                                                         /*audio gracias*/ 
1841   3            send_portERR(0XFF);
1842   3            PantallaLCD(GRACIAS); 
1843   3        
1844   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n");                              /* pto serie no responde*/
1845   3            
1846   3          if (Atributos_Expedidor [ Tipo_Tarjeta]!= MENSUALIDAD)  
1847   3            {
1848   4                  
1849   4            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1850   4            }
1851   3            else
1852   3            {
1853   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1854   4            }
1855   3          }
1856   2          break;
1857   2          
1858   2          case SEQ_RTA_CAPTURE:
1859   2            
1860   2            Mov_Card(MovPos_Capture); 
1861   2            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;
1862   2            prto_ready=1;                                                       /*le da prioridad a la respuesta de la captura de tarjeta*/
1863   2            break;
1864   2      /*------------------------------------------------------------------------------
1865   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1866   2            (0) LA RESPUESTA ES OK
1867   2            (1) NO RESPONDE EL PTO SERIE
1868   2            (2) NO RECIBIDO LA TRAMA 
1869   2            (3) ERROR DE TRAMA CMD (N)
1870   2      ------------------------------------------------------------------------------*/  
1871   2      
1872   2        case SEQ_RTA_CAPTURE_RPTA:
1873   2          
1874   2          if((temp=Trama_Validacion_P_N())!=0)
1875   2          {
1876   3            if(temp==2)
1877   3            {
1878   4              
1879   4                if (ValidaSensores_Out()==1)
1880   4              {
1881   5                lock=0;
1882   5                Debug_txt_Tibbo((unsigned char *) "rele off\r\n");                          /* trama ok la tarjeta fue ejectada*/
1883   5              
1884   5              }
1885   4            
1886   4                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;     
1887   4              
1888   4              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 33  

1889   4            } 
1890   3              else if (temp==3)
1891   3            {
1892   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n");                   /* Tama incorrecta no ejecta l
             -a tarjeta*/
1893   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1894   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1895   4            } 
1896   3            else
1897   3            {
1898   4                    /*Dispensador No Responde PTO SERIE ...*/
1899   4            
1900   4            
1901   4          
1902   4              
1903   4                if(temp=error_rx_pto()==0)
1904   4                {
1905   5                  g_cEstadoComSeqMF=SEQ_RTA_CAPTURE_RPTA;   
1906   5                }
1907   4                else if(temp=error_rx_pto()==1)
1908   4                {
1909   5                  
1910   5                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1911   5                }         
1912   4          
1913   4              
1914   4            
1915   4            }       
1916   3          }
1917   2          else
1918   2          {
1919   3                    
1920   3            prto_ready=0;
1921   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1922   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1923   3            
1924   3            lock=0;
1925   3            ValTimeOutCom=3;    
1926   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                   //SEQ_INICIO;                                                     /*respuesta ok ini
             -cia revisando sensores*/
1927   3                                                          
1928   3          }     
1929   2            
1930   2      
1931   2          break;
1932   2          
1933   2      
1934   2      
1935   2      case SEQ_RD_S1B0_EJECT: 
1936   2          RD_MF(1, 0);                                                                      /**leo el ticket*/  
1937   2          g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA; 
1938   2        break;  
1939   2      /*------------------------------------------------------------------------------
1940   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1941   2      LA tarjeta no tiene pago    
1942   2        
1943   2      ------------------------------------------------------------------------------*/
1944   2        
1945   2        
1946   2        case SEQ_RD_S1B0_EJECT_RPTA:  
1947   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 34  

1948   2          if((temp=Trama_Validacion_P_N())!=0)
1949   2          {
1950   3            if(temp==2)
1951   3            {
1952   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;                                                           /*no ha respondido*/
1953   4            }
1954   3            else if (temp==3)
1955   3            {
1956   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n");                           /* trama no valida respuesta i
             -ncorrecta el leer el bloque*/
1957   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1958   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1959   4            }       
1960   3            else
1961   3            { 
1962   4                  /*Dispensador No Responde PTO SERIE ...*/
1963   4          
1964   4              if(temp=error_rx_pto()==0)
1965   4              {
1966   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT_RPTA;
1967   5              }
1968   4              else if(temp=error_rx_pto()==1)
1969   4              {
1970   5                g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;
1971   5              }         
1972   4                                                  /* respuesta incorrecta*/
1973   4            }
1974   3          }
1975   2          else
1976   2          {
1977   3            
1978   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n");                              /* trama OK CARGA numero d
             -e ticket*/
1979   3            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida
             -*/    
1980   3            
1981   3        for (temp=0; temp<16; temp++)
1982   3            {
1983   4              
1984   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1985   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1986   4              {
1987   5                break;
1988   5              }
1989   4            }
1990   3            DebugBufferMF(buffer_S1_B0,16,RESPUESTA); 
1991   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S_B,'P');    
1992   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1993   3          } 
1994   2            break;
1995   2        case SEQ_UID:
1996   2          Unique_Identifier_UID();
1997   2        g_cEstadoComSeqMF = SEQ_UID_RPTA;
1998   2        break;
1999   2        case SEQ_UID_RPTA:
2000   2            if((temp=Trama_Validacion_P_N())!=0)
2001   2          {
2002   3            if(temp==2)
2003   3            {
2004   4            g_cEstadoComSeqMF=SEQ_UID_RPTA;                                                       /*no ha respondido*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 35  

2005   4            } 
2006   3            else if (temp==3)
2007   3            {
2008   4            Debug_txt_Tibbo((unsigned char *) "SEQ_UID_RPTA FALLO\r\n");                      /* trama no valida*/
2009   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2010   4            g_cEstadoComSeqMF=SEQ_UID;                                                          /* (3) Trama invalida cmd (N)*/ 
2011   4            }     
2012   3            else
2013   3            {
2014   4              
2015   4              /*Dispensador No Responde PTO SERIE ...*/
2016   4          
2017   4              if(temp=error_rx_pto()==0)
2018   4              {
2019   5                g_cEstadoComSeqMF=SEQ_UID_RPTA;
2020   5              }
2021   4              else if(temp=error_rx_pto()==1)
2022   4              {
2023   5                g_cEstadoComSeqMF=SEQ_UID;
2024   5              }
2025   4            
2026   4            }
2027   3          }
2028   2          else
2029   2          {
2030   3            g_cEstadoComSeqMF = Analiza_Uid_Card(Atributos_Expedidor );
2031   3          }
2032   2          break;
2033   2        case SEQ_LOAD_PASSWORD:
2034   2          LoadVerify_EEprom();
2035   2          g_cEstadoComSeqMF=SEQ_MF_LINTECH;   
2036   2          break;
2037   2        case SEQ_POWER_OFF:
2038   2          Power_off();
2039   2          g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;
2040   2          break;
2041   2        case SEQ_POWER_OFF_RPTA:
2042   2          if((temp=Trama_Validacion_P_N())!=0)
2043   2          {
2044   3            if(temp==2)
2045   3            {
2046   4            g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;                                                       /*no ha respondido*/
2047   4            } 
2048   3            else if (temp==3)
2049   3            {
2050   4            Debug_txt_Tibbo((unsigned char *) "SEQ_POWER_OFF_RPTA  FALLO\r\n");                     /* trama no valida*/
2051   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2052   4            g_cEstadoComSeqMF=SEQ_POWER_OFF;                                                          /* (3) Trama invalida cmd (N)*/ 
2053   4            }     
2054   3            else
2055   3            {
2056   4              
2057   4              /*Dispensador No Responde PTO SERIE ...*/
2058   4          
2059   4              if(temp=error_rx_pto()==0)
2060   4              {
2061   5                g_cEstadoComSeqMF=SEQ_POWER_OFF_RPTA;
2062   5              }
2063   4              else if(temp=error_rx_pto()==1)
2064   4              {
2065   5                g_cEstadoComSeqMF=SEQ_POWER_OFF;
2066   5              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 36  

2067   4            
2068   4            }
2069   3          }
2070   2          else
2071   2          {
2072   3            g_cEstadoComSeqMF=SEQ_UID;
2073   3          }
2074   2          break;
2075   2        case SEQ_POWER_ON:
2076   2          Power_off();
2077   2        g_cEstadoComSeqMF = SEQ_POWER_ON_RPTA;
2078   2          break;
2079   2        case SEQ_POWER_ON_RPTA:
2080   2            if((temp=Trama_Validacion_P_N())!=0)
2081   2          {
2082   3            if(temp==2)
2083   3            {
2084   4            g_cEstadoComSeqMF=SEQ_POWER_ON_RPTA;                                                        /*no ha respondido*/
2085   4            } 
2086   3            else if (temp==3)
2087   3            {
2088   4            Debug_txt_Tibbo((unsigned char *) "SEQ_POWER_ON_RPTA  FALLO\r\n");                      /* trama no valida*/
2089   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
2090   4            g_cEstadoComSeqMF=SEQ_POWER_ON;                                                         /* (3) Trama invalida cmd (N)*/ 
2091   4            }     
2092   3            else
2093   3            {
2094   4              
2095   4              /*Dispensador No Responde PTO SERIE ...*/
2096   4          
2097   4              if(temp=error_rx_pto()==0)
2098   4              {
2099   5                g_cEstadoComSeqMF=SEQ_POWER_ON_RPTA;
2100   5              }
2101   4              else if(temp=error_rx_pto()==1)
2102   4              {
2103   5                g_cEstadoComSeqMF=SEQ_POWER_ON;
2104   5              }
2105   4            
2106   4            }
2107   3          }
2108   2          else
2109   2          {
2110   3            g_cEstadoComSeqMF=SEQ_LOAD_PASSWORD;
2111   3          }
2112   2          break;
2113   2        case SEQ_TIPO_CARD:
2114   2          Aut_Card_check_Status();
2115   2          g_cEstadoComSeqMF=SEQ_REQUEST;            
2116   2          break;
2117   2      /*------------------------------------------------------------------------------
2118   2      expulsa la tarjeta por que no pertenece a MF50
2119   2      ------------------------------------------------------------------------------*/    
2120   2        
2121   2        case SEQ_EXPULSAR_TARJ:
2122   2            Card_Insercion(Inhabilita); 
2123   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
2124   2        break;
2125   2        
2126   2        
2127   2        case SEQ_EXPULSAR_CHECK:
2128   2        if((temp=Trama_Validacion_P_N())!=0)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 37  

2129   2          {
2130   3            if(temp==2)
2131   3            {
2132   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
2133   4            }
2134   3            else if (temp==3)
2135   3            {
2136   4              
2137   4                g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
2138   4            }       
2139   3            else
2140   3            { 
2141   4                  /*Dispensador No Responde PTO SERIE ...*/
2142   4          
2143   4              if(temp=error_rx_pto()==0)
2144   4              {
2145   5                g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
2146   5              }
2147   4              else if(temp=error_rx_pto()==1)
2148   4              {
2149   5                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
2150   5              }         
2151   4                                                
2152   4            }
2153   3                                                                                
2154   3          }
2155   2          else
2156   2          {
2157   3            lock=0;
2158   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
2159   3          }   
2160   2          
2161   2          break;
2162   2          
2163   2        case SEQ_EXPULSAR:
2164   2          Mov_Card(MovPos_EjectFront);
2165   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
2166   2        
2167   2        case SEQ_EXPULSAR_FROM:                       
2168   2          if((temp=Trama_Validacion_P_N())!=0)
2169   2          {
2170   3            if(temp==2)
2171   3            {
2172   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
2173   4            } 
2174   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
2175   3          }
2176   2          else
2177   2          {
2178   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
2179   3          }   
2180   2          
2181   2        break;
2182   2        
2183   2      /*------------------------------------------------------------------------------
2184   2      expulsa la tarjeta por que no pertenece a MF50
2185   2      ------------------------------------------------------------------------------*/      
2186   2          
2187   2              default:
2188   2              g_cEstadoComSeqMF=SEQ_INICIO; 
2189   2              break;  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       09/28/2020 11:10:44 PAGE 38  

2190   2            
2191   2        } 
2192   1      }
2193          
2194          
2195            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5958    ----
   CONSTANT SIZE    =   1814    ----
   XDATA SIZE       =    102      71
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
